diff --git CMakeLists.txt CMakeLists.txt
index f02ee51..87a68c0 100644
--- CMakeLists.txt
+++ CMakeLists.txt
@@ -36,11 +36,11 @@
 #
 # For an iOS static library, use
 #
-#   cmake <path-to-freetype2-src-dir> -D IOS_PLATFORM=OS -G Xcode
+#   cmake -D IOS_PLATFORM=OS -G Xcode <path-to-freetype2-src-dir>
 #
 # or
 #
-#   cmake <path-to-freetype2-src-dir> -D IOS_PLATFORM=SIMULATOR -G Xcode
+#   cmake -D IOS_PLATFORM=SIMULATOR -G Xcode <path-to-freetype2-src-dir>
 #
 # Please refer to the cmake manual for further options, in particular, how
 # to modify compilation and linking parameters.
@@ -68,6 +68,11 @@
 #   only if it is available.  Example:
 #
 #     cmake ... -DWITH_ZLIB=ON -DWITH_HarfBuzz=OFF ...
+#
+# . Installation of FreeType can be controlled with the CMake variables
+#   `SKIP_INSTALL_HEADERS', `SKIP_INSTALL_LIBRARIES', and `SKIP_INSTALL_ALL'
+#   (this is compatible with the same CMake variables in zlib's CMake
+#   support).
 
 
 cmake_minimum_required(VERSION 2.6)
@@ -102,7 +107,7 @@ if (APPLE)
     set(BUILD_SHARED_LIBS OFF)
 
     set(CMAKE_TOOLCHAIN_FILE
-      ${PROJECT_SOURCE_DIR}/builds/cmake/iOS.cmake)
+      ${CMAKE_SOURCE_DIR}/builds/cmake/iOS.cmake)
   endif ()
 else ()
   if (DEFINED IOS_PLATFORM)
@@ -173,7 +178,7 @@ foreach (d ZLIB BZip2 PNG HarfBuzz)
 
   if (${d}_FOUND OR ${D}_FOUND)
     message(STATUS "Building with ${d}")
-  endif()
+  endif ()
 endforeach ()
 
 
@@ -383,28 +388,33 @@ endif ()
 
 # Installations
 # Note the trailing slash in the argument to the `DIRECTORY' directive
-install(DIRECTORY ${PROJECT_SOURCE_DIR}/include/
-  DESTINATION include/freetype2
-  PATTERN "internal" EXCLUDE
-  PATTERN "ftconfig.h" EXCLUDE
-  PATTERN "ftoption.h" EXCLUDE
-)
-install(FILES
-  ${PROJECT_BINARY_DIR}/include/freetype/config/ftconfig.h
-  ${PROJECT_BINARY_DIR}/include/freetype/config/ftoption.h
-  DESTINATION include/freetype2/freetype/config
-)
-install(TARGETS freetype
-  EXPORT freetype-targets
-  RUNTIME DESTINATION bin
-  LIBRARY DESTINATION lib
-  ARCHIVE DESTINATION lib
-  FRAMEWORK DESTINATION Library/Frameworks
-)
-install(EXPORT freetype-targets
-  DESTINATION lib/cmake/freetype
-  FILE freetype-config.cmake
-)
+if (NOT SKIP_INSTALL_HEADERS AND NOT SKIP_INSTALL_ALL)
+  install(DIRECTORY ${PROJECT_SOURCE_DIR}/include/
+    DESTINATION include/freetype2
+    PATTERN "internal" EXCLUDE
+    PATTERN "ftconfig.h" EXCLUDE
+    PATTERN "ftoption.h" EXCLUDE
+    )
+  install(FILES
+    ${PROJECT_BINARY_DIR}/include/freetype/config/ftconfig.h
+    ${PROJECT_BINARY_DIR}/include/freetype/config/ftoption.h
+    DESTINATION include/freetype2/freetype/config
+    )
+endif ()
+
+if (NOT SKIP_INSTALL_LIBRARIES AND NOT SKIP_INSTALL_ALL)
+  install(TARGETS freetype
+    EXPORT freetype-targets
+    RUNTIME DESTINATION bin
+    LIBRARY DESTINATION lib
+    ARCHIVE DESTINATION lib
+    FRAMEWORK DESTINATION Library/Frameworks
+    )
+  install(EXPORT freetype-targets
+    DESTINATION lib/cmake/freetype
+    FILE freetype-config.cmake
+    )
+endif ()
 
 
 # Packaging
diff --git ChangeLog ChangeLog
index a19b4de..ffc0a9c 100644
--- ChangeLog
+++ ChangeLog
@@ -1,3 +1,539 @@
+2016-04-16  David Capello  <davidcapello@gmail.com>
+
+	[cmake] Honor SKIP_INSTALL_* settings (as used in zlib).
+
+	As FreeType depends on zlib, if we don't install zlib (e.g., because
+	we defined SKIP_INSTALL_ALL), FreeType cannot be installed, too
+	(cmake triggers an error saying that FreeType cannot be installed
+	because zlib target isn't in the export set).
+
+	* CMakeLists.txt: Honor `SKIP_INSTALL_HEADERS',
+	`SKIP_INSTALL_LIBRARIES', and `SKIP_INSTALL_ALL' settings.
+
+2016-04-16  Behdad Esfahbod  <behdad@behdad.org>
+
+	[truetype] Another fix for non-intermediate GX tuples.
+
+	* src/truetype/ttgxvar.c (ft_var_apply_tuple): Add some missing
+	cases.
+
+2016-04-12  Alexei Podtelezhnikov  <apodtele@gmail.com>
+
+	Remove forgotten macro.
+
+	* include/freetype/internal/internal.h
+	[FT_INTERNAL_POSTSCRIPT_GLOBALS_H]: Remove.
+
+2016-04-09  Werner Lemberg  <wl@gnu.org>
+
+	[autofit] Add support for Georgian scripts.
+
+	Georgian is problematic, since `uppercase' forms of Mkhedruli
+	(called Mtavruli) are not yet defined in Unicode, which means that
+	proper blue zones can't be defined.  However, there is already a
+	proposal submitted to Unicode; see
+
+	  http://www.unicode.org/L2/L2016/16034-n4707-georgian.pdf
+
+	Additionally, due to historical reasons, Unicode treats Khutsuri as
+	the same script as Mkhedruli, and so does OpenType.  However, since
+	the two scripts have completely different shapes it can happen that
+	blue zones differ considerably.  The tag `geok' used here (derived
+	from ISO 15924) to differentiate the two scripts is not an OpenType
+	tag in use.  If we now have a font that contains both glyphs for
+	Mkhedruli and Khutsuri, and it uses OpenType features for both also,
+	HarfBuzz unavoidably treats all glyphs as `geor'.  As a consequence,
+	blue zones for `geok' are not used for glyphs involved in the
+	OpenType features.
+
+	An issue not yet resolved is which OpenType feature should be used
+	to access Mtavruli glyph shapes; right now, FreeType doesn't set up
+	support for them, but it is easy to add them later on as soon as
+	more information is available.
+
+	* src/autofit/afblue.dat: Add blue zone data for Georgian.
+
+	* src/autofit/afblue.c, src/autofit/afblue.h: Regenerated.
+
+	* src/autofit/afscript.h: Add Georgian standard characters.
+
+	* src/autofit/afranges.c: Add Georgian data.
+
+	* src/autofit/afstyles.h: Add Georgian data.
+
+2016-04-05  Werner Lemberg  <wl@gnu.org>
+
+	[autofit] Provide dummy blue zone for pseudo script `none'.
+
+	Even if the dummy hinter is used as the handler for `none' (which
+	doesn't use blue zones), it is more consistent than the old value
+	(which was 0), pointing to Arabic...
+
+	* src/autofit/afblue.dat: Add `AF_BLUE_STRINGSET_NONE'.
+	* src/autofit/afblue.c, src/autofit/afblue.h: Regenerated.
+
+	* src/autofit/afstyles.h (none_dflt): Use AF_BLUE_STRINGSET_NONE.
+
+2016-03-30  Werner Lemberg  <wl@gnu.org>
+
+	* src/pfr/pfrload.c (pfr_aux_name_load): Thinko (#47567).
+
+2016-03-30  Werner Lemberg  <wl@gnu.org>
+
+	* src/pfr/pfrload.c (pfr_log_font_count): Better font size estimate.
+
+2016-03-30  Werner Lemberg  <wl@gnu.org>
+
+	* src/pfr/pfrload.c (pfr_aux_name_load): Fix memory leak (#47567).
+
+2016-03-29  Werner Lemberg  <wl@gnu.org>
+
+	* src/base/ftadvanc.c (FT_Get_Advances): Fix invalid left shift.
+
+2016-03-29  Werner Lemberg  <wl@gnu.org>
+
+	[pfr] Fix binary search (#47514).
+
+	* src/pfr/pfrsbit.c (pfr_lookup_bitmap_data): Handle border
+	conditions correctly.
+
+2016-03-29  Werner Lemberg  <wl@gnu.org>
+
+	[pfr] Minor.
+
+	* src/pfr/pfrsbit.c (pfr_lookup_bitmap_data): Replace `left',
+	`right', and `middle' with `min', `max', and `mid' as used in other
+	FreeType binary search code.
+	(pfr_load_bitmap_metrics): Fix invalid left shift.
+
+2016-03-29  Werner Lemberg  <wl@gnu.org>
+
+	* src/pfr/pfrtypes.h: Replace all enums with macros.
+
+	We need `~FOO' to unset bits, and only with unsigned values (which
+	`enum' isn't normally) this works cleanly.
+
+2016-03-26  Werner Lemberg  <wl@gnu.org>
+
+	[pfr] Robustify bitmap strike handling (#47514).
+
+	We did a binary search for a charcode without ensuring that the
+	searched data is ordered.  Validating the order is now done lazily,
+	this is, the first access to a bitmap glyph triggers the order check
+	in the corresponding bitmap strike.
+
+	* src/pfr/pfrtypes.h (PFR_BitmapFlags): New values
+	`PFR_BITMAP_VALID_CHARCODES' and `PFR_BITMAP_CHARCODES_VALIDATED'.
+
+	* src/pfr/pfrsbit.c (pfr_lookup_bitmap_data): Make `flags' argument
+	a pointer.  Handle new PFR_BITMAP_XXX flags.
+	(pfr_slot_load_bitmap): Updated.
+
+2016-03-26  Werner Lemberg  <wl@gnu.org>
+
+	[pfr] Fix handling of compound glyphs.
+
+	Extra items are indicated with different bit positions.
+
+	* src/pfr/pfrtypes.h (PFR_GlyphFlags): Replace
+	`PFR_GLYPH_EXTRA_ITEMS' with `PFR_GLYPH_SIMPLE_EXTRA_ITEMS' and
+	`PFR_GLYPH_COMPOUND_EXTRA_ITEMS'.
+
+	* src/pfr/pfrgload.c (pfr_glyph_load_simple,
+	pfr_glyph_load_compound): Use them.
+
+2016-03-25  Werner Lemberg  <wl@gnu.org>
+
+	[pfr] Minor.
+
+	* src/pfr/pfrsbit.c, src/pfr/pfrobjs.c: Use flag names instead of
+	bare numbers.
+
+2016-03-25  Werner Lemberg  <wl@gnu.org>
+
+	[pfr] Various clang sanitizer fixes.
+
+	* src/pfr/pfrsbit.c (pfr_load_bitmap_metrics): Correctly handle
+	signed nibbles.
+	(pfr_slot_load_bitmap): Correctly exit frame in case of error.
+	Fix invalid left shifts.
+
+2016-03-23  Werner Lemberg  <wl@gnu.org>
+
+	Rename `VERSION.DLL' (#47472).
+
+	* docs/VERSION.DLL: Renamed to...
+	* docs/VERSIONS.TXT: ...this.
+
+2016-03-23  Werner Lemberg  <wl@gnu.org>
+
+	[raster, smooth] Directly test outline size (#47500).
+
+	This improves stand-alone compilation.
+
+	* src/base/ftoutln.c (FT_Outline_Render): Move cbox size test to...
+
+	* src/raster/ftraster.c (ft_black_render), src/smooth/ftgrays.c
+	(gray_raster_render): ...these functions.
+
+2016-03-23  Werner Lemberg  <wl@gnu.org>
+
+	[raster, smooth] Fix some clang sanitizer runtime issues.
+
+	* src/raster/ftraster.c (ft_black_reset, ft_black_set_mode,
+	ft_black_render): Harmonize signatures with `ftimage.h'.
+
+	* src/smooth/ftgrays.c (gray_raster_render, gray_raster_reset):
+	Ditto.
+
+2016-03-22  Werner Lemberg  <wl@gnu.org>
+
+	* src/truetype/ttgload.c (TT_Load_Simple_Glyph): Minor.
+
+	This fixes an AddressSanitizer issue:
+
+	  ttgload.c:430:7: runtime error: null pointer passed as argument 1,
+	                   which is declared to never be null
+
+2016-03-21  Werner Lemberg  <wl@gnu.org>
+
+	* src/autofit/afhints.c (af_glyph_hints_reload): Thinko.
+
+	This fixes the previous commit to this file.
+
+2016-03-21  Alexei Podtelezhnikov  <apodtele@gmail.com>
+
+	[smooth] Partly revert recent changes.
+
+	* src/smooth/ftgrays.c (gray_conic_to, gray_cubic_to): Rework
+	conditions to fix rendering issues.
+
+2016-03-20  Werner Lemberg  <wl@gnu.org>
+
+	[autofit] Show `near' points in tracing.
+
+	* src/autofit/afhints.h (AF_FLAG_NEAR): New macro.
+
+	* src/autofit/afhints.c (af_glyph_hints_dump_points): Implement it.
+	(af_glyph_hints_reload): Handle AF_FLAG_NEAR.
+
+2016-03-18  Alexei Podtelezhnikov  <apodtele@gmail.com>
+
+	[smooth] Minor refactoring and microoptimizations.
+
+	* src/smooth/ftgrays.c (gray_render_conic, gray_render_cubic): Move
+	band clipping from here.
+	(gray_conic_to, gray_cubic_to): ... to here.
+	(gray_rander_line, gray_render_scanline): Initialize variables closer
+	to their use.
+
+2016-03-17  Alexei Podtelezhnikov  <apodtele@gmail.com>
+
+	[smooth] Minor refactoring.
+
+	* src/smooth/ftgrays.c (gray_render_conic, gray_render_cubic): Move
+	upscaling from here.
+	(gray_conic_to, gray_cubic_to): ... to here.
+
+2016-03-15  Werner Lemberg  <wl@gnu.org>
+
+	* src/autofit/aflatin.c (af_latin_compute_stem_width): Optimize.
+
+2016-03-14  Alexei Podtelezhnikov  <apodtele@gmail.com>
+
+	[smooth] Temporarily revert 6eb6158dd787 (#47114).
+
+	* src/smooth/ftgrays.c (gray_render_line): Old implementation.
+
+2016-03-12  Werner Lemberg  <wl@gnu.org>
+
+	[ftfuzzer] Improve coverage of rasterfuzzer.
+
+	* src/tools/ftfuzzer/rasterfuzzer.cc (LLVMFuzzerTestOneInput): Use
+	input data for `tags' array also.
+	Trim input data to get more positive hits.
+
+2016-03-11  Pavlo Denysov  <paul.kiev+savannah@gmail.com>
+
+	Fix CMake issues for iOS (patch #8941).
+
+	* CMakeLists.txt (CMAKE_TOOLCHAIN_FILE): Fix directory.
+	* builds/cmake/iOS.cmake: No longer enforce gcc.
+
+2016-03-09  Behdad Esfahbod  <behdad@behdad.org>
+
+	[truetype] Fix handling of non-intermediate GX tuples.
+
+	We probably did not notice this as all fonts we tested had only
+	tuple_coords[i] be +1 or -1 for non-intermediate tuples.
+
+	* src/truetype/ttgxvar.c (ft_var_apply_tuple): Implement it.
+
+2016-03-06  Alexei Podtelezhnikov  <apodtele@gmail.com>
+
+	[base] Refuse to render enormous outlines (#47114).
+
+	The goal is to avoid integer overflows in the rendering algorithms.
+	The limit is chosen arbitrarily at some 2^18 pixels, which should be
+	enough for modern devices including printers.
+
+	* src/base/ftoutln.c (FT_Outline_Render): Check CBox and reject
+	enormous outlines.
+
+2016-03-06  Alexei Podtelezhnikov  <apodtele@gmail.com>
+
+	[smooth] Replace left shifts with multiplications (#47114).
+
+	* src/smooth/ftgrays.c (SUBPIXELS, UPSCALE, DOWNSCALE): Do it.
+
+2016-03-05  Werner Lemberg  <wl@gnu.org>
+
+	[autofit] Avoid excessive stem length rounding (#25392).
+
+	* src/autofit/aflatin.c (af_latin_compute_stem_width): Add argument
+	to pass difference between hinted and unhinted position of base
+	point; use this to adjust the stem width depending on the PPEM so
+	that it doesn't become too large under certain circumstances.
+	Update all callers using value 0 for this argument except...
+	(af_latin_align_linked_edge): Pass position delta of base point to
+	`af_latin_compute_stem_width'.
+
+2016-03-05  J Raynor <jxraynor@gmail.com>
+
+	Make FreeType compile on AIX out of the box.
+
+	* builds/unix/configure.raw (XX_ANSIFLAGS): Don't use `-ansi' on
+	AIX.
+
+2016-03-01  Werner Lemberg  <wl@gnu.org>
+	    Kostya Serebryany  <kcc@google.com>
+
+	[ftfuzzer] Add unit for testing smooth and black rasterizers.
+
+	* src/tools/ftfuzzer/rasterfuzzer.cc: New file.
+
+2016-03-01  Werner Lemberg  <wl@gnu.org>
+
+	[autofit] Fix reallocation error introduced in 2016-02-27 (#47310).
+
+	* src/autofit/aflatin.c (af_latin_hints_compute_segments): Reassign
+	`prev_segment' after reallocation.
+
+2016-03-01  Werner Lemberg  <wl@gnu.org>
+
+	Fix clang warnings.
+
+	* src/autofit/aflatin.c (af_latin_hints_compute_segments): Use
+	FT_UShort for `min_flags' and `max_flags'.
+	Initialize `prev_*' variables.
+
+	* src/cff/cffobjs.c (cff_face_init) [FT_DEBUG_LEVEL_TRACE]: Fix
+	types of local variables.
+
+	* src/smooth/ftgrays.c (gray_dump_cells) [FT_DEBUG_LEVEL_TRACE]:
+	Update `printf' format string.
+
+	* src/tools/ftfuzzer/ftfuzzer.cc (setIntermediateAxis): Add cast.
+	(LLVMFuzzerTestOneInput): Fix loop type.
+
+2016-02-29  Werner Lemberg  <wl@gnu.org>
+
+	[autofit] Add blue-zone support for Sinhala script.
+
+	This essentially moves the Sinhala script from the `Indic' hinter to
+	the `Latin' hinter.
+
+	* src/autofit/afblue.dat: Add blue zone data for Sinhala.
+
+	* src/autofit/afblue.c, src/autofit/afblue.h: Regenerated.
+
+	* src/autofit/afscript.h: Add Sinhala standard character and move data
+	out of AF_CONFIG_OPTION_INDIC block.
+
+	* src/autofit/afranges.c: Move Sinhala data out of
+	AF_CONFIG_OPTION_INDIC block.
+
+	* src/autofit/afstyles.h: Update Sinhala data; in particular, use
+	AF_WRITING_SYSTEM_LATIN.
+
+2016-02-27  Werner Lemberg  <wl@gnu.org>
+
+	[autofit] Properly handle spikes pointing to the x-axis.
+
+	An example that gets better rendered is glyph `uusignTaml' (glyph
+	index 2286) in font `FreeSerif.ttf' (Version 0412.2263) at 22ppem.
+
+	* src/autofit/aflatin.c (af_latin_hints_compute_segments): Properly
+	handle segments where the last point of the first segment is
+	identical to the first point in the second one.  This can happen for
+	malformed fonts or spikes.  We either merge the new segment with the
+	previous one (both segments point into the same direction), or we
+	discard the shorter segment if they point into different directions.
+
+2016-02-27  Werner Lemberg  <wl@gnu.org>
+
+	[autofit] Minor code clean-up.
+
+	* src/autofit/aflatin.c (af_latin_hints_compute_segments): Change
+	some local variable names to better differentiate between values
+	along a segment and values orthogonal to it.
+
+2016-02-26  Werner Lemberg  <wl@gnu.org>
+
+	[autofit] Improve BOUND action.
+
+	In complex glyph shapes, the original logic was too simple to cater
+	for situations that would actually need something similar to PS Hint
+	masks.  This fix should alleviate the worst cases.
+
+	* src/autofit/aflatin.c (af_latin_hint_edges): Don't allow
+	complete disappearance of stems.
+
+2016-02-25  Werner Lemberg  <wl@gnu.org>
+
+	[autofit] Add blue-zone support for Tamil script.
+
+	This essentially moves the Tamil script from the `Indic' hinter to
+	the `Latin' hinter.
+
+	* src/autofit/afblue.dat: Add blue zone data for Tamil.
+
+	* src/autofit/afblue.c, src/autofit/afblue.h: Regenerated.
+
+	* src/autofit/afscript.h: Add Tamil standard character and move data
+	out of AF_CONFIG_OPTION_INDIC block.
+
+	* src/autofit/afranges.c: Move Tamil data out of
+	AF_CONFIG_OPTION_INDIC block.
+
+	* src/autofit/afstyles.h: Update Tamil data; in particular, use
+	AF_WRITING_SYSTEM_LATIN.
+
+2016-02-18  Werner Lemberg  <wl@gnu.org>
+
+	[autofit] Add blue-zone support for Malayalam script.
+
+	This essentially moves the Malayalam script from the `Indic' hinter
+	to the `Latin' hinter.
+
+	* src/autofit/afblue.dat: Add blue zone data for Malayalam.
+
+	* src/autofit/afblue.c, src/autofit/afblue.h: Regenerated.
+
+	* src/autofit/afscript.h: Add Malayalam standard characters and move
+	data out of AF_CONFIG_OPTION_INDIC block.
+
+	* src/autofit/afranges.c: Move Malayalam data out of
+	AF_CONFIG_OPTION_INDIC block.
+
+	* src/autofit/afstyles.h: Update Malayalam data; in particular, use
+	AF_WRITING_SYSTEM_LATIN.
+
+2016-02-16  Alexei Podtelezhnikov  <apodtele@gmail.com>
+
+	[smooth] Fix integer overflow (#47114).
+
+	* src/smooth/ftgrays.c (TArea): Make it unconditionally `long'.
+
+2016-02-15  Werner Lemberg  <wl@gnu.org>
+
+	* src/cff/cffparse.c (cff_parse_multiple_master): Improve tracing.
+
+2016-02-15  Werner Lemberg  <wl@gnu.org>
+
+	[cff] Handle T2 operator only with old CFF engine (#47157).
+
+	* src/cff/cffparse.c (cff_parser_run) <opcode 31>: Enclose with
+	#ifdef CFF_CONFIG_OPTION_OLD_ENGINE...#endif.
+
+2016-02-15  Werner Lemberg  <wl@gnu.org>
+
+	[cff] Partially handle `load' and `store' ops in old CFF engine.
+
+	Now all glyphs of MM CFFs like `ITCGaramondMM-It.otf' can be
+	displayed.
+
+	* src/cff/cffgload.c (cff_decoder_parse_charstrings) <cff_op_store,
+	cff_op_load>: Partially implement it.
+
+	* src/cff/cffparse.c (cff_parser_init): Add new parameter to pass
+	the number of Multiple Master axes.
+	Update all callers.
+	(cff_parse_multiple_master): Get number of axes.
+	(cff_parser_run) <opcode 31>: Updated.
+	* src/cff/cffparse.h: Updated.
+	(CFF_ParserRec): Add `num_axes' field.
+
+	* src/cff/cffload.c: Updated.
+
+	* src/cff/cfftypes.h (CFF_FontRecDictRec): Add `num_axes' field.
+
+2016-02-15  Werner Lemberg  <wl@gnu.org>
+
+	[cff] Correctly trace SIDs that contain NULL bytes.
+
+	We need this to properly trace Multiple Master CFFs, which contain
+	two SIDs that are charstrings.
+
+	This commit makes FreeType also show the last SID, omitted
+	previously due to a bug.
+
+	* src/cff/cfftypes.h (CFF_FontRec): Add `string_pool_size' field.
+
+	* src/cff/cffload.c (cff_index_get_pointers): Add argument to return
+	the pool size.
+	Update all callers.
+
+	* src/cff/cffobjs.c (cff_face_init) [FT_DEBUG_LEVEL_TRACE]: Directly
+	access `cff->strings' to display the non-default strings.
+
+2016-02-14  Werner Lemberg  <wl@gnu.org>
+
+	* src/base/fthash.c: Include FT_INTERNAL_MEMORY_H.
+
+2016-02-14  Werner Lemberg  <wl@gnu.org>
+
+	* src/cff/cffparse.c: Include `cffgload.h'.
+
+	Problem reported by Colin Walters <walters@verbum.org>.
+
+2016-02-14  Werner Lemberg  <wl@gnu.org>
+
+	[cff] Make old CFF engine show MM CFFs (without variations).
+
+	The new code only displays the first master in the font.
+
+	* src/cff/cffgload.c (cff_decode_parse_charstrings): Add new
+	parameter to allow function calls from dictionaries also.
+	<cff_op_blend>: Partially implement it.
+	Update all callers.
+	* src/cff/cffgload.h: Updated.
+
+	* src/cff/cffparse.c (cff_parser_init): Add new parameter to pass the
+	number of Multiple Master designs.
+	Update all callers.
+	(cff_parse_multiple_master): New function to rudimentarily parse
+	operator.
+	(cff_parser_run): Handle `T2' operator.
+	* src/cff/cffparse.h: Updated.
+	(CFF_ParserRec): Add `num_designs' field.
+
+	* src/cff/cffload.c: Updated.
+
+	* src/cff/cfftoken.h: Handle `MultipleMaster' operator.
+
+	* src/cff/cfftypes.h (CFF_FontRecDictRec): Add `num_designs' field.
+
+	* src/sfnt/sfobjs.c (sfnt_init_face): Don't handle `fvar' table for
+	MM CFFs.
+
+2016-02-09  Werner Lemberg  <wl@gnu.org>
+
+	[docmaker] Don't emit trailing newlines.
+
+	* src/tools/docmaker/tohtml.py (HtmlFormatter::make_html_code):
+	Use `rstrip'.
+
 2016-02-07  Werner Lemberg  <wl@gnu.org>
 
 	* Version 2.6.3 released.
@@ -561,7 +1097,7 @@
 	[bdf] Remove dead code (#46625).
 
 	The BDF specification only allows decimal numbers, no octal or
-	hexidecimal decoding is needed.
+	hexadecimal decoding is needed.
 
 	* src/bdf/bdflib.c (_bdf_atoul, _bdf_atol, _bdf_atous,
 	_bdf_atos): Remove unused code and parameters.
@@ -734,7 +1270,7 @@
 	* src/autofit/afglobal.c: s/hbshim.h/afshaper.h/.
 	(af_face_globals_compute_style_coverage): Updated.
 
-	* src/autofit/afglocal.h: s/hbshim.h/afshaper.h/.
+	* src/autofit/afglobal.h: s/hbshim.h/afshaper.h/.
 
 	* src/autofit/autofit.c: s/hbshim.c/afshaper.c/.
 
@@ -1700,7 +2236,7 @@
 
 2015-10-04  Werner Lemberg  <wl@gnu.org>
 
-	[bzip2, gzip] Avoid access of unitialized memory (#46109).
+	[bzip2, gzip] Avoid access of uninitialized memory (#46109).
 
 	* src/bzip2/ftbzip2.c (ft_bzip2_file_fill_input), src/gzip/ftgzip.c
 	(ft_gzip_file_fill_input): In case of an error, adjust the limit to
@@ -1708,7 +2244,7 @@
 
 2015-10-03  Werner Lemberg  <wl@gnu.org>
 
-	[bzip2, gzip] Avoid access of unitialized memory (#46109).
+	[bzip2, gzip] Avoid access of uninitialized memory (#46109).
 
 	* src/bzip2/ftbzip2.c (ft_bzip2_file_fill_output), src/gzip/ftgzip.c
 	(ft_gzip_file_fill_output): In case of an error, adjust the limit to
@@ -2117,7 +2653,7 @@
 	[raster,smooth] Microoptimizations.
 
 	* src/raster/ftraster.c (Insert_Y_Turn, Finalize_Profile_Table,
-	Beziier_Up, ): Use do-while loops.
+	Bezier_Up, ): Use do-while loops.
 
 	* src/smooth/ftgrays.c (gray_render_scanline, gray_render_line,
 	gray_convert_glyph): Ditto.
@@ -2248,7 +2784,7 @@
 	[base] Improve emboldener (#45596).
 
 	* src/base/ftoutln.c (FT_Outline_EmboldenXY): Correct displacement
-	of zero-lenght segments.
+	of zero-length segments.
 
 2015-08-16  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
@@ -2323,7 +2859,7 @@
 	* src/type1/t1gload.c (T1_Load_Glyph): Directly modify advances only
 	if font matrix is not trivial.
 	* src/cff/cffgload.c (cff_slot_load): Ditto.
-	* sff/cid/cidgload.c (cid_slot_load_glyph): Ditto for advances and the
+	* src/cid/cidgload.c (cid_slot_load_glyph): Ditto for advances and the
 	entire outline.
 
 2015-08-11  Werner Lemberg  <wl@gnu.org>
@@ -3068,7 +3604,7 @@
 
 	* src/autofit/afhints.h (AF_HINTS_DO_WARP): New macro.
 
-	* src/autofi/aflatin.c (af_latin_hints_apply)
+	* src/autofit/aflatin.c (af_latin_hints_apply)
 	[AF_CONFIG_OPTION_USE_WARPER]: Use `AF_HINTS_DO_WARP' to control use
 	of warper.
 
@@ -3699,7 +4235,7 @@
 	* src/pfr/pfrload.c (pfr_extra_item_load_font_id): Ditto.
 	* src/psaux/psobjs.c (ps_table_add), src/psaux/psobjs.h: Ditto.
 	* src/type1/t1load.c (parse_blend_axis_types, parse_encoding,
-	parse_chharstrings, parse_dict): Ditto.
+	parse_charstrings, parse_dict): Ditto.
 	* src/type42/t42parse.c (t42_parse_encoding, t42_parse_charstrings,
 	t42_parse_dict): Ditto.
 
@@ -3772,7 +4308,7 @@
 	* include/internal/ftstream.h (FT_Stream_Pos): Return `FT_ULong'.
 
 	* src/base/ftoutln.c, src/base/ftrfork.c, src/base/ftstream.c:
-	Signedess fixes.
+	Signedness fixes.
 
 2015-02-16  Werner Lemberg  <wl@gnu.org>
 
@@ -4290,7 +4826,7 @@
 
 2015-01-11  Werner Lemberg  <wl@gnu.org>
 
-	[truetype] Prettyfing.
+	[truetype] Prettifying.
 
 	* src/truetype/ttinterp.c (project, dualproj, fast_project,
 	fast_dualproj): Rename to...
@@ -4322,7 +4858,7 @@
 	[truetype] More macro expansions.
 
 	* src/truetype/ttinterp.c (INS_ARG): Remove macro by expansion,
-	adjusting funtion calls where necessary.
+	adjusting function calls where necessary.
 	(FT_UNUSED_ARG): Removed, no longer needed.
 
 2015-01-10  Werner Lemberg  <wl@gnu.org>
diff --git ChangeLog.20 ChangeLog.20
index 360bb48..2f5c689 100644
--- ChangeLog.20
+++ ChangeLog.20
@@ -330,7 +330,7 @@
 
 2001-12-22  Francesco Zappa Nardelli  <Francesco.Zappa.Nardelli@ens.fr>
 
-	* src/pfc/pcfread.c (pcf_load_font): Handle property `POINT_SIZE'
+	* src/pcf/pcfread.c (pcf_load_font): Handle property `POINT_SIZE'
 	and fix incorrect computation of `available_sizes'.
 
 2001-12-22  David Turner  <david@freetype.org>
@@ -412,7 +412,7 @@
 	* src/cff/cffgload.h: Updated.
 	* src/cff/cffobjs.c: Include FT_INTERNAL_POSTSCRIPT_HINTS_H.
 	(CFF_Size_Get_Globals_Funcs, CFF_Size_Done, CFF_Size_Init,
-	CFF_Size_Reset, CFF_GlyphSlot_Done, CFF_GLyphSlot_Init): New
+	CFF_Size_Reset, CFF_GlyphSlot_Done, CFF_GlyphSlot_Init): New
 	functions.
 	(CFF_Init_Face): Renamed to ...
 	(CFF_Face_Init): This.
@@ -1176,7 +1176,7 @@
 
 	* include/freetype/internal/psaux.h (PS_Table): Use FT_Offset for
 	`cursor' and `capacity'.
-	* src/psaux/psobjc.c (reallocate_t1_table): Use FT_Long for second
+	* src/psaux/psobjs.c (reallocate_t1_table): Use FT_Long for second
 	parameter.
 	(PS_Table_Add): Use FT_Offset for `new_size'.
 
@@ -1710,7 +1710,7 @@
 	`FT_Err_*' with `CFF_Err_*'.
 	* src/cid/cidparse.c: Replaced `FT_Err_*' with `T1_Err_*'.
 	* src/psaux/psobjs.c, src/psaux/t1decode.c: Ditto.
-	* src/sfnt/sfobcs.c, src/sfnt/ttload.c: Replaced `FT_Err_*' with
+	* src/sfnt/sfobjs.c, src/sfnt/ttload.c: Replaced `FT_Err_*' with
 	`TT_Err_*'.
 	* src/truetype/ttgload.c, src/truetype/ttobjs.c: Ditto.
 	* src/type1/t1gload.c, src/type1/t1load.c, src/type1/t1objs.c,
@@ -1730,7 +1730,7 @@
 	* src/cff/cffobjs.c (CFF_Init_Face, CFF_Done_Face): Use
 	FT_LOCAL_DEF.
 	* src/cid/cidobjs.c (CID_Done_Driver): Ditto.
-	* src/trutype/ttobjs.c (TT_Init_Face, TT_Done_Face, TT_Init_Size):
+	* src/truetype/ttobjs.c (TT_Init_Face, TT_Done_Face, TT_Init_Size):
 	Ditto.
 	* src/type1/t1objs.c (T1_Done_Driver): Ditto.
 	* src/pcf/pcfdriver.c (PCF_Done_Face): Ditto.
diff --git ChangeLog.21 ChangeLog.21
index a61682d..ba743ef 100644
--- ChangeLog.21
+++ ChangeLog.21
@@ -327,7 +327,7 @@
 	Blaskey <listtarget@danbala.com>).
 
 	* src/sfnt/ttcmap.h (TT_CMap): Add member `unsorted'.
-	* src/sfnt/ttcmac.c: Use SFNT_Err_Ok where appropriate.
+	* src/sfnt/ttcmap.c: Use SFNT_Err_Ok where appropriate.
 
 	(tt_cmap0_validate, tt_cmap2_validate, tt_cmap6_validate,
 	tt_cmap8_validate, tt_cmap10_validate, tt_cmap12_validate): Use
@@ -756,7 +756,7 @@
 	(AF_AxisHintsRec): Add `max_segments' and `max_edges'.
 	(af_axis_hints_new_segment, af_axis_hints_new_edge): New prototypes.
 
-	* src/autofit/aflatin.c (af_latin_metricsc_scale): Don't call
+	* src/autofit/aflatin.c (af_latin_metrics_scale): Don't call
 	AF_SCALER_EQUAL_SCALES.
 	(af_latin_hints_compute_segments): Change return type to FT_Error.
 	Update all callers.
@@ -1014,7 +1014,7 @@
 	t42_parse_charstrings, t42_parse_dict): Check parser error value
 	after call to T1_Skip_PS_Token (where necessary).
 
-	* src/psaux/psobjc.c (skip_string, ps_parser_skip_PS_token,
+	* src/psaux/psobjs.c (skip_string, ps_parser_skip_PS_token,
 	ps_tobytes): Add error messages.
 
 2005-02-12  Werner Lemberg  <wl@gnu.org>
@@ -1112,7 +1112,7 @@
 	but return them as-is.
 
 	* docs/CHANGES: Mention new bitmap API.
-	* include/freetype/ftchapter.s: Updated.
+	* include/freetype/ftchapters.h: Updated.
 
 2004-12-11  Robert Clark  <freetype@ratty.org.uk>
 
@@ -1159,7 +1159,7 @@
 	(ah_test_extremum, ah_get_orientation): Removed.
 	(ah_outline_load): Use FT_Outline_Get_Orientation.
 
-	* src/base/ftsynth.c (ft_test_extrama, ft_get_orientation): Removed.
+	* src/base/ftsynth.c (ft_test_extrema, ft_get_orientation): Removed.
 	(FT_GlyphSlot_Embolden): Use FT_Outline_Get_Orientation.
 
 2004-11-23  Fernando Papa  <fpapa@netgate.com.uy>
@@ -1829,7 +1829,7 @@
 
 2004-08-05  David Turner  <david@freetype.org>
 
-	`Activate' gray-scale specifing hinting within the TrueType
+	`Activate' gray-scale specifying hinting within the TrueType
 	bytecode interpreter.  This is an experimental feature which
 	should probably be made optional.
 
@@ -1839,7 +1839,7 @@
 	(TT_Load_Glyph): Here.
 	Set `grayscale' flag except for `FT_LOAD_TARGET_MONO'.
 
-	* src/truetyep/ttinterp.c (Ins_GETINFO): Return MS rasterizer
+	* src/truetype/ttinterp.c (Ins_GETINFO): Return MS rasterizer
 	version 1.7.
 	Return rotation and stretching info only if glyph is rotated or
 	stretched, respectively.
@@ -2048,7 +2048,7 @@
 	pcf_get_metrics, pcf_get_bitmaps, pcf_get_encodings): Improve
 	debugging messages.
 
-	* src/pcf/pcfdrivr.c (FT_COMPOMENT): Move up.
+	* src/pcf/pcfdrivr.c (FT_COMPONENT): Move up.
 	(PCF_Face_Init): Simplify code.
 
 	* src/bdf/bdfdrivr.h (BDF_FaceRec): New element `default_glyph'.
@@ -2116,7 +2116,7 @@
 	* include/freetype/cache/ftcmru.h (FTC_MruNode_CompareFunc): Change
 	return type to FT_Bool.
 
-	* src/cache/ftbasic.c (ftc_basic_family_compare): Change return
+	* src/cache/ftcbasic.c (ftc_basic_family_compare): Change return
 	type to FT_Bool.
 
 	* src/cache/ftccache.c (FTC_Cache_Init, ftc_cache_init): Make
@@ -2899,7 +2899,7 @@
 	Improve MacOS fond support.  Provide a new API
 	`FT_New_Face_From_FSSpec' similar to `FT_New_Face'.
 
-	* src/base/ftmac.c [__MWERKS__]: Include FSp_fpopen.h.
+	* src/base/ftmac.c [__MWERKS__]: Include FSp_fopen.h.
 	STREAM_FILE [__MWERKS__]: New macro.
 	(ft_FSp_stream_close, ft_FSp_stream_io) [__MWERKS__]: New functions.
 	(file_spec_from_path) [__MWERKS__]: Updated #if statement.
@@ -3331,7 +3331,7 @@
 
 	* src/cff/cffdrivr.c (cff_get_cmap_info): Call sfnt module's TT CMap
 	Info service function if the cmap comes from sfnt.  Return 0 if the
-	cmap is sythesized in cff module.
+	cmap is synthesized in cff module.
 
 2004-01-20  David Turner  <david@freetype.org>
 
@@ -3460,7 +3460,7 @@
 
 2003-12-25  Werner Lemberg  <wl@gnu.org>
 
-	* src/base/fttrigon.c, src/base/ftgloadr.c: Inlude
+	* src/base/fttrigon.c, src/base/ftgloadr.c: Include
 	FT_INTERNAL_OBJECTS_H.
 
 	* src/base/ftstroke.c (FT_Outline_GetInsideBorder,
@@ -3539,7 +3539,7 @@
 	src/cache/ftcsbits.c,
 	src/cache/ftccmap.c,
 	src/cache/ftcbasic.c (added),
-	src/cache/ftclru.c (removed):
+	src/cache/ftlru.c (removed):
 
 	  *Complete* rewrite of the cache sub-system to `solve' the
 	  following points:
@@ -4119,7 +4119,7 @@
 	(fnt_cmap_class_rec, fnt_cmap_class), src/bdf/bdflib.c (empty,
 	_num_bdf_properties), src/gzip/infutil.c (inflate_mask),
 	src/gzip/inffixed.h (fixed_bl, fixed_bd, fixed_tl, fixed_td),
-	src/gzip/inftrees.h (inflate_trees_fixed), srf/gzip/inftrees.c
+	src/gzip/inftrees.h (inflate_trees_fixed), src/gzip/inftrees.c
 	(inflate_trees_fixed): Decorate with more `const' to avoid
 	writable global variables which are disallowed on ARM.
 
@@ -4659,7 +4659,7 @@
 
 	* src/type42/t42drivr.c: Include FT_SERVICE_XFREE86_NAME_H,
 	FT_SERVICE_GLYPH_DICT_H, and FT_SERVICE_POSTSCRIPT_NAME_H.
-	(t42_service_glyph_dict, t42_service_ps_name): New strucures
+	(t42_service_glyph_dict, t42_service_ps_name): New structures
 	providing Type 42 services.
 	(t42_services): New services list.
 	(T42_Get_Interface): Use `ft_service_list_lookup'.
@@ -4683,7 +4683,7 @@
 	(gindex,gindex).
 
 	* src/base/ftpfr.c (ft_pfr_check): Fix serious typo.
-	* src/pfr/prfload.c: Remove dead code.
+	* src/pfr/pfrload.c: Remove dead code.
 	(pfr_get_gindex, pfr_compare_kern_pairs, pfr_sort_kerning_pairs):
 	New functions.
 	(pfr_phy_font_done): Free `kern_pairs'.
@@ -5569,7 +5569,7 @@
 	* src/bdf/bdfdrivr.c (BDF_Face_Init), src/pcf/pcfdriver.c
 	(PCF_Face_Init): Test for charset registry case-insensitively.
 
-	* src/gzip/ftgzip.c (ft_gzip_fil_io): Revert change from yesterday;
+	* src/gzip/ftgzip.c (ft_gzip_file_io): Revert change from yesterday;
 	it has already been fixed differently.
 
 	* src/truetype/ttinterp.c (DO_SFVTL): Add missing braces around
@@ -5706,7 +5706,7 @@
 	(ah_outline_compute_edges): Scale `edge_distance_threshold' down
 	after rounding instead of scaling comparison value in loop.
 
-	* src/autohint/ahhint.c (ah_hinter_align_stong_points): Provide
+	* src/autohint/ahhint.c (ah_hinter_align_strong_points): Provide
 	alternative code which runs faster.
 	Handle `before->scale == 0'.
 
@@ -5960,7 +5960,7 @@
 
 2003-03-27  David Turner  <david@freetype.org>
 
-	* README: Udpated.
+	* README: Updated.
 
 	* README.UNX: Removed (now replaced by docs/INSTALL.UNX).
 
@@ -6275,7 +6275,7 @@
 	(bdf_driver_class): Use `bdf_driver_requester'.
 
 	* src/pcf/pcfdrivr.c: Include FT_BDF_H.
-	(pcf_get_bdf_property, pdc_driver_requester): New functions
+	(pcf_get_bdf_property, pcf_driver_requester): New functions
 	(pcf_driver_class): Use `pcf_driver_requester'.
 
 	* src/pcf/pcfread.c: Include `pcfread.h'.
@@ -6547,7 +6547,7 @@
 
 2002-11-07  David Turner  <david@freetype.org>
 
-	* src/cache/ftcsbit.c (ftc_sbit_node_load): Fixed a small bug that
+	* src/cache/ftcsbits.c (ftc_sbit_node_load): Fixed a small bug that
 	caused problems with embedded bitmaps.
 
 	* src/otlayout/otlayout.h, src/otlyaout/otlconf.h,
@@ -6608,7 +6608,7 @@
 
 2002-11-01  David Turner  <david@freetype.org>
 
-	Added PFR-specific public API.  Fixed the kerning retrievel routine
+	Added PFR-specific public API.  Fixed the kerning retrieval routine
 	(it returned invalid values when the outline and metrics resolution
 	differ).
 
@@ -6695,7 +6695,7 @@
 	* src/pfr/pfrgload.c: Include `pfrsbit.h'.
 	* src/pfr/pfrload.c (pfr_extra_item_load_kerning_pairs): Rewritten.
 	(pfr_phy_font_done, pfr_phy_font_load): Updated.
-	* src/pfr/pfrobks.c: Include `pfrsbit.h'.
+	* src/pfr/pfrobjs.c: Include `pfrsbit.h'.
 	(pfr_face_init): Handle kerning and embedded bitmaps.
 	(pfr_slot_load): Load embedded bitmaps.
 	(PFR_KERN_INDEX): Removed.
@@ -7032,7 +7032,7 @@
 	(FTC_Image_Cache_Lookup): This function.
 	(ftc_image_family_init): Updated.
 
-	* src/cache/ftcsbit.c (FTC_SBitQueryRec, FTC_SBitFamilyRec):
+	* src/cache/ftcsbits.c (FTC_SBitQueryRec, FTC_SBitFamilyRec):
 	Updated.
 	(ftc_sbit_node_load): Updated.
 	Moved code to convert type flags to load flags to...
@@ -7556,7 +7556,7 @@
 	Get glyph offset.
 
 	* src/truetype/ttobjs.c (TT_Face_Init)
-	[FT_CONFIG_OPTION_INCOREMENTAL]: Added the incremental loading
+	[FT_CONFIG_OPTION_INCREMENTAL]: Added the incremental loading
 	system for the TrueType driver.
 
 	* src/cid/cidgload.c (cid_load_glyph)
@@ -7897,7 +7897,7 @@
 
 2002-06-21  Sven Neumann  <sven@convergence.de>
 
-	* src/prf/pfrtypes.h (PFR_KernPair): New structure.
+	* src/pfr/pfrtypes.h (PFR_KernPair): New structure.
 	(PFR_PhyFont): Use it.
 	(PFR_KernFlags): New enumeration.
 	* src/pfr/pfrload.c (pfr_extra_item_load_kerning_pairs): New
@@ -8245,7 +8245,7 @@
 	`fttype1.c' in src/base.
 
 	* src/pshinter/pshglob.c (psh_blues_scale_zones): Fixed a bug that
-	prevented family blue zones substitution from hapenning correctly.
+	prevented family blue zones substitution from happening correctly.
 
 	* include/freetype/ftbdf.h FT_Get_BDF_Charset_ID): Adding
 	documentation comment.
@@ -8622,7 +8622,7 @@
 
 2002-04-19  Werner Lemberg  <wl@gnu.org>
 
-	* src/pfr/pfrload.c (pfr_extra_items_farse): Fix debug message.
+	* src/pfr/pfrload.c (pfr_extra_items_parse): Fix debug message.
 	(pfr_phy_font_load): s/size/Size/ for local variable to avoid
 	compiler warning.
 	* src/pfr/pfrobjs.c (pfr_face_init): Fix debug message.
@@ -8676,7 +8676,7 @@
 
 2002-04-16  Francesco Zappa Nardelli  <Francesco.Zappa.Nardelli@ens.fr>
 
-	* src/pcf/pcfread (pcf_get_accell): Fix parsing of accelerator
+	* src/pcf/pcfread.c (pcf_get_accel): Fix parsing of accelerator
 	tables.
 
 2002-04-15  David Turner  <david@freetype.org>
@@ -8716,7 +8716,7 @@
 
 	src/cache/ftcimage.c, src/cache/ftcsbits.c,
 
-	src/cff/cffdriver.c, src/cff/cffload.c, src/cff/cffobjs.c,
+	src/cff/cffdrivr.c, src/cff/cffload.c, src/cff/cffobjs.c,
 
 	src/cid/cidload.c, src/cid/cidparse.c, src/cid/cidriver.c,
 
@@ -9068,7 +9068,7 @@
 
 	* include/freetype/internal/psaux.h, src/cid/cidload.c,
 	src/cidtoken.h, src/psaux/psobjs.c, src/psaux/psobjs.h,
-	src/psaux/t1decode.c, stc/type1/t1load.c, src/type1/t1tokens.h:
+	src/psaux/t1decode.c, src/type1/t1load.c, src/type1/t1tokens.h:
 	Updated common PostScript type definitions.
 	Renamed all enumeration values like to uppercase variants:
 
@@ -9076,7 +9076,7 @@
 	  t1_field_cid_info => T1_FIELD_LOCATION_CID_INFO
 	  etc.
 
-	* include/freetype/internal/psglobals.h: Removed.
+	* include/freetype/internal/psglobal.h: Removed.
 	* include/freetype/internal/pshints.h, src/pshinter/pshglob.h:
 	Updated.
 
diff --git ChangeLog.22 ChangeLog.22
index 79f9478..ac19d60 100644
--- ChangeLog.22
+++ ChangeLog.22
@@ -387,10 +387,10 @@
 	(FTC_INode_Weight): Commented out.
 	* src/cache/ftcimage.h: Updated.
 
-	* src/cache/ftmanag.c (FTC_Manager_Compress,
+	* src/cache/ftcmanag.c (FTC_Manager_Compress,
 	FTC_Manager_RegisterCache, FTC_Manager_FlushN):
 	s/FT_EXPORT/FT_LOCAL/.
-	* src/cache/ftmanag.h: Updated.
+	* src/cache/ftcmanag.h: Updated.
 
 	* src/cache/ftcsbits.c (FTC_SNode_Free, FTC_SNode_New,
 	FTC_SNode_Compare): s/FT_EXPORT/FT_LOCAL/.
@@ -934,7 +934,7 @@
 	* include/freetype/freetype.h (FT_GlyphSlotRec): Improve
 	documentation of `outline' field.
 
-	* src/sfnt/sfobjc.s: Inckude FT_INTERNAL_DEBUG_H.
+	* src/sfnt/sfobjs.c: Include FT_INTERNAL_DEBUG_H.
 	* src/sfnt/sfdriver.c: Include ttmtx.h.
 
 	* src/autofit/afcjk.c: Include aftypes.h and aflatin.h.
@@ -1630,8 +1630,8 @@
 
 	* include/freetype/internal/t1types.h (T1_FaceRec): Updated.
 
-	* src/psaux/t1cmap.h (T1_CmapStdRec): Updated.
-	(T1_CmapUnicode, T1_CmapUnicodeRec): Removed.
+	* src/psaux/t1cmap.h (T1_CMapStdRec): Updated.
+	(T1_CMapUnicode, T1_CMapUnicodeRec): Removed.
 
 	* src/psaux/t1cmap.c (t1_get_glyph_name): New callback function.
 	(t1_cmap_unicode_init, t1_cmap_unicode_done,
@@ -1781,7 +1781,7 @@
 	Note that this doesn't force auto-hinting for all fonts, however.
 
 	* src/autofit/afhints.c (af_glyph_hints_reload): Don't set
-	scaler_fiags here but...
+	scaler_flags here but...
 	(af_glyph_hints_rescale): Here.
 
 	* src/autofit/aflatin.c (af_latin_hints_init): Disable horizontal
@@ -1813,7 +1813,7 @@
 	[TT_CONFIG_OPTION_BDF]: New structure.
 	(TT_FaceRec) [TT_CONFIG_OPTION_BDF]: New member `bdf'.
 
-	* include/freetype/ttags.h (TTAG_BDF): New macro.
+	* include/freetype/tttags.h (TTAG_BDF): New macro.
 
 	* src/sfnt/Jamfile (_sources): Add ttbdf.
 
@@ -1835,7 +1835,7 @@
 
 2005-12-07  Werner Lemberg  <wl@gnu.org>
 
-	* src/sfnt/sfobjc.c (sfnt_init_face): Move tag check to...
+	* src/sfnt/sfobjs.c (sfnt_init_face): Move tag check to...
 	* src/sfnt/ttload.c (sfnt_init): Here, before handling TTCs.
 
 2005-12-06  Chia-I Wu  <b90201047@ntu.edu.tw>
@@ -1962,7 +1962,7 @@
 
 	* docs/CHANGES: Mention scaling bug.
 
-2005-11-18  susuzki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
+2005-11-18  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* include/freetype/ftgxval.h, src/base/ftgxval.c
 	(FT_TrueTypeGX_Free, FT_ClassicKern_Free): New functions to free
@@ -2311,7 +2311,7 @@
 	CJK font).  A SING Glyphlet Font is an OpenType font that contains
 	the outline(s), either in a `glyf' or `CFF' table, for a glyph;
 	`cmap', `BASE', and `GSUB' tables are present with the same format
-	and functionaliy as a regular OpenType font; there are no `name',
+	and functionality as a regular OpenType font; there are no `name',
 	`head', `OS/2', and `post' tables; there are two new tables, `SING'
 	which contains details about the glyphlet, and `META' which contains
 	metadata.
@@ -2320,7 +2320,7 @@
 
 	  http://www.adobe.com/products/indesign/sing_gaiji.html
 
-	* include/freetype/ttags.h (TTAG_SING, TTAG_META): New macros for
+	* include/freetype/tttags.h (TTAG_SING, TTAG_META): New macros for
 	the OpenType tables `SING' and `META'.  These two tables are used in
 	SING Glyphlet Format fonts.
 
diff --git ChangeLog.23 ChangeLog.23
index bc8ea5b..7fb5813 100644
--- ChangeLog.23
+++ ChangeLog.23
@@ -139,7 +139,7 @@
 	Fix compilation warning.
 
 	* src/base/ftbase.h: s/LOCAL_DEF/LOCAL/.
-	* src/base/ftobjc.s: Include ftbase.h conditionally.
+	* src/base/ftobjs.c: Include ftbase.h conditionally.
 
 2010-01-11  Kwang Yul Seo  <skyul@company100.net>
 
@@ -655,7 +655,7 @@
 	[Win64] Improve the computation of random seed from stack address.
 
 	On LLP64 platform, the conversion from pointer to FT_Fixed need
-	to drop higher 32-bit.  Explict casts are required. Reported by
+	to drop higher 32-bit.  Explicit casts are required. Reported by
 	NightStrike from MinGW-w64 project.  See
 	http://lists.gnu.org/archive/html/freetype/2009-09/msg00000.html
 
@@ -891,7 +891,7 @@
 	pcf: Fix a comparison between FT_Long and FT_ULong.
 
 	* src/pcf/pcfread.c (pcf_get_bitmaps): Return an error
-	if PCF_Face->nemetrics is negative.
+	if PCF_Face->nmetrics is negative.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
@@ -1150,7 +1150,7 @@
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
-	cache: Insert explict casts for LP64 systems.
+	cache: Insert explicit casts for LP64 systems.
 
 	* src/cache/ftcbasic.c (FTC_ImageCache_Lookup,
 	FTC_SBitCache_Lookup): The type of FTC_ImageType->width
@@ -1409,7 +1409,7 @@
 
 	base: Prevent some overflows on LP64 systems.
 
-	* src/base/ftadvance.c (FT_Get_Advances): Cast the
+	* src/base/ftadvanc.c (FT_Get_Advances): Cast the
 	unsigned long constant FT_LOAD_ADVANCE_ONLY to FT_UInt32
 	for LP64 platforms.
 
@@ -1499,7 +1499,7 @@
 
 	bdf: Fix some data types mismatching with their sources.
 
-	* src/bdf/bdrdrivr.c (bdf_cmap_char_index): The type
+	* src/bdf/bdfdrivr.c (bdf_cmap_char_index): The type
 	of `code' is matched with BDF_encoding_el->enc.
 	(bdf_cmap_char_next): The type of `charcode' is
 	matched with BDF_encoding_el->enc.  When *acharcode
@@ -1545,7 +1545,7 @@
 	* src/cache/ftcbasic.c (FTC_ImageCache_Lookup): Exclude
 	the legacy behaviour from 16-bit platform, because the
 	current hack cannot detect the caller uses this function
-	via legacy convension.
+	via legacy convention.
 	(FTC_SBitCache_Lookup): Ditto.
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
@@ -1585,7 +1585,7 @@
 
 2009-07-31  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
-	fttypes.h: Cast FT_MAKE_TAG output to FT_Tag exlicitly.
+	fttypes.h: Cast FT_MAKE_TAG output to FT_Tag explicitly.
 
 	* include/freetype/fttypes.h (FT_MAKE_TAG):
 	Cast the result to FT_Tag.
@@ -1687,7 +1687,7 @@
 	sfnt: Count the size of the memory object by ptrdiff_t.
 
 	* src/sfnt/ttbdf.c (tt_face_find_bdf_prop): The type of
-	`peroperty_len' is changed from FT_UInt to FT_Offset,
+	`property_len' is changed from FT_UInt to FT_Offset,
 	to match with size_t, which is appropriate type for the
 	object in the memory buffer.
 
@@ -2122,7 +2122,7 @@
 	Use 16.16 format everywhere (except for large integers followed by a
 	`div').
 	[CAN_HANDLE_NON_INTEGRAL_T1_OPERANDS]: Remove #ifdef and activate
-	code uncoditionally.
+	code unconditionally.
 	Add support for random numbers and update remaining code
 	accordingly; this should work now.
 	(t1_operator_seac): Updated.
@@ -2479,7 +2479,7 @@
 	af_latin_script_class struct will have function to init it instead of
 	being allocated in the global scope.
 	Change af_latin_blue_chars to be PIC-compatible by being a two
-	dimentional array rather than array of pointers.
+	dimensional array rather than array of pointers.
 
 
 	* src/autofit/aflatin2.h declare af_latin2_script_class
@@ -2489,11 +2489,11 @@
 	af_latin2_script_class struct will have function to init it instead of
 	being allocated in the global scope.
 	Change af_latin2_blue_chars to be PIC-compatible by being a two
-	dimentional array rather than array of pointers.
+	dimensional array rather than array of pointers.
 
 	* src/autofit/afglobal.c when FT_CONFIG_OPTION_PIC is defined
 	af_script_classes array initialization was moved to afpic.c and
-	is later refered using macros defeined in afpic.h.
+	is later referred using macros defined in afpic.h.
 
 	New Files:
 	* src/autofit/afpic.h declare struct to hold PIC globals for autofit
@@ -2573,7 +2573,7 @@
 	Macros will be used from rastpic.h in order to access
 	ft_standard_raster from the pic_container (allocated in ftraster.c).
 	In ft_raster1_render when PIC is enabled, the last letter of
-	module_name is used to verfy the renderer class rather than the
+	module_name is used to verify the renderer class rather than the
 	class pointer.
 
 	* src/raster/ftraster.c when FT_CONFIG_OPTION_PIC is defined
@@ -2755,7 +2755,7 @@
 	And macros will be used from ttpic.h in order to access them
 	from the pic_container.
 	* src/truetype/ttobjs.c change trick_names array to be
-	PIC-compatible by being a two dimentional array rather than array
+	PIC-compatible by being a two dimensional array rather than array
 	of pointers.
 
 	New Files:
@@ -2784,14 +2784,14 @@
 	Add macros to declare, allocate and initialize drivers
 	(FT_Driver_ClassRec).
 	* include/freetype/internal/ftpic.h new file to declare the
-	FT_PIC_Container struct and the functions to allocate and detroy it.
+	FT_PIC_Container struct and the functions to allocate and destroy it.
 	* include/freetype/internal/ftserv.h add macros to allocate and
-	destory arrays of FT_ServiceDescRec.
+	destroy arrays of FT_ServiceDescRec.
 	* include/freetype/internal/internal.h define macro to include
 	ftpic.h.
 
 	New Files:
-	* src/base/ftpic.c implement functions to allocate and destory the
+	* src/base/ftpic.c implement functions to allocate and destroy the
 	global pic_container.
 	* src/base/basepic.h declare struct to hold PIC globals for base and
 	macros to access them.
@@ -2814,7 +2814,7 @@
 	* src/base/ftglyph.c when FT_CONFIG_OPTION_PIC is defined
 	ft_bitmap_glyph_class and ft_outline_glyph_class will be allocated
 	in the pic_container instead of the global scope and use macros from
- 	basepic.h to access them.
+	basepic.h to access them.
 	* src/base/ftbbox.c allocate bbox_interface stract on the stack
 	instead of the global scope when FT_CONFIG_OPTION_PIC is defined.
 	* src/base/ftstroke.c access ft_outline_glyph_class allocated in
@@ -3519,7 +3519,7 @@
 2008-12-21  Werner Lemberg  <wl@gnu.org>
 
 	* src/pfr/pfrdrivr.c, src/winfonts/winfnt.c, src/cache/ftcmanag.c,
-	src/smooth/ftgrays.c, src/base/ftobjc.s, src/sfobjs.c:
+	src/smooth/ftgrays.c, src/base/ftobjs.c, src/sfobjs.c:
 	s/_Err_Bad_Argument/_Err_Invalid_Argument/.  The former is for
 	errors in the bytecode interpreter only.
 
@@ -4098,7 +4098,7 @@
 2008-09-18  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/cff/cffobjs.c (cff_face_init): Use TTAG_OTTO defined
-	in ttags.h instead of numerical value 0x4F54544FL.
+	in tttags.h instead of numerical value 0x4F54544FL.
 
 2008-09-16  Werner Lemberg  <wl@gnu.org>
 
@@ -4248,7 +4248,7 @@
 2008-08-29  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* src/sfnt/sfobjs.c (sfnt_open_font): Use TTAG_OTTO defined in
-	ttags.h instead of FT_MAKE_TAG( 'O', 'T', 'T', 'O' ).
+	tttags.h instead of FT_MAKE_TAG( 'O', 'T', 'T', 'O' ).
 
 2008-08-28  Werner Lemberg  <wl@gnu.org>
 
@@ -4258,7 +4258,7 @@
 
 2008-08-23  Werner Lemberg  <wl@gnu.org>
 
-	* src/type/t1afm.c (compare_kern_pairs), src/pxaux/afmparse.c
+	* src/type/t1afm.c (compare_kern_pairs), src/psaux/afmparse.c
 	(afm_compare_kern_pairs): Fix comparison.  This fixes Savannah bug
 	#24119.
 
@@ -4387,7 +4387,7 @@
 
 	* src/cff/cffload.c (cff_font_load): Pass `pure_cff'.
 	Invert sids table only if `pure_cff' is set.
-	* src/cff/cffload.h: Udpated.
+	* src/cff/cffload.h: Updated.
 
 	* src/cff/cffobjs.c (cff_face_init): Updated.
 	Set FT_FACE_FLAG_CID_KEYED only if pure_cff is set.
@@ -5329,7 +5329,7 @@
 
 2007-08-18  Werner Lemberg  <wl@gnu.org>
 
-	* src/otvalid/otvcmmn.c (otv_x_y_ux_sy): Skip context glyphs.  Found
+	* src/otvalid/otvcommn.c (otv_x_y_ux_sy): Skip context glyphs.  Found
 	by Imran Yousaf.  Fixes Savannah bug #20773.
 
 	(otv_Lookup_validate): Correct handling of LookupType.  Found by
@@ -5428,7 +5428,7 @@
 	* include/freetype/config/ftheader.h (FT_CID_H): New macro.
 	* include/freetype/ftcid.h: New file.
 
-	* include/freetype/internal/ftserv.h (FT_SERVIVE_CID_H): New macro.
+	* include/freetype/internal/ftserv.h (FT_SERVICE_CID_H): New macro.
 	* include/freetype/internal/services/svcid.h: New file.
 
 	* src/base/ftcid.c: New file.
@@ -5938,7 +5938,7 @@
 
 	Savannah patch #5929.
 
-	* include/freetype/tttables.h, src/base/ftobjcs.c
+	* include/freetype/tttables.h, src/base/ftobjs.c
 	(FT_Get_CMap_Format): New function.
 
 	* include/freetype/internal/services/svttcmap.c (TT_CMapInfo): Add
@@ -6005,7 +6005,7 @@
 
 2007-05-11  David Turner  <david@freetype.org>
 
-	* src/cache/ftbasic.c, include/freetype/ftcache.h
+	* src/cache/ftcbasic.c, include/freetype/ftcache.h
 	(FTC_ImageCache_LookupScaler, FTC_SBit_Cache_LookupScaler): Two new
 	functions that allow us to look up glyphs using an FTC_Scaler object
 	to specify the size, making it possible to use fractional pixel
@@ -6097,8 +6097,8 @@
 
 2007-04-06  David Turner  <david@freetype.org>
 
-	* src/base/ftbimap.c (ft_bitmap_assure_buffer): Fix buffer-overwrite bug
-	(Savannah bug #19536).
+	* src/base/ftbitmap.c (ft_bitmap_assure_buffer): Fix buffer-overwrite
+	bug (Savannah bug #19536).
 
 2007-04-04  Werner Lemberg  <wl@gnu.org>
 
@@ -6256,7 +6256,7 @@
 	case FT_Init_FreeType fails for some reason.  Problem reported by
 	Maximilian Schwerin <maximilian.schwerin@buelowssiege.de>.
 
-	* src/truetype/ttobs.c (tt_size_init_bytecode): Clear the `x_ppem'
+	* src/truetype/ttobjs.c (tt_size_init_bytecode): Clear the `x_ppem'
 	and `y_ppem' fields of the `TT_Size.metrics' structure, not those of
 	`TT_Size.root.metrics'.  Problem reported by Daniel Glöckner
 	<daniel-gl@gmx.net>.
@@ -6335,7 +6335,7 @@
 	* src/base/ftutil.c (ft_mem_dup, ft_mem_strdup, ft_mem_strcpyn): New
 	functions.
 
-	* src/bfd/bfddrivr.c (bdf_interpret_style, BDF_Face_Init),
+	* src/bdf/bdfdrivr.c (bdf_interpret_style, BDF_Face_Init),
 	src/bdf/bdflib.c (_bdf_add_property), src/pcf/pcfread.c
 	(pcf_get_properties, pcf_interpret_style, pcf_load_font),
 	src/cff/cffdrivr.c (cff_get_glyph_name), src/cff/cffload.c
@@ -6546,7 +6546,7 @@
 2007-01-16  David Turner  <david@freetype.org>
 
 	* src/autofit/aflatin.c (af_latin_hints_compute_segments),
-	src/cff/cffdriver.c (cff_ps_get_font_info), src/truetype/ttobjs.c
+	src/cff/cffdrivr.c (cff_ps_get_font_info), src/truetype/ttobjs.c
 	(tt_face_init), src/truetype/ttinterp.c (Ins_SHC): Fix compiler
 	warnings.
 
@@ -6592,7 +6592,7 @@
 	* src/cff/cffload.c: Include FT_TYPE1_TABLES_H.
 	(cff_font_done): Free font->font_info if necessary.
 
-	* src/cff/cffdrvr.c (cff_ps_get_font_info): New function.
+	* src/cff/cffdrivr.c (cff_ps_get_font_info): New function.
 	(cff_service_ps_info): Register cff_ps_get_font_info.
 
 2007-01-13  Werner Lemberg  <wl@gnu.org>
@@ -6734,7 +6734,7 @@
 	files are not used.
 
 	* include/freetype/internal/tttypes.h (TT_FaceRec): Add members
-	`horz_metrics_offset' and `vert_metrics_ofset'.
+	`horz_metrics_offset' and `vert_metrics_offset'.
 	* src/sfnt/ttmtx.c (tt_face_load_hmtx, tt_face_get_metrics):
 	Updated.
 
@@ -7517,7 +7517,7 @@
 2006-08-15  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
 	* modules.cfg (BASE_EXTENSIONS): Compile in ftgxval.c by default to
-	build ftvalid in ft2demos.  This has been inadvertedly changed
+	build ftvalid in ft2demos.  This has been inadvertently changed
 	2006-08-13.
 
 2006-08-15  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
@@ -7647,7 +7647,7 @@
 	`len_buildchar'.
 	Remove `keywords_flags'.
 
-	* src/type1/t1load.h (T1_LoaderRect): New field
+	* src/type1/t1load.h (T1_LoaderRec): New field
 	`keywords_encountered'.
 	(T1_PRIVATE, T1_FONTDIR_AFTER_PRIVATE): New macros.
 
@@ -7840,7 +7840,7 @@
 	* src/base/ftobjs.c (load_face_in_embedded_rfork): Replace
 	`FT_Stream_Close' by `FT_Stream_Free' to fix memory leak.
 
-	* src/base/ftrfrk.c (raccess_guess_linux_double_from_file_name):
+	* src/base/ftrfork.c (raccess_guess_linux_double_from_file_name):
 	Replace `FT_Stream_Close' by `FT_Stream_Free' to fix memory leak.
 
 2006-05-19  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
@@ -7902,7 +7902,7 @@
 	(FT_Stream_OpenGzip): Use it to handle small files directly in
 	memory.
 
-	* src/psaux/psconv.c (PS_Conv_ASCIIHexDecode, PS_ConvEexecDecode):
+	* src/psaux/psconv.c (PS_Conv_ASCIIHexDecode, PS_Conv_EexecDecode):
 	Improve performance.
 
 	* src/truetype/ttgload.c (TT_Access_Glyph_Frame): Set `cursor' and
diff --git ChangeLog.24 ChangeLog.24
index 3a4abe2..a1f1576 100644
--- ChangeLog.24
+++ ChangeLog.24
@@ -780,7 +780,7 @@
 
 	Move font tweaking tables to...
 
-	* src/truetype/ttsubpic.c: This file and decorate them with `static'
+	* src/truetype/ttsubpix.c: This file and decorate them with `static'
 	and `const' where appropriate.
 
 	(X_SCALING_Rules, X_SCALING_RULES_SIZE): Renamed to...
@@ -978,7 +978,7 @@
 
 	[base] Clean up trigonometric core.
 
-	* src/base/fttrrigon.c (ft_trig_pseudo_polarize): Align algorithm
+	* src/base/fttrigon.c (ft_trig_pseudo_polarize): Align algorithm
 	with `ft_trig_pseudo_rotate'.
 
 2012-12-18  Infinality  <infinality@infinality.net>
@@ -990,7 +990,7 @@
 
 2012-12-17  Infinality  <infinality@infinality.net>
 
-	[truetype] Remove unusued code and variables.
+	[truetype] Remove unused code and variables.
 
 	* src/truetype/ttinterp.c: Updated.
 	(Ins_FDEF): Remove opcode patterns that are not being used.
@@ -1012,7 +1012,7 @@
 
 2012-12-16  Infinality  <infinality@infinality.net>
 
-	[truetype] Remove unusued code and variables.  Add minor fixes.
+	[truetype] Remove unused code and variables.  Add minor fixes.
 
 	* src/truetype/ttsubpix.h: Updated.
 	(SKIP_NONPIXEL_Y_MOVES_Rules_Exceptions): Add Trebuchet MS.
@@ -1037,7 +1037,7 @@
 	(Ins_FDEF): Rework code to fix bugs and add more detection.
 	(Ins_CALL): Remove unused code.
 	(Ins_LOOPCALL): Remove unused code.
-	(TT_RunIns): Remove unusued code.
+	(TT_RunIns): Remove unused code.
 	(Ins_SHPIX): Add logic to handle ttfautohinted fonts.
 	(Ins_MIRP): Don't round x in cut-in calculation.  Add logic to handle
 	ttfautohinted fonts.
@@ -1395,7 +1395,7 @@
 
 	[autofit] Minor optimization.
 
-	* src/autofit/afglobals.c (af_face_globals_compute_script_coverage):
+	* src/autofit/afglobal.c (af_face_globals_compute_script_coverage):
 	Add loop condition.
 
 2012-09-29  Werner Lemberg  <wl@gnu.org>
@@ -2556,7 +2556,7 @@
 	s/t1_init_loader/cid_init_loader/.
 	s/t1_done_loader/cid_done_loader/.
 
-	* src/pxaux/t1cmap.c: s/t1_get_glyph_name/psaux_get_glyph_name/.
+	* src/psaux/t1cmap.c: s/t1_get_glyph_name/psaux_get_glyph_name/.
 
 	* src/truetype/ttdriver.c: s/Load_Glyph/tt_glyph_load/.
 
@@ -2796,9 +2796,9 @@
 	[base] Fix a dereference of uninitialized variable in PIC mode.
 
 	* src/base/ftglyph.c (FT_Glyph_To_Bitmap): `glyph' must be
-	set before derefering to obtain `library'.  The initialization
+	set before dereferring to obtain `library'.  The initialization
 	of `clazz', `glyph', `library' and NULL pointer check are
-	reordered to minimize PIC conditonals.
+	reordered to minimize PIC conditionals.
 
 2012-01-14  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
@@ -3261,7 +3261,7 @@
 
 2011-09-17  Alexei Podtelezhnikov  <apodtele@gmail.com>
 
-	[smooth] Slightly optimize conic and cubic flatterners.
+	[smooth] Slightly optimize conic and cubic flatteners.
 
 	* src/smooth/ftgrays.c (gray_render_conic, gray_render_cubic): Move
 	out some code from the main loop to speed it up.
@@ -4120,7 +4120,7 @@
 	[autofit] Add more Indic scripts with hanging baseline.
 
 	* src/autofit/afindic.c (af_indic_uniranges): Tibetan, Limbu,
-	Sundanese, Meetei Mayak, Syloti Nagri and Sharada scripts are
+	Sundanese, Meetei Mayek, Syloti Nagri and Sharada scripts are
 	added.
 
 2011-04-21  Behdad Esfahbod  <behdad@behdad.org>
@@ -4756,7 +4756,7 @@
 	* src/bzip2/*: New files.
 
 	* src/pcf/pcf.h: s/gzip_/comp_/.
-	* src/pcf/pcfdrvr.c: Include FT_BZIP2_H.
+	* src/pcf/pcfdrivr.c: Include FT_BZIP2_H.
 	s/gzip_/comp_/.
 	(PCF_Face_Init): Handle bzip2 compressed files.
 
@@ -4768,7 +4768,7 @@
 
 	If we encounter a space in a string then the sbit buffer is NULL,
 	height and width are 0s.  So the check in ftc_snode_compare will
-	always pass for spaces (comparision with 255).  Here the comments
+	always pass for spaces (comparison with 255).  Here the comments
 	above the condition are proper but the implementation is not.  When
 	we create an snode I think it is the proper way to initialize the
 	width to 255 and then put a check for being equal to 255 in snode
@@ -5548,7 +5548,7 @@
 	Add reference counters and to FT_Library and FT_Face objects.
 
 	* include/freetype/freetype.h (FT_Reference_Face): New function.
-	* include/freetype/ftmodapi.h (FT_Rererence_Library): New function.
+	* include/freetype/ftmodapi.h (FT_Reference_Library): New function.
 
 	* include/freetype/internal/ftobjs.h (FT_Face_InternalRec,
 	FT_LibraryRec): New field `refcount'.
@@ -6278,8 +6278,8 @@
 	Use real types instead of `void' for `pshinter' and `psnames' fields.
 
 	* src/cff/cffload.c: Don't include PS cmaps service.
-	(cff_index_get_pointers): Add `pool' parameter which allows to
-	insert an extra NUL character for each String INDEX entry.
+	(cff_index_get_pointers): Add `pool' parameter which allows inserting
+	an extra NUL character for each String INDEX entry.
 	(cff_index_get_name): Make it a local function.
 	(cff_index_get_string): New function.
 	(cff_subfont_load): Updated.
diff --git ChangeLog.25 ChangeLog.25
index 0766f57..1f5eb3a 100644
--- ChangeLog.25
+++ ChangeLog.25
@@ -245,7 +245,7 @@
 	All public FreeType enumeration and flag values are uppercase...
 
 	* include/tttables.h (FT_Sfnt_Tag): Implement it.  For backwards
-	compatilibity, retain the old values as macros.
+	compatibility, retain the old values as macros.
 
 	* src/base/ftfstype.c (FT_Get_FSType_Flags), src/sfnt/sfdriver.c
 	(get_sfnt_table): Updated.
@@ -380,7 +380,7 @@
 	elements, use CSS descendants (of class `section') to format the
 	data.
 
-	Also remove reduntant <p> and <br> elements, replacing them with
+	Also remove redundant <p> and <br> elements, replacing them with
 	proper CSS.
 
 	Globally reduce page width to 75%.
@@ -549,7 +549,7 @@
 
 	* src/base/ftobjs.c (FT_Get_Glyph_Name): Fix compiler warning.
 
-	Introdruced in previous change.  Reported by Alexei.
+	Introduced in previous change.  Reported by Alexei.
 
 2014-11-26  Werner Lemberg  <wl@gnu.org>
 
@@ -579,7 +579,7 @@
 
 2014-11-26  suzuki toshiya  <mpsuzuki@hiroshima-u.ac.jp>
 
-	* src/base/ftobj.c (Mac_Read_POST_Resource): Additional
+	* src/base/ftobjs.c (Mac_Read_POST_Resource): Additional
 	overflow check in the summation of POST fragment lengths,
 	suggested by Mateusz Jurczyk <mjurczyk@google.com>.
 
@@ -945,7 +945,7 @@
 
 	The scaling between the hypotenuse and its CORDIC approximation is
 	based on regression analysis. The smaller padding for `theta' is
-	justifed by its maximum error of less than 6.
+	justified by its maximum error of less than 6.
 
 	* src/base/fttrigon.c (ft_trig_downscale): Borrow code from
 	./ftcalc.c (ft_multo64), change linear intercept.
@@ -1430,7 +1430,7 @@
 	[base] Avoid undefined FT_MSB in `BBox_Cubic_Check'.
 
 	* src/base/ftbbox.c (BBox_Cubic_Check): Update.
-	(update_cubic_max): Repalce with...
+	(update_cubic_max): Replace with...
 	(cubic_peak): ... this, which now handles upscaling.
 
 2014-08-11  Alexei Podtelezhnikov  <apodtele@gmail.com>
@@ -2444,7 +2444,7 @@
 	that the covered ranges are the same: Bengali, Devanagari, Gujarati,
 	Gurmukhi, Kannada, Limbu, Malayalam, Oriya, Sinhala, Sundanese,
 	Syloti Nagri, Tamil, Telugu, and Tibetan.  At the same time, remove
-	entries for Meetai Mayak and Sharada – the Unicode ranges were
+	entries for Meetei Mayek and Sharada – the Unicode ranges were
 	incorrect (and nobody has complained about that), fonts are scarce
 	for those scripts, and the Indic auto-hinter support is rudimentary
 	anyways.
@@ -2697,7 +2697,7 @@
 
 	[autofit] Introduce `coverages'.
 
-	Coverages are the interface to the HarfBuzz library to acces
+	Coverages are the interface to the HarfBuzz library to access
 	OpenType features for handling glyphs not addressable by the cmap.
 
 	Right now, compilation of HarfBuzz is only added to the development
@@ -2896,11 +2896,11 @@
 	* src/autofit/afdummy.c, src/autofit/afdummy.h: Updated.
 	* src/autofit/afindic.c, src/autofit/afindic.h: Updated.
 	* src/autofit/aflatin.c, src/autofit/aflatin.h: Updated.
-	* src/autofit/aflatn2.c, src/autofit/aflatn2.h: Updated.
+	* src/autofit/aflatin2.c, src/autofit/aflatin2.h: Updated.
 
 	* src/autofit/afpic.c: Updated.
 
-	* src/autofir/autofit.c: Include `afranges.c'.
+	* src/autofit/autofit.c: Include `afranges.c'.
 	* src/autofit/rules.mk (AUTOF_DRV_SRC): Add `afranges.c'.
 
 2013-12-18  Werner Lemberg  <wl@gnu.org>
@@ -3418,7 +3418,7 @@
 	* src/autofit/afblue.c, src/autofit/afblue.h: Regenerated.
 
 	* src/autofit/aflatin.c, src/autofit/aflatin.h,
-	src/autofit/atlatin2.c: Updated.
+	src/autofit/aflatin2.c: Updated.
 
 2013-10-19  Werner Lemberg  <wl@gnu.org>
 
@@ -3999,7 +3999,7 @@
 
 	* builds/vms/ftconfig.h: Ditto.
 	Make the differences to the master `ftconfig.h' file as small as
-	possible for easier maintainance.
+	possible for easier maintenance.
 
 2013-08-05  Werner Lemberg  <wl@gnu.org>
 
@@ -4319,7 +4319,7 @@
 
 	* include/freetype/internal/tttypes.h (TT_SBit_MetricsRec): Widen
 	fields to FT_Short and FT_UShort, respectively.
-	(TT_SBitTableType): New enumeration.
+	(TT_SbitTableType): New enumeration.
 	(TT_FaceRec): Add `sbit_table_type' field.
 
 	* include/freetype/tttags.h (TTAG_sbix): New macro.
@@ -4332,7 +4332,7 @@
 	* src/sfnt/ttsbit.c: Include `ttmtx.h'.
 	(tt_face_load_eblc): Renamed to...
 	(tt_face_load_sbit): This.
-	Handlic `sbix' bitmaps.
+	Handle `sbix' bitmaps.
 	(tt_face_free_eblc): Renamed to...
 	(tt_face_load_sbit): This.
 	Updated.
@@ -4615,7 +4615,7 @@
 	Fix Savannah bug #39269.
 
 	* src/base/ftgloadr.c (FT_GlyphLoader_CheckPoints): Free memory in
-	case of reacollocation failures.
+	case of reallocation failures.
 
 2013-06-18  Andrew Church  <achurch+savannah@achurch.org>
 
@@ -5098,7 +5098,7 @@
 
 	[truetype] Add framework for TrueType properties.
 
-	* src/truetype/ttdrivr.c: Include FT_SERVICE_PROPERTIES_H.
+	* src/truetype/ttdriver.c: Include FT_SERVICE_PROPERTIES_H.
 	(tt_property_set, tt_property_get): New functions, still empty.
 	Define `tt_service_properties' service.
 	Update `tt_services'.
diff --git builds/cmake/iOS.cmake builds/cmake/iOS.cmake
index 9fb20c0..378dbd8 100644
--- builds/cmake/iOS.cmake
+++ builds/cmake/iOS.cmake
@@ -85,11 +85,6 @@ if (CMAKE_UNAME)
     DARWIN_MAJOR_VERSION "${CMAKE_HOST_SYSTEM_VERSION}")
 endif (CMAKE_UNAME)
 
-# force the compilers to gcc for iOS
-include(CMakeForceCompiler)
-CMAKE_FORCE_C_COMPILER(gcc gcc)
-CMAKE_FORCE_CXX_COMPILER(g++ g++)
-
 # skip the platform compiler checks for cross compiling
 set(CMAKE_CXX_COMPILER_WORKS TRUE)
 set(CMAKE_C_COMPILER_WORKS TRUE)
diff --git builds/unix/configure.raw builds/unix/configure.raw
index 1be10a3..e6fd748 100644
--- builds/unix/configure.raw
+++ builds/unix/configure.raw
@@ -15,7 +15,7 @@ AC_INIT([FreeType], [@VERSION@], [freetype@nongnu.org], [freetype])
 AC_CONFIG_SRCDIR([ftconfig.in])
 
 
-# Don't forget to update docs/VERSION.DLL!
+# Don't forget to update `docs/VERSIONS.TXT'!
 
 version_info='18:3:12'
 AC_SUBST([version_info])
@@ -235,6 +235,9 @@ if test "x$GCC" = xyes; then
   *-*-mingw*)
     XX_ANSIFLAGS="-pedantic"
     ;;
+  *-*-aix*)
+    XX_ANSIFLAGS="-pedantic"
+    ;;
   *)
     GCC_VERSION=`$CC -dumpversion`
     GCC_MAJOR=`echo "$GCC_VERSION" | sed 's/\([[^.]][[^.]]*\).*/\1/'`
diff --git docs/CHANGES docs/CHANGES
index 0803072..14b57cb 100644
--- docs/CHANGES
+++ docs/CHANGES
@@ -3754,7 +3754,7 @@ BETA-8 (RELEASE CANDIDATE) CHANGES
         automatically when needed.
 
   - Reformatted all  modules source  code in order  to get rid  of the
-    basic data types redifinitions (i.e. `TT_Int' instead of `FT_Int',
+    basic data types redefinitions (i.e. `TT_Int' instead of `FT_Int',
     `T1_Fixed'  instead  of  `FT_Fixed').  Hence  the  format-specific
     prefixes like  `TT_', `T1_',  `T2_' and `CID_'  are only  used for
     relevant structures.
diff --git docs/VERSION.DLL docs/VERSION.DLL
deleted file mode 100644
index 804c2f2..0000000
--- docs/VERSION.DLL
+++ /dev/null
@@ -1,119 +0,0 @@
-Due  to our  use of  `libtool' to  generate and  install the  FreeType 2
-libraries on  Unix systems, as  well as  other historical events,  it is
-generally very  difficult to  know precisely which  release of  the font
-engine is installed on a given system.
-
-This file tries  to explain why and to document  ways to properly detect
-FreeType on Unix.
-
-
-1. Version and Release numbers
-------------------------------
-
-For each new  public release of FreeType 2, there  are generally *three*
-distinct `version' numbers to consider:
-
-  * The official FreeType 2 release number, like 2.3.1 or 2.4.10.
-
-  * The libtool (and  Unix) specific version number,  like 13.0.7.  This
-    is what `freetype-config --version' returns.
-
-  * The platform-specific  shared object  number, used for  example when
-    the library is installed as `/usr/lib/libfreetype.so.6.7.1'.
-
-The platform-specific  number is, unsurprisingly,  platform-specific and
-varies  with the  operating system  you are  using (several  variants of
-Linux, FreeBSD,  Solaris, etc.).  You  should thus _never_ use  it, even
-for simple tests.
-
-The libtool-specific  number does  not equal the  release number  but is
-tied to it.
-
-The release number is available  at *compile* time through the following
-macros defined in FT_FREETYPE_H:
-
-  - FREETYPE_MAJOR: major release number
-  - FREETYPE_MINOR: minor release number
-  - FREETYPE_PATCH: patch release number
-
-See below for a small autoconf fragment.
-
-The  release  number   is  also  available  at   *runtime*  through  the
-`FT_Library_Version' API.
-
-
-2. History
-----------
-
-The  following   table  gives,  for   all  releases  since   2.4.0,  the
-corresponding libtool number, as well  as the shared object number found
-on _most_ systems, but not all of them:
-
-
-    release     libtool     so
-  -------------------------------
-     2.6.3      18.3.12   6.12.3
-     2.6.2      18.2.12   6.12.2
-     2.6.1      18.1.12   6.12.1
-     2.6.0      18.0.12   6.12.0
-     2.5.5      17.4.11   6.11.4
-     2.5.4      17.3.11   6.11.3
-     2.5.3      17.2.11   6.11.2
-     2.5.2      17.1.11   6.11.1
-     2.5.1      17.0.11   6.11.0
-     2.5.0      16.2.10   6.10.2
-     2.4.12     16.1.10   6.10.1
-     2.4.11     16.0.10   6.10.0
-     2.4.10     15.0.9    6.9.0
-     2.4.9      14.1.8    6.8.1
-     2.4.8      14.0.8    6.8.0
-     2.4.7      13.2.7    6.7.2
-     2.4.6      13.1.7    6.7.1
-     2.4.5      13.0.7    6.7.0
-     2.4.4      12.2.6    6.6.2
-     2.4.3      12.1.6    6.6.1
-     2.4.2      12.0.6    6.6.0
-     2.4.1      11.1.5    6.5.1
-     2.4.0      11.0.5    6.5.0
-
-
-3. Autoconf Code Fragment
--------------------------
-
-Lars Clausen contributed the following autoconf fragment to detect which
-version of  FreeType is  installed on  a system.  This  one tests  for a
-version that  is at least 2.0.9;  you should change it  to check against
-other release numbers.
-
-
-  AC_MSG_CHECKING([whether FreeType version is 2.0.9 or higher])
-  old_CPPFLAGS="$CPPFLAGS"
-  CPPFLAGS=`freetype-config --cflags`
-  AC_TRY_CPP([
-
-#include <ft2build.h>
-#include FT_FREETYPE_H
-#if (FREETYPE_MAJOR*1000 + FREETYPE_MINOR)*1000 + FREETYPE_PATCH < 2000009
-#error Freetype version too low.
-#endif
-  ],
-  [AC_MSG_RESULT(yes)
-   FREETYPE_LIBS=`freetype-config --libs`
-   AC_SUBST(FREETYPE_LIBS)
-   AC_DEFINE(HAVE_FREETYPE,1,[Define if you have the FreeType2 library])
-   CPPFLAGS="$old_CPPFLAGS"],
-  [AC_MSG_ERROR([Need FreeType library version 2.0.9 or higher])])
-
-------------------------------------------------------------------------
-
-Copyright 2002-2016 by
-David Turner, Robert Wilhelm, and Werner Lemberg.
-
-This  file is  part  of the  FreeType  project, and  may  only be  used,
-modified,  and  distributed under  the  terms  of  the FreeType  project
-license, LICENSE.TXT.  By continuing  to use, modify, or distribute this
-file  you indicate that  you have  read the  license and  understand and
-accept it fully.
-
-
---- end of VERSION.DLL ---
diff --git docs/VERSIONS.TXT docs/VERSIONS.TXT
new file mode 100644
index 0000000..e2c72bc
--- /dev/null
+++ docs/VERSIONS.TXT
@@ -0,0 +1,119 @@
+Due  to our  use of  `libtool' to  generate and  install the  FreeType 2
+libraries on  Unix systems, as  well as  other historical events,  it is
+generally very  difficult to  know precisely which  release of  the font
+engine is installed on a given system.
+
+This file tries  to explain why and to document  ways to properly detect
+FreeType on Unix.
+
+
+1. Version and Release numbers
+------------------------------
+
+For each new  public release of FreeType 2, there  are generally *three*
+distinct `version' numbers to consider:
+
+  * The official FreeType 2 release number, like 2.3.1 or 2.4.10.
+
+  * The libtool (and  Unix) specific version number,  like 13.0.7.  This
+    is what `freetype-config --version' returns.
+
+  * The platform-specific  shared object  number, used for  example when
+    the library is installed as `/usr/lib/libfreetype.so.6.7.1'.
+
+The platform-specific  number is, unsurprisingly,  platform-specific and
+varies  with the  operating system  you are  using (several  variants of
+Linux, FreeBSD,  Solaris, etc.).  You  should thus _never_ use  it, even
+for simple tests.
+
+The libtool-specific  number does  not equal the  release number  but is
+tied to it.
+
+The release number is available  at *compile* time through the following
+macros defined in FT_FREETYPE_H:
+
+  - FREETYPE_MAJOR: major release number
+  - FREETYPE_MINOR: minor release number
+  - FREETYPE_PATCH: patch release number
+
+See below for a small autoconf fragment.
+
+The  release  number   is  also  available  at   *runtime*  through  the
+`FT_Library_Version' API.
+
+
+2. History
+----------
+
+The  following   table  gives,  for   all  releases  since   2.4.0,  the
+corresponding libtool number, as well  as the shared object number found
+on _most_ systems, but not all of them:
+
+
+    release     libtool     so
+  -------------------------------
+     2.6.3      18.3.12   6.12.3
+     2.6.2      18.2.12   6.12.2
+     2.6.1      18.1.12   6.12.1
+     2.6.0      18.0.12   6.12.0
+     2.5.5      17.4.11   6.11.4
+     2.5.4      17.3.11   6.11.3
+     2.5.3      17.2.11   6.11.2
+     2.5.2      17.1.11   6.11.1
+     2.5.1      17.0.11   6.11.0
+     2.5.0      16.2.10   6.10.2
+     2.4.12     16.1.10   6.10.1
+     2.4.11     16.0.10   6.10.0
+     2.4.10     15.0.9    6.9.0
+     2.4.9      14.1.8    6.8.1
+     2.4.8      14.0.8    6.8.0
+     2.4.7      13.2.7    6.7.2
+     2.4.6      13.1.7    6.7.1
+     2.4.5      13.0.7    6.7.0
+     2.4.4      12.2.6    6.6.2
+     2.4.3      12.1.6    6.6.1
+     2.4.2      12.0.6    6.6.0
+     2.4.1      11.1.5    6.5.1
+     2.4.0      11.0.5    6.5.0
+
+
+3. Autoconf Code Fragment
+-------------------------
+
+Lars Clausen contributed the following autoconf fragment to detect which
+version of  FreeType is  installed on  a system.  This  one tests  for a
+version that  is at least 2.0.9;  you should change it  to check against
+other release numbers.
+
+
+  AC_MSG_CHECKING([whether FreeType version is 2.0.9 or higher])
+  old_CPPFLAGS="$CPPFLAGS"
+  CPPFLAGS=`freetype-config --cflags`
+  AC_TRY_CPP([
+
+#include <ft2build.h>
+#include FT_FREETYPE_H
+#if (FREETYPE_MAJOR*1000 + FREETYPE_MINOR)*1000 + FREETYPE_PATCH < 2000009
+#error Freetype version too low.
+#endif
+  ],
+  [AC_MSG_RESULT(yes)
+   FREETYPE_LIBS=`freetype-config --libs`
+   AC_SUBST(FREETYPE_LIBS)
+   AC_DEFINE(HAVE_FREETYPE,1,[Define if you have the FreeType2 library])
+   CPPFLAGS="$old_CPPFLAGS"],
+  [AC_MSG_ERROR([Need FreeType library version 2.0.9 or higher])])
+
+------------------------------------------------------------------------
+
+Copyright 2002-2016 by
+David Turner, Robert Wilhelm, and Werner Lemberg.
+
+This  file is  part  of the  FreeType  project, and  may  only be  used,
+modified,  and  distributed under  the  terms  of  the FreeType  project
+license, LICENSE.TXT.  By continuing  to use, modify, or distribute this
+file  you indicate that  you have  read the  license and  understand and
+accept it fully.
+
+
+--- end of VERSIONS.TXT ---
diff --git docs/release docs/release
index 3d66762..fc03a50 100644
--- docs/release
+++ docs/release
@@ -13,7 +13,7 @@ How to prepare a new release
 
 . README: Update.
 
-. docs/VERSION.DLL: Document changed `version_info'.
+. docs/VERSIONS.TXT: Document changed `version_info'.
 
 . ChangeLog:   Announce  new  release   (both  in  the  freetype2  and
   freetype2-demos modules).
diff --git include/freetype/freetype.h include/freetype/freetype.h
index 4666d48..250f405 100644
--- include/freetype/freetype.h
+++ include/freetype/freetype.h
@@ -2339,9 +2339,9 @@ FT_BEGIN_HEADER
   /*      used to determine both scaling values.                           */
   /*                                                                       */
   /*    FT_SIZE_REQUEST_TYPE_REAL_DIM ::                                   */
-  /*      The real dimension.  The sum of the the `ascender' and (minus    */
-  /*      of) the `descender' fields of @FT_FaceRec are used to determine  */
-  /*      both scaling values.                                             */
+  /*      The real dimension.  The sum of the `ascender' and (minus of)    */
+  /*      the `descender' fields of @FT_FaceRec are used to determine both */
+  /*      scaling values.                                                  */
   /*                                                                       */
   /*    FT_SIZE_REQUEST_TYPE_BBOX ::                                       */
   /*      The font bounding box.  The width and height of the `bbox' field */
@@ -2855,7 +2855,7 @@ FT_BEGIN_HEADER
    *
    *   If @FT_LOAD_RENDER is also set, the glyph is rendered in the
    *   corresponding mode (i.e., the mode that matches the used algorithm
-   *   best).  An exeption is FT_LOAD_TARGET_MONO since it implies
+   *   best).  An exception is FT_LOAD_TARGET_MONO since it implies
    *   @FT_LOAD_MONOCHROME.
    *
    *   You can use a hinting algorithm that doesn't correspond to the same
@@ -3273,7 +3273,7 @@ FT_BEGIN_HEADER
   /*    `.notdef').                                                        */
   /*                                                                       */
   /*    This function always returns an error if the config macro          */
-  /*    `FT_CONFIG_OPTION_NO_GLYPH_NAMES' is not defined in `ftoptions.h'. */
+  /*    `FT_CONFIG_OPTION_NO_GLYPH_NAMES' is not defined in `ftoption.h'.  */
   /*                                                                       */
   FT_EXPORT( FT_Error )
   FT_Get_Glyph_Name( FT_Face     face,
diff --git include/freetype/ftautoh.h include/freetype/ftautoh.h
index 8052dd2..40c8003 100644
--- include/freetype/ftautoh.h
+++ include/freetype/ftautoh.h
@@ -219,8 +219,8 @@ FT_BEGIN_HEADER
    *       U+0F00 - U+0FFF  // Tibetan
    *       U+1900 - U+194F  // Limbu
    *       U+1B80 - U+1BBF  // Sundanese
-   *       U+1C80 - U+1CDF  // Meetei Mayak
    *       U+A800 - U+A82F  // Syloti Nagri
+   *       U+ABC0 - U+ABFF  // Meetei Mayek
    *      U+11800 - U+118DF // Sharada
    *     }
    *
diff --git include/freetype/ftcffdrv.h include/freetype/ftcffdrv.h
index 9dea980..b0b4299 100644
--- include/freetype/ftcffdrv.h
+++ include/freetype/ftcffdrv.h
@@ -89,7 +89,7 @@ FT_BEGIN_HEADER
    *   features preserve the design's weight and spacing much better than
    *   aliased type would.
    *
-   *   2) Aligment in the vertical direction: Weights and spacing along the
+   *   2) Alignment in the vertical direction: Weights and spacing along the
    *   y~axis are less critical; what is much more important is the visual
    *   alignment of related features (like cap-height and x-height).  The
    *   sense of alignment for these is enhanced by the sharpness of grid-fit
diff --git include/freetype/ftcid.h include/freetype/ftcid.h
index 140f2f8..e1bc9fe 100644
--- include/freetype/ftcid.h
+++ include/freetype/ftcid.h
@@ -97,8 +97,8 @@ FT_BEGIN_HEADER
    *
    * @description:
    *    Retrieve the type of the input face, CID keyed or not.  In
-   *    constrast to the @FT_IS_CID_KEYED macro this function returns
-   *    successfully also for CID-keyed fonts in an SNFT wrapper.
+   *    contrast to the @FT_IS_CID_KEYED macro this function returns
+   *    successfully also for CID-keyed fonts in an SFNT wrapper.
    *
    * @input:
    *    face ::
diff --git include/freetype/ftgzip.h include/freetype/ftgzip.h
index 9e658b0..3932ce6 100644
--- include/freetype/ftgzip.h
+++ include/freetype/ftgzip.h
@@ -117,11 +117,11 @@ FT_BEGIN_HEADER
   *
   * @inout:
   *   output_len ::
-  *     Before calling the function, this is the the total size of the
-  *     output buffer, which must be large enough to hold the entire
-  *     uncompressed data (so the size of the uncompressed data must be
-  *     known in advance).  After calling the function, `output_len' is the
-  *     size of the used data in `output'.
+  *     Before calling the function, this is the total size of the output
+  *     buffer, which must be large enough to hold the entire uncompressed
+  *     data (so the size of the uncompressed data must be known in
+  *     advance).  After calling the function, `output_len' is the size of
+  *     the used data in `output'.
   *
   * @return:
   *   FreeType error code.  0~means success.
diff --git include/freetype/internal/ftdriver.h include/freetype/internal/ftdriver.h
index 4b28e6a..3e1e66e 100644
--- include/freetype/internal/ftdriver.h
+++ include/freetype/internal/ftdriver.h
@@ -213,7 +213,7 @@ FT_BEGIN_HEADER
   /*    And when it is no longer needed a `destroy' function needs to be   */
   /*    called to release that allocation.                                 */
   /*                                                                       */
-  /*    `fcinit.c' (ft_create_default_module_classes) already contains a   */
+  /*    `ftinit.c' (ft_create_default_module_classes) already contains a   */
   /*    mechanism to call these functions for the default modules          */
   /*    described in `ftmodule.h'.                                         */
   /*                                                                       */
diff --git include/freetype/internal/ftobjs.h include/freetype/internal/ftobjs.h
index c37c07e..e3fa320 100644
--- include/freetype/internal/ftobjs.h
+++ include/freetype/internal/ftobjs.h
@@ -833,7 +833,7 @@ FT_BEGIN_HEADER
   /*                        filtering callback function.                   */
   /*                                                                       */
   /*    pic_container    :: Contains global structs and tables, instead    */
-  /*                        of defining them globallly.                    */
+  /*                        of defining them globally.                     */
   /*                                                                       */
   /*    refcount         :: A counter initialized to~1 at the time an      */
   /*                        @FT_Library structure is created.              */
@@ -971,8 +971,8 @@ FT_BEGIN_HEADER
   /*                                                                       */
   /* <Description>                                                         */
   /*    Used to initialize an instance of FT_Outline_Funcs struct.         */
-  /*    When FT_CONFIG_OPTION_PIC is defined an init funtion will need to  */
-  /*    be called with a pre-allocated structure to be filled.             */
+  /*    When FT_CONFIG_OPTION_PIC is defined an init function will need    */
+  /*    to be called with a pre-allocated structure to be filled.          */
   /*    When FT_CONFIG_OPTION_PIC is not defined the struct will be        */
   /*    allocated in the global scope (or the scope where the macro        */
   /*    is used).                                                          */
@@ -1030,8 +1030,8 @@ FT_BEGIN_HEADER
   /*                                                                       */
   /* <Description>                                                         */
   /*    Used to initialize an instance of FT_Raster_Funcs struct.          */
-  /*    When FT_CONFIG_OPTION_PIC is defined an init funtion will need to  */
-  /*    be called with a pre-allocated structure to be filled.             */
+  /*    When FT_CONFIG_OPTION_PIC is defined an init function will need    */
+  /*    to be called with a pre-allocated structure to be filled.          */
   /*    When FT_CONFIG_OPTION_PIC is not defined the struct will be        */
   /*    allocated in the global scope (or the scope where the macro        */
   /*    is used).                                                          */
@@ -1090,8 +1090,8 @@ FT_BEGIN_HEADER
   /*                                                                       */
   /* <Description>                                                         */
   /*    Used to initialize an instance of FT_Glyph_Class struct.           */
-  /*    When FT_CONFIG_OPTION_PIC is defined an init funtion will need to  */
-  /*    be called with a pre-allocated stcture to be filled.               */
+  /*    When FT_CONFIG_OPTION_PIC is defined an init function will need    */
+  /*    to be called with a pre-allocated structure to be filled.          */
   /*    When FT_CONFIG_OPTION_PIC is not defined the struct will be        */
   /*    allocated in the global scope (or the scope where the macro        */
   /*    is used).                                                          */
@@ -1164,11 +1164,11 @@ FT_BEGIN_HEADER
   /* <Description>                                                         */
   /*    Used to initialize an instance of FT_Renderer_Class struct.        */
   /*                                                                       */
-  /*    When FT_CONFIG_OPTION_PIC is defined a `create' funtion will need  */
-  /*    to be called with a pointer where the allocated structure is       */
+  /*    When FT_CONFIG_OPTION_PIC is defined a `create' function will      */
+  /*    need to be called with a pointer where the allocated structure is  */
   /*    returned.  And when it is no longer needed a `destroy' function    */
   /*    needs to be called to release that allocation.                     */
-  /*    `fcinit.c' (ft_create_default_module_classes) already contains     */
+  /*    `ftinit.c' (ft_create_default_module_classes) already contains     */
   /*    a mechanism to call these functions for the default modules        */
   /*    described in `ftmodule.h'.                                         */
   /*                                                                       */
@@ -1368,11 +1368,11 @@ FT_BEGIN_HEADER
   /* <Description>                                                         */
   /*    Used to initialize an instance of an FT_Module_Class struct.       */
   /*                                                                       */
-  /*    When FT_CONFIG_OPTION_PIC is defined a `create' funtion needs to   */
-  /*    be called with a pointer where the allocated structure is          */
+  /*    When FT_CONFIG_OPTION_PIC is defined a `create' function needs     */
+  /*    to be called with a pointer where the allocated structure is       */
   /*    returned.  And when it is no longer needed a `destroy' function    */
   /*    needs to be called to release that allocation.                     */
-  /*    `fcinit.c' (ft_create_default_module_classes) already contains     */
+  /*    `ftinit.c' (ft_create_default_module_classes) already contains     */
   /*    a mechanism to call these functions for the default modules        */
   /*    described in `ftmodule.h'.                                         */
   /*                                                                       */
diff --git include/freetype/internal/ftrfork.h include/freetype/internal/ftrfork.h
index 13a68fe..b923401 100644
--- include/freetype/internal/ftrfork.h
+++ include/freetype/internal/ftrfork.h
@@ -227,7 +227,7 @@ FT_BEGIN_HEADER
   /*    sort_by_res_id ::                                                  */
   /*      A Boolean to sort the fragmented resource by their ids.          */
   /*      The fragmented resources for `POST' resource should be sorted    */
-  /*      to restore Type1 font properly.  For `snft' resources, sorting   */
+  /*      to restore Type1 font properly.  For `sfnt' resources, sorting   */
   /*      may induce a different order of the faces in comparison to that  */
   /*      by QuickDraw API.                                                */
   /*                                                                       */
diff --git include/freetype/internal/internal.h include/freetype/internal/internal.h
index 689afa9..8c3c14c 100644
--- include/freetype/internal/internal.h
+++ include/freetype/internal/internal.h
@@ -44,7 +44,6 @@
 
 #define FT_INTERNAL_POSTSCRIPT_AUX_H      <freetype/internal/psaux.h>
 #define FT_INTERNAL_POSTSCRIPT_HINTS_H    <freetype/internal/pshints.h>
-#define FT_INTERNAL_POSTSCRIPT_GLOBALS_H  <freetype/internal/psglobal.h>
 
 #define FT_INTERNAL_AUTOHINT_H            <freetype/internal/autohint.h>
 
diff --git include/freetype/internal/tttypes.h include/freetype/internal/tttypes.h
index 8643775..8f1a642 100644
--- include/freetype/internal/tttypes.h
+++ include/freetype/internal/tttypes.h
@@ -185,7 +185,7 @@ FT_BEGIN_HEADER
   /*                                                                       */
   /*    CompLength :: Compressed table length (in bytes).                  */
   /*                                                                       */
-  /*    OrigLength :: Unompressed table length (in bytes).                 */
+  /*    OrigLength :: Uncompressed table length (in bytes).                */
   /*                                                                       */
   /*    CheckSum   :: The table checksum.  This value can be ignored.      */
   /*                                                                       */
diff --git include/freetype/tttables.h include/freetype/tttables.h
index dfe3bcb..1c075dc 100644
--- include/freetype/tttables.h
+++ include/freetype/tttables.h
@@ -587,7 +587,7 @@ FT_BEGIN_HEADER
   /*                                                                       */
   /*    FT_SFNT_HHEA :: To access the font's @TT_HoriHeader structure.     */
   /*                                                                       */
-  /*    FT_SFNT_VHEA :: To access the font's @TT_VertHeader struture.      */
+  /*    FT_SFNT_VHEA :: To access the font's @TT_VertHeader structure.     */
   /*                                                                       */
   /*    FT_SFNT_POST :: To access the font's @TT_Postscript structure.     */
   /*                                                                       */
diff --git src/autofit/afblue.c src/autofit/afblue.c
index 7d9646c..f1699a8 100644
--- src/autofit/afblue.c
+++ src/autofit/afblue.c
@@ -54,6 +54,26 @@
     '\0',
     '\xE0', '\xA5', '\x81', ' ', '\xE0', '\xA5', '\x83',  /* ु ृ */
     '\0',
+    '\xE1', '\x83', '\x92', ' ', '\xE1', '\x83', '\x93', ' ', '\xE1', '\x83', '\x94', ' ', '\xE1', '\x83', '\x95', ' ', '\xE1', '\x83', '\x97', ' ', '\xE1', '\x83', '\x98', ' ', '\xE1', '\x83', '\x9D', ' ', '\xE1', '\x83', '\xA6',  /* გ დ ე ვ თ ი ო ღ */
+    '\0',
+    '\xE1', '\x83', '\x90', ' ', '\xE1', '\x83', '\x96', ' ', '\xE1', '\x83', '\x9B', ' ', '\xE1', '\x83', '\xA1', ' ', '\xE1', '\x83', '\xA8', ' ', '\xE1', '\x83', '\xAB', ' ', '\xE1', '\x83', '\xAE', ' ', '\xE1', '\x83', '\xB0',  /* ა ზ მ ს შ ძ ხ ჰ */
+    '\0',
+    '\xE1', '\x83', '\xA1', ' ', '\xE1', '\x83', '\xAE', ' ', '\xE1', '\x83', '\xA5', ' ', '\xE1', '\x83', '\x96', ' ', '\xE1', '\x83', '\x9B', ' ', '\xE1', '\x83', '\xA8', ' ', '\xE1', '\x83', '\xA9', ' ', '\xE1', '\x83', '\xAC',  /* ს ხ ქ ზ მ შ ჩ წ */
+    '\0',
+    '\xE1', '\x83', '\x94', ' ', '\xE1', '\x83', '\x95', ' ', '\xE1', '\x83', '\x9F', ' ', '\xE1', '\x83', '\xA2', ' ', '\xE1', '\x83', '\xA3', ' ', '\xE1', '\x83', '\xA4', ' ', '\xE1', '\x83', '\xA5', ' ', '\xE1', '\x83', '\xA7',  /* ე ვ ჟ ტ უ ფ ქ ყ */
+    '\0',
+    '\xE1', '\x82', '\xB1', ' ', '\xE1', '\x82', '\xA7', ' ', '\xE1', '\x82', '\xB9', ' ', '\xE1', '\x82', '\xBC', ' ', '\xE1', '\x82', '\xA4', ' ', '\xE1', '\x82', '\xA5', ' ', '\xE1', '\x82', '\xB3', ' ', '\xE1', '\x82', '\xBA',  /* Ⴑ Ⴇ Ⴙ Ⴜ Ⴄ Ⴅ Ⴓ Ⴚ */
+    '\0',
+    '\xE1', '\x82', '\xA4', ' ', '\xE1', '\x82', '\xA5', ' ', '\xE1', '\x82', '\xA7', ' ', '\xE1', '\x82', '\xA8', ' ', '\xE1', '\x82', '\xA6', ' ', '\xE1', '\x82', '\xB1', ' ', '\xE1', '\x82', '\xAA', ' ', '\xE1', '\x82', '\xAB',  /* Ⴄ Ⴅ Ⴇ Ⴈ Ⴆ Ⴑ Ⴊ Ⴋ */
+    '\0',
+    '\xE2', '\xB4', '\x81', ' ', '\xE2', '\xB4', '\x97', ' ', '\xE2', '\xB4', '\x82', ' ', '\xE2', '\xB4', '\x84', ' ', '\xE2', '\xB4', '\x85', ' ', '\xE2', '\xB4', '\x87', ' ', '\xE2', '\xB4', '\x94', ' ', '\xE2', '\xB4', '\x96',  /* ⴁ ⴗ ⴂ ⴄ ⴅ ⴇ ⴔ ⴖ */
+    '\0',
+    '\xE2', '\xB4', '\x88', ' ', '\xE2', '\xB4', '\x8C', ' ', '\xE2', '\xB4', '\x96', ' ', '\xE2', '\xB4', '\x8E', ' ', '\xE2', '\xB4', '\x83', ' ', '\xE2', '\xB4', '\x86', ' ', '\xE2', '\xB4', '\x8B', ' ', '\xE2', '\xB4', '\xA2',  /* ⴈ ⴌ ⴖ ⴎ ⴃ ⴆ ⴋ ⴢ */
+    '\0',
+    '\xE2', '\xB4', '\x90', ' ', '\xE2', '\xB4', '\x91', ' ', '\xE2', '\xB4', '\x93', ' ', '\xE2', '\xB4', '\x95', ' ', '\xE2', '\xB4', '\x99', ' ', '\xE2', '\xB4', '\x9B', ' ', '\xE2', '\xB4', '\xA1', ' ', '\xE2', '\xB4', '\xA3',  /* ⴐ ⴑ ⴓ ⴕ ⴙ ⴛ ⴡ ⴣ */
+    '\0',
+    '\xE2', '\xB4', '\x84', ' ', '\xE2', '\xB4', '\x85', ' ', '\xE2', '\xB4', '\x94', ' ', '\xE2', '\xB4', '\x95', ' ', '\xE2', '\xB4', '\x81', ' ', '\xE2', '\xB4', '\x82', ' ', '\xE2', '\xB4', '\x98', ' ', '\xE2', '\xB4', '\x9D',  /* ⴄ ⴅ ⴔ ⴕ ⴁ ⴂ ⴘ ⴝ */
+    '\0',
     '\xCE', '\x93', ' ', '\xCE', '\x92', ' ', '\xCE', '\x95', ' ', '\xCE', '\x96', ' ', '\xCE', '\x98', ' ', '\xCE', '\x9F', ' ', '\xCE', '\xA9',  /* Γ Β Ε Ζ Θ Ο Ω */
     '\0',
     '\xCE', '\x92', ' ', '\xCE', '\x94', ' ', '\xCE', '\x96', ' ', '\xCE', '\x9E', ' ', '\xCE', '\x98', ' ', '\xCE', '\x9F',  /* Β Δ Ζ Ξ Θ Ο */
@@ -128,6 +148,10 @@
     '\0',
     '\xE1', '\xB5', '\x96', ' ', '\xCA', '\xB8', ' ', '\xE1', '\xB5', '\x8D',  /* ᵖ ʸ ᵍ */
     '\0',
+    '\xE0', '\xB4', '\x92', ' ', '\xE0', '\xB4', '\x9F', ' ', '\xE0', '\xB4', '\xA0', ' ', '\xE0', '\xB4', '\xB1', ' ', '\xE0', '\xB4', '\x9A', ' ', '\xE0', '\xB4', '\xAA', ' ', '\xE0', '\xB4', '\x9A', '\xE0', '\xB5', '\x8D', '\xE0', '\xB4', '\x9A', ' ', '\xE0', '\xB4', '\xAA', '\xE0', '\xB5', '\x8D', '\xE0', '\xB4', '\xAA',  /* ഒ ട ഠ റ ച പ ച്ച പ്പ */
+    '\0',
+    '\xE0', '\xB4', '\x9F', ' ', '\xE0', '\xB4', '\xA0', ' ', '\xE0', '\xB4', '\xA7', ' ', '\xE0', '\xB4', '\xB6', ' ', '\xE0', '\xB4', '\x98', ' ', '\xE0', '\xB4', '\x9A', ' ', '\xE0', '\xB4', '\xA5', ' ', '\xE0', '\xB4', '\xB2',  /* ട ഠ ധ ശ ഘ ച ഥ ല */
+    '\0',
     '\xE1', '\x80', '\x81', ' ', '\xE1', '\x80', '\x82', ' ', '\xE1', '\x80', '\x84', ' ', '\xE1', '\x80', '\x92', ' ', '\xE1', '\x80', '\x9D', ' ', '\xE1', '\x81', '\xA5', ' ', '\xE1', '\x81', '\x8A', ' ', '\xE1', '\x81', '\x8B',  /* ခ ဂ င ဒ ဝ ၥ ၊ ။ */
     '\0',
     '\xE1', '\x80', '\x84', ' ', '\xE1', '\x80', '\x8E', ' ', '\xE1', '\x80', '\x92', ' ', '\xE1', '\x80', '\x95', ' ', '\xE1', '\x80', '\x97', ' ', '\xE1', '\x80', '\x9D', ' ', '\xE1', '\x81', '\x8A', ' ', '\xE1', '\x81', '\x8B',  /* င ဎ ဒ ပ ဗ ဝ ၊ ။ */
@@ -136,6 +160,16 @@
     '\0',
     '\xE1', '\x80', '\x89', ' ', '\xE1', '\x80', '\x8A', ' ', '\xE1', '\x80', '\xA5', ' ', '\xE1', '\x80', '\xA9', ' ', '\xE1', '\x80', '\xA8', ' ', '\xE1', '\x81', '\x82', ' ', '\xE1', '\x81', '\x85', ' ', '\xE1', '\x81', '\x89',  /* ဉ ည ဥ ဩ ဨ ၂ ၅ ၉ */
     '\0',
+    '\xE0', '\xB6', '\x89', ' ', '\xE0', '\xB6', '\x9A', ' ', '\xE0', '\xB6', '\x9D', ' ', '\xE0', '\xB6', '\xB3', ' ', '\xE0', '\xB6', '\xB4', ' ', '\xE0', '\xB6', '\xBA', ' ', '\xE0', '\xB6', '\xBD', ' ', '\xE0', '\xB7', '\x86',  /* ඉ ක ඝ ඳ ප ය ල ෆ */
+    '\0',
+    '\xE0', '\xB6', '\x91', ' ', '\xE0', '\xB6', '\x94', ' ', '\xE0', '\xB6', '\x9D', ' ', '\xE0', '\xB6', '\xA2', ' ', '\xE0', '\xB6', '\xA7', ' ', '\xE0', '\xB6', '\xAE', ' ', '\xE0', '\xB6', '\xB0', ' ', '\xE0', '\xB6', '\xBB',  /* එ ඔ ඝ ජ ට ථ ධ ර */
+    '\0',
+    '\xE0', '\xB6', '\xAF', ' ', '\xE0', '\xB6', '\xB3', ' ', '\xE0', '\xB6', '\x8B', ' ', '\xE0', '\xB6', '\xBD', ' ', '\xE0', '\xB6', '\xAD', '\xE0', '\xB7', '\x96', ' ', '\xE0', '\xB6', '\xAD', '\xE0', '\xB7', '\x94', ' ', '\xE0', '\xB6', '\xB6', '\xE0', '\xB7', '\x94', ' ', '\xE0', '\xB6', '\xAF', '\xE0', '\xB7', '\x94',  /* ද ඳ උ ල තූ තු බු දු */
+    '\0',
+    '\xE0', '\xAE', '\x89', ' ', '\xE0', '\xAE', '\x92', ' ', '\xE0', '\xAE', '\x93', ' ', '\xE0', '\xAE', '\xB1', ' ', '\xE0', '\xAE', '\x88', ' ', '\xE0', '\xAE', '\x95', ' ', '\xE0', '\xAE', '\x99', ' ', '\xE0', '\xAE', '\x9A',  /* உ ஒ ஓ ற ஈ க ங ச */
+    '\0',
+    '\xE0', '\xAE', '\x95', ' ', '\xE0', '\xAE', '\x9A', ' ', '\xE0', '\xAE', '\xB2', ' ', '\xE0', '\xAE', '\xB6', ' ', '\xE0', '\xAE', '\x89', ' ', '\xE0', '\xAE', '\x99', ' ', '\xE0', '\xAE', '\x9F', ' ', '\xE0', '\xAE', '\xAA',  /* க ச ல ஶ உ ங ட ப */
+    '\0',
     '\xE0', '\xB0', '\x87', ' ', '\xE0', '\xB0', '\x8C', ' ', '\xE0', '\xB0', '\x99', ' ', '\xE0', '\xB0', '\x9E', ' ', '\xE0', '\xB0', '\xA3', ' ', '\xE0', '\xB0', '\xB1', ' ', '\xE0', '\xB1', '\xAF',  /* ఇ ఌ ఙ ఞ ణ ఱ ౯ */
     '\0',
     '\xE0', '\xB0', '\x85', ' ', '\xE0', '\xB0', '\x95', ' ', '\xE0', '\xB0', '\x9A', ' ', '\xE0', '\xB0', '\xB0', ' ', '\xE0', '\xB0', '\xBD', ' ', '\xE0', '\xB1', '\xA8', ' ', '\xE0', '\xB1', '\xAC',  /* అ క చ ర ఽ ౨ ౬ */
@@ -229,6 +263,20 @@
     { AF_BLUE_STRING_DEVANAGARI_BASE,   0                                 },
     { AF_BLUE_STRING_DEVANAGARI_BOTTOM, 0                                 },
     { AF_BLUE_STRING_MAX,               0                                 },
+    { AF_BLUE_STRING_GEORGIAN_MKHEDRULI_TOP,       AF_BLUE_PROPERTY_LATIN_TOP      |
+                                                   AF_BLUE_PROPERTY_LATIN_X_HEIGHT   },
+    { AF_BLUE_STRING_GEORGIAN_MKHEDRULI_BOTTOM,    0                                 },
+    { AF_BLUE_STRING_GEORGIAN_MKHEDRULI_ASCENDER,  AF_BLUE_PROPERTY_LATIN_TOP        },
+    { AF_BLUE_STRING_GEORGIAN_MKHEDRULI_DESCENDER, 0                                 },
+    { AF_BLUE_STRING_MAX,                          0                                 },
+    { AF_BLUE_STRING_GEORGIAN_ASOMTAVRULI_TOP,       AF_BLUE_PROPERTY_LATIN_TOP        },
+    { AF_BLUE_STRING_GEORGIAN_ASOMTAVRULI_BOTTOM,    0                                 },
+    { AF_BLUE_STRING_GEORGIAN_NUSKHURI_TOP,          AF_BLUE_PROPERTY_LATIN_TOP      |
+                                                     AF_BLUE_PROPERTY_LATIN_X_HEIGHT   },
+    { AF_BLUE_STRING_GEORGIAN_NUSKHURI_BOTTOM,       0                                 },
+    { AF_BLUE_STRING_GEORGIAN_NUSKHURI_ASCENDER,     AF_BLUE_PROPERTY_LATIN_TOP        },
+    { AF_BLUE_STRING_GEORGIAN_NUSKHURI_DESCENDER,    0                                 },
+    { AF_BLUE_STRING_MAX,                            0                                 },
     { AF_BLUE_STRING_GREEK_CAPITAL_TOP,     AF_BLUE_PROPERTY_LATIN_TOP        },
     { AF_BLUE_STRING_GREEK_CAPITAL_BOTTOM,  0                                 },
     { AF_BLUE_STRING_GREEK_SMALL_BETA_TOP,  AF_BLUE_PROPERTY_LATIN_TOP        },
@@ -287,12 +335,23 @@
     { AF_BLUE_STRING_LATIN_SUPS_SMALL,           0                                 },
     { AF_BLUE_STRING_LATIN_SUPS_SMALL_DESCENDER, 0                                 },
     { AF_BLUE_STRING_MAX,                        0                                 },
+    { AF_BLUE_STRING_MALAYALAM_TOP,    AF_BLUE_PROPERTY_LATIN_TOP },
+    { AF_BLUE_STRING_MALAYALAM_BOTTOM, 0                          },
+    { AF_BLUE_STRING_MAX,              0                          },
     { AF_BLUE_STRING_MYANMAR_TOP,       AF_BLUE_PROPERTY_LATIN_TOP      |
                                         AF_BLUE_PROPERTY_LATIN_X_HEIGHT   },
     { AF_BLUE_STRING_MYANMAR_BOTTOM,    0                                 },
     { AF_BLUE_STRING_MYANMAR_ASCENDER,  AF_BLUE_PROPERTY_LATIN_TOP        },
     { AF_BLUE_STRING_MYANMAR_DESCENDER, 0                                 },
     { AF_BLUE_STRING_MAX,               0                                 },
+    { AF_BLUE_STRING_MAX, 0 },
+    { AF_BLUE_STRING_SINHALA_TOP,       AF_BLUE_PROPERTY_LATIN_TOP },
+    { AF_BLUE_STRING_SINHALA_BOTTOM,    0                          },
+    { AF_BLUE_STRING_SINHALA_DESCENDER, 0                          },
+    { AF_BLUE_STRING_MAX,               0                          },
+    { AF_BLUE_STRING_TAMIL_TOP,    AF_BLUE_PROPERTY_LATIN_TOP },
+    { AF_BLUE_STRING_TAMIL_BOTTOM, 0                          },
+    { AF_BLUE_STRING_MAX,          0                          },
     { AF_BLUE_STRING_TELUGU_TOP,    AF_BLUE_PROPERTY_LATIN_TOP },
     { AF_BLUE_STRING_TELUGU_BOTTOM, 0                          },
     { AF_BLUE_STRING_MAX,           0                          },
diff --git src/autofit/afblue.dat src/autofit/afblue.dat
index 9a7757c..827daef 100644
--- src/autofit/afblue.dat
+++ src/autofit/afblue.dat
@@ -65,8 +65,8 @@
 // values; this essentially means that the maximum values can easily be too
 // large.  Given that the purpose of those values is to create local
 // fixed-size arrays at compile time for further processing of the blue zone
-// data, this isn't a problem.  Note the the final zero byte of a string is
-// not counted.  Note also that the count holds the number of UTF-8 encoded
+// data, this isn't a problem.  Note the final zero byte of a string is not
+// counted.  Note also that the count holds the number of UTF-8 encoded
 // characters, not bytes.
 
 
@@ -114,6 +114,29 @@ AF_BLUE_STRING_ENUM AF_BLUE_STRINGS_ARRAY AF_BLUE_STRING_MAX_LEN:
   AF_BLUE_STRING_DEVANAGARI_BOTTOM
     "ु ृ"
 
+  AF_BLUE_STRING_GEORGIAN_MKHEDRULI_TOP
+    "გ დ ე ვ თ ი ო ღ"
+  AF_BLUE_STRING_GEORGIAN_MKHEDRULI_BOTTOM
+    "ა ზ მ ს შ ძ ხ ჰ"
+  AF_BLUE_STRING_GEORGIAN_MKHEDRULI_ASCENDER
+    "ს ხ ქ ზ მ შ ჩ წ"
+  AF_BLUE_STRING_GEORGIAN_MKHEDRULI_DESCENDER
+    "ე ვ ჟ ტ უ ფ ქ ყ"
+
+  AF_BLUE_STRING_GEORGIAN_ASOMTAVRULI_TOP
+    "Ⴑ Ⴇ Ⴙ Ⴜ Ⴄ Ⴅ Ⴓ Ⴚ"
+  AF_BLUE_STRING_GEORGIAN_ASOMTAVRULI_BOTTOM
+    "Ⴄ Ⴅ Ⴇ Ⴈ Ⴆ Ⴑ Ⴊ Ⴋ"
+
+  AF_BLUE_STRING_GEORGIAN_NUSKHURI_TOP
+    "ⴁ ⴗ ⴂ ⴄ ⴅ ⴇ ⴔ ⴖ"
+  AF_BLUE_STRING_GEORGIAN_NUSKHURI_BOTTOM
+    "ⴈ ⴌ ⴖ ⴎ ⴃ ⴆ ⴋ ⴢ"
+  AF_BLUE_STRING_GEORGIAN_NUSKHURI_ASCENDER
+    "ⴐ ⴑ ⴓ ⴕ ⴙ ⴛ ⴡ ⴣ"
+  AF_BLUE_STRING_GEORGIAN_NUSKHURI_DESCENDER
+    "ⴄ ⴅ ⴔ ⴕ ⴁ ⴂ ⴘ ⴝ"
+
   AF_BLUE_STRING_GREEK_CAPITAL_TOP
     "Γ Β Ε Ζ Θ Ο Ω"
   AF_BLUE_STRING_GREEK_CAPITAL_BOTTOM
@@ -200,6 +223,11 @@ AF_BLUE_STRING_ENUM AF_BLUE_STRINGS_ARRAY AF_BLUE_STRING_MAX_LEN:
   AF_BLUE_STRING_LATIN_SUPS_SMALL_DESCENDER
     "ᵖ ʸ ᵍ"
 
+  AF_BLUE_STRING_MALAYALAM_TOP
+    "ഒ ട ഠ റ ച പ ച്ച പ്പ"
+  AF_BLUE_STRING_MALAYALAM_BOTTOM
+    "ട ഠ ധ ശ ഘ ച ഥ ല"
+
   AF_BLUE_STRING_MYANMAR_TOP
     "ခ ဂ င ဒ ဝ ၥ ၊ ။"
   AF_BLUE_STRING_MYANMAR_BOTTOM
@@ -209,6 +237,18 @@ AF_BLUE_STRING_ENUM AF_BLUE_STRINGS_ARRAY AF_BLUE_STRING_MAX_LEN:
   AF_BLUE_STRING_MYANMAR_DESCENDER
     "ဉ ည ဥ ဩ ဨ ၂ ၅ ၉"
 
+  AF_BLUE_STRING_SINHALA_TOP
+    "ඉ ක ඝ ඳ ප ය ල ෆ"
+  AF_BLUE_STRING_SINHALA_BOTTOM
+    "එ ඔ ඝ ජ ට ථ ධ ර"
+  AF_BLUE_STRING_SINHALA_DESCENDER
+    "ද ඳ උ ල තූ තු බු දු"
+
+  AF_BLUE_STRING_TAMIL_TOP
+    "உ ஒ ஓ ற ஈ க ங ச"
+  AF_BLUE_STRING_TAMIL_BOTTOM
+    "க ச ல ஶ உ ங ட ப"
+
   AF_BLUE_STRING_TELUGU_TOP
     "ఇ ఌ ఙ ఞ ణ ఱ ౯"
   AF_BLUE_STRING_TELUGU_BOTTOM
@@ -428,6 +468,25 @@ AF_BLUE_STRINGSET_ENUM AF_BLUE_STRINGSETS_ARRAY AF_BLUE_STRINGSET_MAX_LEN:
     { AF_BLUE_STRING_DEVANAGARI_BOTTOM, 0                                 }
     { AF_BLUE_STRING_MAX,               0                                 }
 
+  // blue zones for Mtavruli are missing (not yet defined in Unicode)
+  AF_BLUE_STRINGSET_GEOR
+    { AF_BLUE_STRING_GEORGIAN_MKHEDRULI_TOP,       AF_BLUE_PROPERTY_LATIN_TOP      |
+                                                   AF_BLUE_PROPERTY_LATIN_X_HEIGHT   }
+    { AF_BLUE_STRING_GEORGIAN_MKHEDRULI_BOTTOM,    0                                 }
+    { AF_BLUE_STRING_GEORGIAN_MKHEDRULI_ASCENDER,  AF_BLUE_PROPERTY_LATIN_TOP        }
+    { AF_BLUE_STRING_GEORGIAN_MKHEDRULI_DESCENDER, 0                                 }
+    { AF_BLUE_STRING_MAX,                          0                                 }
+
+  AF_BLUE_STRINGSET_GEOK
+    { AF_BLUE_STRING_GEORGIAN_ASOMTAVRULI_TOP,       AF_BLUE_PROPERTY_LATIN_TOP        }
+    { AF_BLUE_STRING_GEORGIAN_ASOMTAVRULI_BOTTOM,    0                                 }
+    { AF_BLUE_STRING_GEORGIAN_NUSKHURI_TOP,          AF_BLUE_PROPERTY_LATIN_TOP      |
+                                                     AF_BLUE_PROPERTY_LATIN_X_HEIGHT   }
+    { AF_BLUE_STRING_GEORGIAN_NUSKHURI_BOTTOM,       0                                 }
+    { AF_BLUE_STRING_GEORGIAN_NUSKHURI_ASCENDER,     AF_BLUE_PROPERTY_LATIN_TOP        }
+    { AF_BLUE_STRING_GEORGIAN_NUSKHURI_DESCENDER,    0                                 }
+    { AF_BLUE_STRING_MAX,                            0                                 }
+
   AF_BLUE_STRINGSET_GREK
     { AF_BLUE_STRING_GREEK_CAPITAL_TOP,     AF_BLUE_PROPERTY_LATIN_TOP        }
     { AF_BLUE_STRING_GREEK_CAPITAL_BOTTOM,  0                                 }
@@ -504,6 +563,11 @@ AF_BLUE_STRINGSET_ENUM AF_BLUE_STRINGSETS_ARRAY AF_BLUE_STRINGSET_MAX_LEN:
     { AF_BLUE_STRING_LATIN_SUPS_SMALL_DESCENDER, 0                                 }
     { AF_BLUE_STRING_MAX,                        0                                 }
 
+  AF_BLUE_STRINGSET_MLYM
+    { AF_BLUE_STRING_MALAYALAM_TOP,    AF_BLUE_PROPERTY_LATIN_TOP }
+    { AF_BLUE_STRING_MALAYALAM_BOTTOM, 0                          }
+    { AF_BLUE_STRING_MAX,              0                          }
+
   AF_BLUE_STRINGSET_MYMR
     { AF_BLUE_STRING_MYANMAR_TOP,       AF_BLUE_PROPERTY_LATIN_TOP      |
                                         AF_BLUE_PROPERTY_LATIN_X_HEIGHT   }
@@ -512,6 +576,20 @@ AF_BLUE_STRINGSET_ENUM AF_BLUE_STRINGSETS_ARRAY AF_BLUE_STRINGSET_MAX_LEN:
     { AF_BLUE_STRING_MYANMAR_DESCENDER, 0                                 }
     { AF_BLUE_STRING_MAX,               0                                 }
 
+  AF_BLUE_STRINGSET_NONE
+    { AF_BLUE_STRING_MAX, 0 }
+
+  AF_BLUE_STRINGSET_SINH
+    { AF_BLUE_STRING_SINHALA_TOP,       AF_BLUE_PROPERTY_LATIN_TOP }
+    { AF_BLUE_STRING_SINHALA_BOTTOM,    0                          }
+    { AF_BLUE_STRING_SINHALA_DESCENDER, 0                          }
+    { AF_BLUE_STRING_MAX,               0                          }
+
+  AF_BLUE_STRINGSET_TAML
+    { AF_BLUE_STRING_TAMIL_TOP,    AF_BLUE_PROPERTY_LATIN_TOP }
+    { AF_BLUE_STRING_TAMIL_BOTTOM, 0                          }
+    { AF_BLUE_STRING_MAX,          0                          }
+
   AF_BLUE_STRINGSET_TELU
     { AF_BLUE_STRING_TELUGU_TOP,    AF_BLUE_PROPERTY_LATIN_TOP }
     { AF_BLUE_STRING_TELUGU_BOTTOM, 0                          }
diff --git src/autofit/afblue.h src/autofit/afblue.h
index 75cd6c3..2ec7d82 100644
--- src/autofit/afblue.h
+++ src/autofit/afblue.h
@@ -91,57 +91,74 @@ FT_BEGIN_HEADER
     AF_BLUE_STRING_DEVANAGARI_TOP = 241,
     AF_BLUE_STRING_DEVANAGARI_HEAD = 273,
     AF_BLUE_STRING_DEVANAGARI_BOTTOM = 305,
-    AF_BLUE_STRING_GREEK_CAPITAL_TOP = 313,
-    AF_BLUE_STRING_GREEK_CAPITAL_BOTTOM = 334,
-    AF_BLUE_STRING_GREEK_SMALL_BETA_TOP = 352,
-    AF_BLUE_STRING_GREEK_SMALL = 370,
-    AF_BLUE_STRING_GREEK_SMALL_DESCENDER = 394,
-    AF_BLUE_STRING_HEBREW_TOP = 418,
-    AF_BLUE_STRING_HEBREW_BOTTOM = 442,
-    AF_BLUE_STRING_HEBREW_DESCENDER = 460,
-    AF_BLUE_STRING_KANNADA_TOP = 475,
-    AF_BLUE_STRING_KANNADA_BOTTOM = 519,
-    AF_BLUE_STRING_KHMER_TOP = 551,
-    AF_BLUE_STRING_KHMER_SUBSCRIPT_TOP = 575,
-    AF_BLUE_STRING_KHMER_BOTTOM = 615,
-    AF_BLUE_STRING_KHMER_DESCENDER = 647,
-    AF_BLUE_STRING_KHMER_LARGE_DESCENDER = 681,
-    AF_BLUE_STRING_KHMER_SYMBOLS_WAXING_TOP = 768,
-    AF_BLUE_STRING_KHMER_SYMBOLS_WANING_BOTTOM = 776,
-    AF_BLUE_STRING_LAO_TOP = 784,
-    AF_BLUE_STRING_LAO_BOTTOM = 816,
-    AF_BLUE_STRING_LAO_ASCENDER = 848,
-    AF_BLUE_STRING_LAO_LARGE_ASCENDER = 864,
-    AF_BLUE_STRING_LAO_DESCENDER = 876,
-    AF_BLUE_STRING_LATIN_CAPITAL_TOP = 900,
-    AF_BLUE_STRING_LATIN_CAPITAL_BOTTOM = 916,
-    AF_BLUE_STRING_LATIN_SMALL_F_TOP = 932,
-    AF_BLUE_STRING_LATIN_SMALL = 946,
-    AF_BLUE_STRING_LATIN_SMALL_DESCENDER = 960,
-    AF_BLUE_STRING_LATIN_SUBS_CAPITAL_TOP = 970,
-    AF_BLUE_STRING_LATIN_SUBS_CAPITAL_BOTTOM = 990,
-    AF_BLUE_STRING_LATIN_SUBS_SMALL_F_TOP = 1010,
-    AF_BLUE_STRING_LATIN_SUBS_SMALL = 1030,
-    AF_BLUE_STRING_LATIN_SUBS_SMALL_DESCENDER = 1066,
-    AF_BLUE_STRING_LATIN_SUPS_CAPITAL_TOP = 1086,
-    AF_BLUE_STRING_LATIN_SUPS_CAPITAL_BOTTOM = 1117,
-    AF_BLUE_STRING_LATIN_SUPS_SMALL_F_TOP = 1146,
-    AF_BLUE_STRING_LATIN_SUPS_SMALL = 1172,
-    AF_BLUE_STRING_LATIN_SUPS_SMALL_DESCENDER = 1197,
-    AF_BLUE_STRING_MYANMAR_TOP = 1208,
-    AF_BLUE_STRING_MYANMAR_BOTTOM = 1240,
-    AF_BLUE_STRING_MYANMAR_ASCENDER = 1272,
-    AF_BLUE_STRING_MYANMAR_DESCENDER = 1300,
-    AF_BLUE_STRING_TELUGU_TOP = 1332,
-    AF_BLUE_STRING_TELUGU_BOTTOM = 1360,
-    AF_BLUE_STRING_THAI_TOP = 1388,
-    AF_BLUE_STRING_THAI_BOTTOM = 1412,
-    AF_BLUE_STRING_THAI_ASCENDER = 1440,
-    AF_BLUE_STRING_THAI_LARGE_ASCENDER = 1452,
-    AF_BLUE_STRING_THAI_DESCENDER = 1464,
-    AF_BLUE_STRING_THAI_LARGE_DESCENDER = 1480,
-    AF_BLUE_STRING_THAI_DIGIT_TOP = 1488,
-    af_blue_1_1 = 1499,
+    AF_BLUE_STRING_GEORGIAN_MKHEDRULI_TOP = 313,
+    AF_BLUE_STRING_GEORGIAN_MKHEDRULI_BOTTOM = 345,
+    AF_BLUE_STRING_GEORGIAN_MKHEDRULI_ASCENDER = 377,
+    AF_BLUE_STRING_GEORGIAN_MKHEDRULI_DESCENDER = 409,
+    AF_BLUE_STRING_GEORGIAN_ASOMTAVRULI_TOP = 441,
+    AF_BLUE_STRING_GEORGIAN_ASOMTAVRULI_BOTTOM = 473,
+    AF_BLUE_STRING_GEORGIAN_NUSKHURI_TOP = 505,
+    AF_BLUE_STRING_GEORGIAN_NUSKHURI_BOTTOM = 537,
+    AF_BLUE_STRING_GEORGIAN_NUSKHURI_ASCENDER = 569,
+    AF_BLUE_STRING_GEORGIAN_NUSKHURI_DESCENDER = 601,
+    AF_BLUE_STRING_GREEK_CAPITAL_TOP = 633,
+    AF_BLUE_STRING_GREEK_CAPITAL_BOTTOM = 654,
+    AF_BLUE_STRING_GREEK_SMALL_BETA_TOP = 672,
+    AF_BLUE_STRING_GREEK_SMALL = 690,
+    AF_BLUE_STRING_GREEK_SMALL_DESCENDER = 714,
+    AF_BLUE_STRING_HEBREW_TOP = 738,
+    AF_BLUE_STRING_HEBREW_BOTTOM = 762,
+    AF_BLUE_STRING_HEBREW_DESCENDER = 780,
+    AF_BLUE_STRING_KANNADA_TOP = 795,
+    AF_BLUE_STRING_KANNADA_BOTTOM = 839,
+    AF_BLUE_STRING_KHMER_TOP = 871,
+    AF_BLUE_STRING_KHMER_SUBSCRIPT_TOP = 895,
+    AF_BLUE_STRING_KHMER_BOTTOM = 935,
+    AF_BLUE_STRING_KHMER_DESCENDER = 967,
+    AF_BLUE_STRING_KHMER_LARGE_DESCENDER = 1001,
+    AF_BLUE_STRING_KHMER_SYMBOLS_WAXING_TOP = 1088,
+    AF_BLUE_STRING_KHMER_SYMBOLS_WANING_BOTTOM = 1096,
+    AF_BLUE_STRING_LAO_TOP = 1104,
+    AF_BLUE_STRING_LAO_BOTTOM = 1136,
+    AF_BLUE_STRING_LAO_ASCENDER = 1168,
+    AF_BLUE_STRING_LAO_LARGE_ASCENDER = 1184,
+    AF_BLUE_STRING_LAO_DESCENDER = 1196,
+    AF_BLUE_STRING_LATIN_CAPITAL_TOP = 1220,
+    AF_BLUE_STRING_LATIN_CAPITAL_BOTTOM = 1236,
+    AF_BLUE_STRING_LATIN_SMALL_F_TOP = 1252,
+    AF_BLUE_STRING_LATIN_SMALL = 1266,
+    AF_BLUE_STRING_LATIN_SMALL_DESCENDER = 1280,
+    AF_BLUE_STRING_LATIN_SUBS_CAPITAL_TOP = 1290,
+    AF_BLUE_STRING_LATIN_SUBS_CAPITAL_BOTTOM = 1310,
+    AF_BLUE_STRING_LATIN_SUBS_SMALL_F_TOP = 1330,
+    AF_BLUE_STRING_LATIN_SUBS_SMALL = 1350,
+    AF_BLUE_STRING_LATIN_SUBS_SMALL_DESCENDER = 1386,
+    AF_BLUE_STRING_LATIN_SUPS_CAPITAL_TOP = 1406,
+    AF_BLUE_STRING_LATIN_SUPS_CAPITAL_BOTTOM = 1437,
+    AF_BLUE_STRING_LATIN_SUPS_SMALL_F_TOP = 1466,
+    AF_BLUE_STRING_LATIN_SUPS_SMALL = 1492,
+    AF_BLUE_STRING_LATIN_SUPS_SMALL_DESCENDER = 1517,
+    AF_BLUE_STRING_MALAYALAM_TOP = 1528,
+    AF_BLUE_STRING_MALAYALAM_BOTTOM = 1572,
+    AF_BLUE_STRING_MYANMAR_TOP = 1604,
+    AF_BLUE_STRING_MYANMAR_BOTTOM = 1636,
+    AF_BLUE_STRING_MYANMAR_ASCENDER = 1668,
+    AF_BLUE_STRING_MYANMAR_DESCENDER = 1696,
+    AF_BLUE_STRING_SINHALA_TOP = 1728,
+    AF_BLUE_STRING_SINHALA_BOTTOM = 1760,
+    AF_BLUE_STRING_SINHALA_DESCENDER = 1792,
+    AF_BLUE_STRING_TAMIL_TOP = 1836,
+    AF_BLUE_STRING_TAMIL_BOTTOM = 1868,
+    AF_BLUE_STRING_TELUGU_TOP = 1900,
+    AF_BLUE_STRING_TELUGU_BOTTOM = 1928,
+    AF_BLUE_STRING_THAI_TOP = 1956,
+    AF_BLUE_STRING_THAI_BOTTOM = 1980,
+    AF_BLUE_STRING_THAI_ASCENDER = 2008,
+    AF_BLUE_STRING_THAI_LARGE_ASCENDER = 2020,
+    AF_BLUE_STRING_THAI_DESCENDER = 2032,
+    AF_BLUE_STRING_THAI_LARGE_DESCENDER = 2048,
+    AF_BLUE_STRING_THAI_DIGIT_TOP = 2056,
+    af_blue_1_1 = 2067,
 #ifdef AF_CONFIG_OPTION_CJK
     AF_BLUE_STRING_CJK_TOP = af_blue_1_1 + 1,
     AF_BLUE_STRING_CJK_BOTTOM = af_blue_1_1 + 203,
@@ -204,19 +221,25 @@ FT_BEGIN_HEADER
     AF_BLUE_STRINGSET_BENG = 4,
     AF_BLUE_STRINGSET_CYRL = 9,
     AF_BLUE_STRINGSET_DEVA = 15,
-    AF_BLUE_STRINGSET_GREK = 21,
-    AF_BLUE_STRINGSET_HEBR = 28,
-    AF_BLUE_STRINGSET_KNDA = 32,
-    AF_BLUE_STRINGSET_KHMR = 35,
-    AF_BLUE_STRINGSET_KHMS = 41,
-    AF_BLUE_STRINGSET_LAO = 44,
-    AF_BLUE_STRINGSET_LATN = 50,
-    AF_BLUE_STRINGSET_LATB = 57,
-    AF_BLUE_STRINGSET_LATP = 64,
-    AF_BLUE_STRINGSET_MYMR = 71,
-    AF_BLUE_STRINGSET_TELU = 76,
-    AF_BLUE_STRINGSET_THAI = 79,
-    af_blue_2_1 = 87,
+    AF_BLUE_STRINGSET_GEOR = 21,
+    AF_BLUE_STRINGSET_GEOK = 26,
+    AF_BLUE_STRINGSET_GREK = 33,
+    AF_BLUE_STRINGSET_HEBR = 40,
+    AF_BLUE_STRINGSET_KNDA = 44,
+    AF_BLUE_STRINGSET_KHMR = 47,
+    AF_BLUE_STRINGSET_KHMS = 53,
+    AF_BLUE_STRINGSET_LAO = 56,
+    AF_BLUE_STRINGSET_LATN = 62,
+    AF_BLUE_STRINGSET_LATB = 69,
+    AF_BLUE_STRINGSET_LATP = 76,
+    AF_BLUE_STRINGSET_MLYM = 83,
+    AF_BLUE_STRINGSET_MYMR = 86,
+    AF_BLUE_STRINGSET_NONE = 91,
+    AF_BLUE_STRINGSET_SINH = 92,
+    AF_BLUE_STRINGSET_TAML = 96,
+    AF_BLUE_STRINGSET_TELU = 99,
+    AF_BLUE_STRINGSET_THAI = 102,
+    af_blue_2_1 = 110,
 #ifdef AF_CONFIG_OPTION_CJK
     AF_BLUE_STRINGSET_HANI = af_blue_2_1 + 0,
     af_blue_2_1_1 = af_blue_2_1 + 2,
diff --git src/autofit/afcjk.c src/autofit/afcjk.c
index 4ba5d22..427e4d8 100644
--- src/autofit/afcjk.c
+++ src/autofit/afcjk.c
@@ -1528,7 +1528,7 @@
       }
 
       if ( dist < 54 )
-        dist += ( 54 - dist ) / 2 ;
+        dist += ( 54 - dist ) / 2;
       else if ( dist < 3 * 64 )
       {
         FT_Pos  delta;
diff --git src/autofit/afhints.c src/autofit/afhints.c
index 9ed058f..6c3d032 100644
--- src/autofit/afhints.c
+++ src/autofit/afhints.c
@@ -314,7 +314,7 @@
     AF_DUMP(( "Table of points:\n" ));
 
     if ( hints->num_points )
-      AF_DUMP(( "  index  hedge  hseg  vedge  vseg  flags"
+      AF_DUMP(( "  index  hedge  hseg  vedge  vseg  flags "
                 "  xorg  yorg  xscale  yscale   xfit    yfit" ));
     else
       AF_DUMP(( "  (none)\n" ));
@@ -335,7 +335,7 @@
         contour++;
       }
 
-      AF_DUMP(( "  %5d  %5s %5s  %5s %5s  %s "
+      AF_DUMP(( "  %5d  %5s %5s  %5s %5s  %s"
                 " %5d %5d %7.2f %7.2f %7.2f %7.2f\n",
                 point_idx,
                 af_print_idx( buf1,
@@ -344,8 +344,11 @@
                 af_print_idx( buf3,
                               af_get_edge_index( hints, segment_idx_0, 0 ) ),
                 af_print_idx( buf4, segment_idx_0 ),
-                ( point->flags & AF_FLAG_WEAK_INTERPOLATION ) ? "weak"
-                                                              : " -- ",
+                ( point->flags & AF_FLAG_NEAR )
+                  ? " near "
+                  : ( point->flags & AF_FLAG_WEAK_INTERPOLATION )
+                    ? " weak "
+                    : "strong",
 
                 point->fx,
                 point->fy,
@@ -813,18 +816,26 @@
       AF_Point  point;
       AF_Point  point_limit = points + hints->num_points;
 
+      /* value 20 in `near_limit' is heuristic */
+      FT_UInt  units_per_em = hints->metrics->scaler.face->units_per_EM;
+      FT_Int   near_limit   = 20 * units_per_em / 2048;
+
 
       /* compute coordinates & Bezier flags, next and prev */
       {
         FT_Vector*  vec           = outline->points;
         char*       tag           = outline->tags;
-        AF_Point    end           = points + outline->contours[0];
+        FT_Short    endpoint      = outline->contours[0];
+        AF_Point    end           = points + endpoint;
         AF_Point    prev          = end;
         FT_Int      contour_index = 0;
 
 
         for ( point = points; point < point_limit; point++, vec++, tag++ )
         {
+          FT_Pos  out_x, out_y;
+
+
           point->in_dir  = (FT_Char)AF_DIR_NONE;
           point->out_dir = (FT_Char)AF_DIR_NONE;
 
@@ -833,6 +844,9 @@
           point->ox = point->x = FT_MulFix( vec->x, x_scale ) + x_delta;
           point->oy = point->y = FT_MulFix( vec->y, y_scale ) + y_delta;
 
+          end->fx = (FT_Short)outline->points[endpoint].x;
+          end->fy = (FT_Short)outline->points[endpoint].y;
+
           switch ( FT_CURVE_TAG( *tag ) )
           {
           case FT_CURVE_TAG_CONIC:
@@ -845,6 +859,12 @@
             point->flags = AF_FLAG_NONE;
           }
 
+          out_x = point->fx - prev->fx;
+          out_y = point->fy - prev->fy;
+
+          if ( FT_ABS( out_x ) + FT_ABS( out_y ) < near_limit )
+            prev->flags |= AF_FLAG_NEAR;
+
           point->prev = prev;
           prev->next  = point;
           prev        = point;
@@ -853,8 +873,9 @@
           {
             if ( ++contour_index < outline->n_contours )
             {
-              end  = points + outline->contours[contour_index];
-              prev = end;
+              endpoint = outline->contours[contour_index];
+              end      = points + endpoint;
+              prev     = end;
             }
           }
         }
@@ -880,17 +901,15 @@
          *  Compute directions of `in' and `out' vectors.
          *
          *  Note that distances between points that are very near to each
-         *  other are accumulated.  In other words, the auto-hinter
+         *  other are accumulated.  In other words, the auto-hinter either
          *  prepends the small vectors between near points to the first
-         *  non-near vector.  All intermediate points are tagged as
-         *  weak; the directions are adjusted also to be equal to the
-         *  accumulated one.
+         *  non-near vector, or the sum of small vector lengths exceeds a
+         *  threshold, thus `grouping' the small vectors.  All intermediate
+         *  points are tagged as weak; the directions are adjusted also to
+         *  be equal to the accumulated one.
          */
 
-        /* value 20 in `near_limit' is heuristic */
-        FT_UInt  units_per_em = hints->metrics->scaler.face->units_per_EM;
-        FT_Int   near_limit   = 20 * units_per_em / 2048;
-        FT_Int   near_limit2  = 2 * near_limit - 1;
+        FT_Int  near_limit2 = 2 * near_limit - 1;
 
         AF_Point*  contour;
         AF_Point*  contour_limit = hints->contours + hints->num_contours;
@@ -937,7 +956,7 @@
           /* now loop over all points of the contour to get */
           /* `in' and `out' vector directions               */
 
-          curr  = first;
+          curr = first;
 
           /*
            *  We abuse the `u' and `v' fields to store index deltas to the
@@ -960,7 +979,7 @@
 
 
             point = next;
-            next = point->next;
+            next  = point->next;
 
             out_x += next->fx - point->fx;
             out_y += next->fy - point->fy;
diff --git src/autofit/afhints.h src/autofit/afhints.h
index 4563565..faa5bdb 100644
--- src/autofit/afhints.h
+++ src/autofit/afhints.h
@@ -221,6 +221,9 @@ FT_BEGIN_HEADER
   /* candidates for weak interpolation have this flag set */
 #define AF_FLAG_WEAK_INTERPOLATION  ( 1U << 4 )
 
+  /* the distance to the next point is very small */
+#define AF_FLAG_NEAR  ( 1U << 5 )
+
 
   /* edge hint flags */
 #define AF_EDGE_NORMAL  0
diff --git src/autofit/aflatin.c src/autofit/aflatin.c
index 8a45116..f9b8507 100644
--- src/autofit/aflatin.c
+++ src/autofit/aflatin.c
@@ -1436,14 +1436,34 @@
     /* do each contour separately */
     for ( ; contour < contour_limit; contour++ )
     {
-      AF_Point  point      =  contour[0];
-      AF_Point  last       =  point->prev;
-      int       on_edge    =  0;
-      FT_Pos    min_pos    =  32000;  /* minimum segment pos != min_coord */
-      FT_Pos    max_pos    = -32000;  /* maximum segment pos != max_coord */
-      FT_Pos    min_on_pos =  32000;
-      FT_Pos    max_on_pos = -32000;
-      FT_Bool   passed;
+      AF_Point  point   = contour[0];
+      AF_Point  last    = point->prev;
+      int       on_edge = 0;
+
+      /* we call values measured along a segment (point->v)    */
+      /* `coordinates', and values orthogonal to it (point->u) */
+      /* `positions'                                           */
+      FT_Pos     min_pos      =  32000;
+      FT_Pos     max_pos      = -32000;
+      FT_Pos     min_coord    =  32000;
+      FT_Pos     max_coord    = -32000;
+      FT_UShort  min_flags    =  AF_FLAG_NONE;
+      FT_UShort  max_flags    =  AF_FLAG_NONE;
+      FT_Pos     min_on_coord =  32000;
+      FT_Pos     max_on_coord = -32000;
+
+      FT_Bool  passed;
+
+      AF_Segment  prev_segment = NULL;
+
+      FT_Pos     prev_min_pos      = min_pos;
+      FT_Pos     prev_max_pos      = max_pos;
+      FT_Pos     prev_min_coord    = min_coord;
+      FT_Pos     prev_max_coord    = max_coord;
+      FT_UShort  prev_min_flags    = min_flags;
+      FT_UShort  prev_max_flags    = max_flags;
+      FT_Pos     prev_min_on_coord = min_on_coord;
+      FT_Pos     prev_max_on_coord = max_on_coord;
 
 
       if ( point == last )  /* skip singletons -- just in case */
@@ -1478,51 +1498,181 @@
 
         if ( on_edge )
         {
+          /* get minimum and maximum position */
           u = point->u;
           if ( u < min_pos )
             min_pos = u;
           if ( u > max_pos )
             max_pos = u;
 
-          /* get minimum and maximum coordinate of on points */
+          /* get minimum and maximum coordinate together with flags */
+          v = point->v;
+          if ( v < min_coord )
+          {
+            min_coord = v;
+            min_flags = point->flags;
+          }
+          if ( v > max_coord )
+          {
+            max_coord = v;
+            max_flags = point->flags;
+          }
+
+          /* get minimum and maximum coordinate of `on' points */
           if ( !( point->flags & AF_FLAG_CONTROL ) )
           {
             v = point->v;
-            if ( v < min_on_pos )
-              min_on_pos = v;
-            if ( v > max_on_pos )
-              max_on_pos = v;
+            if ( v < min_on_coord )
+              min_on_coord = v;
+            if ( v > max_on_coord )
+              max_on_coord = v;
           }
 
           if ( point->out_dir != segment_dir || point == last )
           {
-            /* we are just leaving an edge; record a new segment! */
-            segment->last = point;
-            segment->pos  = (FT_Short)( ( min_pos + max_pos ) >> 1 );
-
-            /* a segment is round if either its first or last point */
-            /* is a control point, and the length of the on points  */
-            /* inbetween doesn't exceed a heuristic limit           */
-            if ( ( segment->first->flags | point->flags ) & AF_FLAG_CONTROL &&
-                 ( max_on_pos - min_on_pos ) < flat_threshold               )
-              segment->flags |= AF_EDGE_ROUND;
-
-            /* compute segment size */
-            min_pos = max_pos = point->v;
-
-            v = segment->first->v;
-            if ( v < min_pos )
-              min_pos = v;
-            if ( v > max_pos )
-              max_pos = v;
-
-            segment->min_coord = (FT_Short)min_pos;
-            segment->max_coord = (FT_Short)max_pos;
-            segment->height    = (FT_Short)( segment->max_coord -
-                                             segment->min_coord );
+            /* check whether the new segment's start point is identical to */
+            /* the previous segment's end point; for example, this might   */
+            /* happen for spikes                                           */
+
+            if ( !prev_segment || segment->first != prev_segment->last )
+            {
+              /* points are different: we are just leaving an edge, thus */
+              /* record a new segment                                    */
+
+              segment->last = point;
+              segment->pos  = (FT_Short)( ( min_pos + max_pos ) >> 1 );
+
+              /* a segment is round if either its first or last point */
+              /* is a control point, and the length of the on points  */
+              /* inbetween doesn't exceed a heuristic limit           */
+              if ( ( min_flags | max_flags ) & AF_FLAG_CONTROL      &&
+                   ( max_on_coord - min_on_coord ) < flat_threshold )
+                segment->flags |= AF_EDGE_ROUND;
+
+              segment->min_coord = (FT_Short)min_coord;
+              segment->max_coord = (FT_Short)max_coord;
+              segment->height    = segment->max_coord - segment->min_coord;
+
+              prev_segment      = segment;
+              prev_min_pos      = min_pos;
+              prev_max_pos      = max_pos;
+              prev_min_coord    = min_coord;
+              prev_max_coord    = max_coord;
+              prev_min_flags    = min_flags;
+              prev_max_flags    = max_flags;
+              prev_min_on_coord = min_on_coord;
+              prev_max_on_coord = max_on_coord;
+            }
+            else
+            {
+              /* points are the same: we don't create a new segment but */
+              /* merge the current segment with the previous one        */
+
+              if ( prev_segment->last->in_dir == point->in_dir )
+              {
+                /* we have identical directions (this can happen for       */
+                /* degenerate outlines that move zig-zag along the main    */
+                /* axis without changing the coordinate value of the other */
+                /* axis, and where the segments have just been merged):    */
+                /* unify segments                                          */
+
+                /* update constraints */
+
+                if ( prev_min_pos < min_pos )
+                  min_pos = prev_min_pos;
+                if ( prev_max_pos > max_pos )
+                  max_pos = prev_max_pos;
+
+                if ( prev_min_coord < min_coord )
+                {
+                  min_coord = prev_min_coord;
+                  min_flags = prev_min_flags;
+                }
+                if ( prev_max_coord > max_coord )
+                {
+                  max_coord = prev_max_coord;
+                  max_flags = prev_max_flags;
+                }
+
+                if ( prev_min_on_coord < min_on_coord )
+                  min_on_coord = prev_min_on_coord;
+                if ( prev_max_on_coord > max_on_coord )
+                  max_on_coord = prev_max_on_coord;
+
+                prev_segment->last = point;
+                prev_segment->pos  = (FT_Short)( ( min_pos +
+                                                   max_pos ) >> 1 );
+
+                if ( ( min_flags | max_flags ) & AF_FLAG_CONTROL      &&
+                     ( max_on_coord - min_on_coord ) < flat_threshold )
+                  prev_segment->flags |= AF_EDGE_ROUND;
+                else
+                  prev_segment->flags &= ~AF_EDGE_ROUND;
+
+                prev_segment->min_coord = (FT_Short)min_coord;
+                prev_segment->max_coord = (FT_Short)max_coord;
+                prev_segment->height    = prev_segment->max_coord -
+                                          prev_segment->min_coord;
+              }
+              else
+              {
+                /* we have different directions; use the properties of the */
+                /* longer segment and discard the other one                */
+
+                if ( FT_ABS( prev_max_coord - prev_min_coord ) >
+                     FT_ABS( max_coord - min_coord ) )
+                {
+                  /* discard current segment */
+
+                  if ( min_pos < prev_min_pos )
+                    prev_min_pos = min_pos;
+                  if ( max_pos > prev_max_pos )
+                    prev_max_pos = max_pos;
+
+                  prev_segment->last = point;
+                  prev_segment->pos  = (FT_Short)( ( prev_min_pos +
+                                                     prev_max_pos ) >> 1 );
+                }
+                else
+                {
+                  /* discard previous segment */
+
+                  if ( prev_min_pos < min_pos )
+                    min_pos = prev_min_pos;
+                  if ( prev_max_pos > max_pos )
+                    max_pos = prev_max_pos;
+
+                  segment->last = point;
+                  segment->pos  = (FT_Short)( ( min_pos + max_pos ) >> 1 );
+
+                  if ( ( min_flags | max_flags ) & AF_FLAG_CONTROL      &&
+                       ( max_on_coord - min_on_coord ) < flat_threshold )
+                    segment->flags |= AF_EDGE_ROUND;
+
+                  segment->min_coord = (FT_Short)min_coord;
+                  segment->max_coord = (FT_Short)max_coord;
+                  segment->height    = segment->max_coord -
+                                       segment->min_coord;
+
+                  *prev_segment = *segment;
+
+                  prev_min_pos      = min_pos;
+                  prev_max_pos      = max_pos;
+                  prev_min_coord    = min_coord;
+                  prev_max_coord    = max_coord;
+                  prev_min_flags    = min_flags;
+                  prev_max_flags    = max_flags;
+                  prev_min_on_coord = min_on_coord;
+                  prev_max_on_coord = max_on_coord;
+                }
+              }
+
+              axis->num_segments--;
+            }
 
             on_edge = 0;
             segment = NULL;
+
             /* fall through */
           }
         }
@@ -1551,15 +1701,22 @@
           segment->first = point;
           segment->last  = point;
 
-          min_pos = max_pos = point->u;
+          /* `af_axis_hints_new_segment' reallocates memory,    */
+          /* thus we have to refresh the `prev_segment' pointer */
+          if ( prev_segment )
+            prev_segment = segment - 1;
+
+          min_pos   = max_pos   = point->u;
+          min_coord = max_coord = point->v;
+          min_flags = max_flags = point->flags;
 
           if ( point->flags & AF_FLAG_CONTROL )
           {
-            min_on_pos =  32000;
-            max_on_pos = -32000;
+            min_on_coord =  32000;
+            max_on_coord = -32000;
           }
           else
-            min_on_pos = max_on_pos = point->v;
+            min_on_coord = max_on_coord = point->v;
 
           on_edge = 1;
         }
@@ -2347,6 +2504,7 @@
   af_latin_compute_stem_width( AF_GlyphHints  hints,
                                AF_Dimension   dim,
                                FT_Pos         width,
+                               FT_Pos         base_delta,
                                FT_UInt        base_flags,
                                FT_UInt        stem_flags )
   {
@@ -2424,7 +2582,39 @@
             dist += delta;
         }
         else
-          dist = ( dist + 32 ) & ~63;
+        {
+          /* A stem's end position depends on two values: the start        */
+          /* position and the stem length.  The former gets usually        */
+          /* rounded to the grid, while the latter gets rounded also if it */
+          /* exceeds a certain length (see below in this function).  This  */
+          /* `double rounding' can lead to a great difference to the       */
+          /* original, unhinted position; this normally doesn't matter for */
+          /* large PPEM values, but for small sizes it can easily make     */
+          /* outlines collide.  For this reason, we adjust the stem length */
+          /* by a small amount depending on the PPEM value in case the     */
+          /* former and latter rounding both point into the same           */
+          /* direction.                                                    */
+
+          FT_Pos  bdelta = 0;
+
+
+          if ( ( ( width > 0 ) && ( base_delta > 0 ) ) ||
+               ( ( width < 0 ) && ( base_delta < 0 ) ) )
+          {
+            FT_UInt  ppem = metrics->root.scaler.face->size->metrics.x_ppem;
+
+
+            if ( ppem < 10 )
+              bdelta = base_delta;
+            else if ( ppem < 30 )
+              bdelta = ( base_delta * (FT_Pos)( 30 - ppem ) ) / 20;
+
+            if ( bdelta < 0 )
+              bdelta = -bdelta;
+          }
+
+          dist = ( dist - bdelta + 32 ) & ~63;
+        }
       }
     }
     else
@@ -2513,11 +2703,17 @@
                               AF_Edge        base_edge,
                               AF_Edge        stem_edge )
   {
-    FT_Pos  dist = stem_edge->opos - base_edge->opos;
+    FT_Pos  dist, base_delta;
+    FT_Pos  fitted_width;
 
-    FT_Pos  fitted_width = af_latin_compute_stem_width( hints, dim, dist,
-                                                        base_edge->flags,
-                                                        stem_edge->flags );
+
+    dist       = stem_edge->opos - base_edge->opos;
+    base_delta = base_edge->pos - base_edge->opos;
+
+    fitted_width = af_latin_compute_stem_width( hints, dim,
+                                                dist, base_delta,
+                                                base_edge->flags,
+                                                stem_edge->flags );
 
 
     stem_edge->pos = base_edge->pos + fitted_width;
@@ -2721,7 +2917,8 @@
 
 
         org_len = edge2->opos - edge->opos;
-        cur_len = af_latin_compute_stem_width( hints, dim, org_len,
+        cur_len = af_latin_compute_stem_width( hints, dim,
+                                               org_len, 0,
                                                edge->flags,
                                                edge2->flags );
 
@@ -2790,7 +2987,8 @@
         org_len    = edge2->opos - edge->opos;
         org_center = org_pos + ( org_len >> 1 );
 
-        cur_len = af_latin_compute_stem_width( hints, dim, org_len,
+        cur_len = af_latin_compute_stem_width( hints, dim,
+                                               org_len, 0,
                                                edge->flags,
                                                edge2->flags );
 
@@ -2850,7 +3048,8 @@
           org_len    = edge2->opos - edge->opos;
           org_center = org_pos + ( org_len >> 1 );
 
-          cur_len    = af_latin_compute_stem_width( hints, dim, org_len,
+          cur_len    = af_latin_compute_stem_width( hints, dim,
+                                                    org_len, 0,
                                                     edge->flags,
                                                     edge2->flags );
 
@@ -2885,14 +3084,21 @@
              ( top_to_bottom_hinting ? ( edge->pos > edge[-1].pos )
                                      : ( edge->pos < edge[-1].pos ) ) )
         {
+          /* don't move if stem would (almost) disappear otherwise; */
+          /* the ad-hoc value 16 corresponds to 1/4px               */
+          if ( edge->link && FT_ABS( edge->link->pos - edge[-1].pos ) > 16 )
+          {
 #ifdef FT_DEBUG_LEVEL_TRACE
-          FT_TRACE5(( "  BOUND: edge %d (pos=%.2f) moved to %.2f\n",
-                      edge - edges, edge->pos / 64.0, edge[-1].pos / 64.0 ));
+            FT_TRACE5(( "  BOUND: edge %d (pos=%.2f) moved to %.2f\n",
+                        edge - edges,
+                        edge->pos / 64.0,
+                        edge[-1].pos / 64.0 ));
 
-          num_actions++;
+            num_actions++;
 #endif
 
-          edge->pos = edge[-1].pos;
+            edge->pos = edge[-1].pos;
+          }
         }
       }
     }
@@ -3048,13 +3254,20 @@
              ( top_to_bottom_hinting ? ( edge->pos > edge[-1].pos )
                                      : ( edge->pos < edge[-1].pos ) ) )
         {
+          /* don't move if stem would (almost) disappear otherwise; */
+          /* the ad-hoc value 16 corresponds to 1/4px               */
+          if ( edge->link && FT_ABS( edge->link->pos - edge[-1].pos ) > 16 )
+          {
 #ifdef FT_DEBUG_LEVEL_TRACE
-          FT_TRACE5(( "  BOUND: edge %d (pos=%.2f) moved to %.2f\n",
-                      edge - edges, edge->pos / 64.0, edge[-1].pos / 64.0 ));
+            FT_TRACE5(( "  BOUND: edge %d (pos=%.2f) moved to %.2f\n",
+                        edge - edges,
+                        edge->pos / 64.0,
+                        edge[-1].pos / 64.0 ));
 
-          num_actions++;
+            num_actions++;
 #endif
-          edge->pos = edge[-1].pos;
+            edge->pos = edge[-1].pos;
+          }
         }
 
         if ( edge + 1 < edge_limit                                   &&
@@ -3062,14 +3275,21 @@
              ( top_to_bottom_hinting ? ( edge->pos < edge[1].pos )
                                      : ( edge->pos > edge[1].pos ) ) )
         {
+          /* don't move if stem would (almost) disappear otherwise; */
+          /* the ad-hoc value 16 corresponds to 1/4px               */
+          if ( edge->link && FT_ABS( edge->link->pos - edge[-1].pos ) > 16 )
+          {
 #ifdef FT_DEBUG_LEVEL_TRACE
-          FT_TRACE5(( "  BOUND: edge %d (pos=%.2f) moved to %.2f\n",
-                      edge - edges, edge->pos / 64.0, edge[1].pos / 64.0 ));
+            FT_TRACE5(( "  BOUND: edge %d (pos=%.2f) moved to %.2f\n",
+                        edge - edges,
+                        edge->pos / 64.0,
+                        edge[1].pos / 64.0 ));
 
-          num_actions++;
+            num_actions++;
 #endif
 
-          edge->pos = edge[1].pos;
+            edge->pos = edge[1].pos;
+          }
         }
       }
     }
diff --git src/autofit/aflatin2.c src/autofit/aflatin2.c
index 1fab85e..5db4a41 100644
--- src/autofit/aflatin2.c
+++ src/autofit/aflatin2.c
@@ -1,3 +1,8 @@
+/* ATTENTION: This file doesn't compile.  It is only here as a reference */
+/*            of an alternative latin hinting algorithm that was always  */
+/*            marked as experimental.                                    */
+
+
 /***************************************************************************/
 /*                                                                         */
 /*  aflatin2.c                                                             */
diff --git src/autofit/aflatin2.h src/autofit/aflatin2.h
index c17a6a2..f83f704 100644
--- src/autofit/aflatin2.h
+++ src/autofit/aflatin2.h
@@ -1,3 +1,8 @@
+/* ATTENTION: This file doesn't compile.  It is only here as a reference */
+/*            of an alternative latin hinting algorithm that was always  */
+/*            marked as experimental.                                    */
+
+
 /***************************************************************************/
 /*                                                                         */
 /*  aflatin2.h                                                             */
diff --git src/autofit/afranges.c src/autofit/afranges.c
index 4e81e78..e22cb34 100644
--- src/autofit/afranges.c
+++ src/autofit/afranges.c
@@ -158,6 +158,36 @@
   };
 
 
+  const AF_Script_UniRangeRec  af_geor_uniranges[] =
+  {
+    AF_UNIRANGE_REC(  0x10D0UL,  0x10FFUL ),  /* Georgian (Mkhedruli) */
+#if 0
+    /* the following range is proposed for inclusion in Unicode */
+    AF_UNIRANGE_REC(  0x1C90UL,  0x1CBFUL ),  /* Georgian (Mtavruli)  */
+#endif
+    AF_UNIRANGE_REC(       0UL,       0UL )
+  };
+
+  const AF_Script_UniRangeRec  af_geor_nonbase_uniranges[] =
+  {
+    AF_UNIRANGE_REC( 0UL, 0UL )
+  };
+
+
+  const AF_Script_UniRangeRec  af_geok_uniranges[] =
+  {
+    /* Khutsuri */
+    AF_UNIRANGE_REC(  0x10A0UL,  0x10CDUL ),  /* Georgian (Asomtavruli) */
+    AF_UNIRANGE_REC(  0x2D00UL,  0x2D2DUL ),  /* Georgian (Nuskhuri)    */
+    AF_UNIRANGE_REC(       0UL,       0UL )
+  };
+
+  const AF_Script_UniRangeRec  af_geok_nonbase_uniranges[] =
+  {
+    AF_UNIRANGE_REC( 0UL, 0UL )
+  };
+
+
   const AF_Script_UniRangeRec  af_grek_uniranges[] =
   {
     AF_UNIRANGE_REC(  0x0370UL,  0x03FFUL ),  /* Greek and Coptic */
@@ -354,6 +384,21 @@
   };
 
 
+  const AF_Script_UniRangeRec  af_mlym_uniranges[] =
+  {
+    AF_UNIRANGE_REC(  0x0D00UL,  0x0D7FUL ),  /* Malayalam */
+    AF_UNIRANGE_REC(       0UL,       0UL )
+  };
+
+  const AF_Script_UniRangeRec  af_mlym_nonbase_uniranges[] =
+  {
+    AF_UNIRANGE_REC(  0x0D01UL,  0x0D01UL ),
+    AF_UNIRANGE_REC(  0x0D4DUL,  0x0D4EUL ),
+    AF_UNIRANGE_REC(  0x0D62UL,  0x0D63UL ),
+    AF_UNIRANGE_REC(       0UL,       0UL )
+  };
+
+
   const AF_Script_UniRangeRec  af_mymr_uniranges[] =
   {
     AF_UNIRANGE_REC( 0x1000UL, 0x109FUL ),    /* Myanmar            */
@@ -391,6 +436,35 @@
   };
 
 
+  const AF_Script_UniRangeRec  af_sinh_uniranges[] =
+  {
+    AF_UNIRANGE_REC(  0x0D80UL,  0x0DFFUL ),  /* Sinhala */
+    AF_UNIRANGE_REC(       0UL,       0UL )
+  };
+
+  const AF_Script_UniRangeRec  af_sinh_nonbase_uniranges[] =
+  {
+    AF_UNIRANGE_REC(  0x0DCAUL,  0x0DCAUL ),
+    AF_UNIRANGE_REC(  0x0DD2UL,  0x0DD6UL ),
+    AF_UNIRANGE_REC(       0UL,       0UL )
+  };
+
+
+  const AF_Script_UniRangeRec  af_taml_uniranges[] =
+  {
+    AF_UNIRANGE_REC(  0x0B80UL,  0x0BFFUL ),  /* Tamil */
+    AF_UNIRANGE_REC(       0UL,       0UL )
+  };
+
+  const AF_Script_UniRangeRec  af_taml_nonbase_uniranges[] =
+  {
+    AF_UNIRANGE_REC(  0x0B82UL,  0x0B82UL ),
+    AF_UNIRANGE_REC(  0x0BC0UL,  0x0BC2UL ),
+    AF_UNIRANGE_REC(  0x0BCDUL,  0x0BCDUL ),
+    AF_UNIRANGE_REC(       0UL,       0UL )
+  };
+
+
   const AF_Script_UniRangeRec  af_telu_uniranges[] =
   {
     AF_UNIRANGE_REC(  0x0C00UL,  0x0C7FUL ),  /* Telugu */
@@ -473,21 +547,6 @@
   };
 
 
-  const AF_Script_UniRangeRec  af_mlym_uniranges[] =
-  {
-    AF_UNIRANGE_REC(  0x0D00UL,  0x0D7FUL ),  /* Malayalam */
-    AF_UNIRANGE_REC(       0UL,       0UL )
-  };
-
-  const AF_Script_UniRangeRec  af_mlym_nonbase_uniranges[] =
-  {
-    AF_UNIRANGE_REC(  0x0D01UL,  0x0D01UL ),
-    AF_UNIRANGE_REC(  0x0D4DUL,  0x0D4EUL ),
-    AF_UNIRANGE_REC(  0x0D62UL,  0x0D63UL ),
-    AF_UNIRANGE_REC(       0UL,       0UL )
-  };
-
-
   const AF_Script_UniRangeRec  af_orya_uniranges[] =
   {
     AF_UNIRANGE_REC(  0x0B00UL,  0x0B7FUL ),  /* Oriya */
@@ -506,20 +565,6 @@
   };
 
 
-  const AF_Script_UniRangeRec  af_sinh_uniranges[] =
-  {
-    AF_UNIRANGE_REC(  0x0D80UL,  0x0DFFUL ),  /* Sinhala */
-    AF_UNIRANGE_REC(       0UL,       0UL )
-  };
-
-  const AF_Script_UniRangeRec  af_sinh_nonbase_uniranges[] =
-  {
-    AF_UNIRANGE_REC(  0x0DCAUL,  0x0DCAUL ),
-    AF_UNIRANGE_REC(  0x0DD2UL,  0x0DD6UL ),
-    AF_UNIRANGE_REC(       0UL,       0UL )
-  };
-
-
   const AF_Script_UniRangeRec  af_sund_uniranges[] =
   {
     AF_UNIRANGE_REC(  0x1B80UL,  0x1BBFUL ),  /* Sundanese            */
@@ -551,21 +596,6 @@
   };
 
 
-  const AF_Script_UniRangeRec  af_taml_uniranges[] =
-  {
-    AF_UNIRANGE_REC(  0x0B80UL,  0x0BFFUL ),  /* Tamil */
-    AF_UNIRANGE_REC(       0UL,       0UL )
-  };
-
-  const AF_Script_UniRangeRec  af_taml_nonbase_uniranges[] =
-  {
-    AF_UNIRANGE_REC(  0x0B82UL,  0x0B82UL ),
-    AF_UNIRANGE_REC(  0x0BC0UL,  0x0BC2UL ),
-    AF_UNIRANGE_REC(  0x0BCDUL,  0x0BCDUL ),
-    AF_UNIRANGE_REC(       0UL,       0UL )
-  };
-
-
   const AF_Script_UniRangeRec  af_tibt_uniranges[] =
   {
     AF_UNIRANGE_REC(  0x0F00UL,  0x0FFFUL ),  /* Tibetan */
diff --git src/autofit/afscript.h src/autofit/afscript.h
index 9bbb6f3..e19cfcd 100644
--- src/autofit/afscript.h
+++ src/autofit/afscript.h
@@ -55,6 +55,18 @@
           HINTING_TOP_TO_BOTTOM,
           "\xE0\xA4\xA0 \xE0\xA4\xB5 \xE0\xA4\x9F" ) /* ठ व ट */
 
+  SCRIPT( geor, GEOR,
+          "Georgian (Mkhedruli)",
+          HB_SCRIPT_GEORGIAN,
+          HINTING_BOTTOM_TO_TOP,
+          "\xE1\x83\x98 \xE1\x83\x94 \xE1\x83\x90" ) /* ი ე ა */
+
+  SCRIPT( geok, GEOK,
+          "Georgian (Khutsuri)",
+          HB_SCRIPT_INVALID,
+          HINTING_BOTTOM_TO_TOP,
+          "\xE1\x82\xB6 \xE1\x82\xB1 \xE2\xB4\x99" ) /* Ⴖ Ⴑ ⴙ */
+
   SCRIPT( grek, GREK,
           "Greek",
           HB_SCRIPT_GREEK,
@@ -111,6 +123,12 @@
           HINTING_BOTTOM_TO_TOP,
           "\xE1\xB5\x92 \xE1\xB4\xBC \xE2\x81\xB0" ) /* ᵒ ᴼ ⁰ */
 
+  SCRIPT( mlym, MLYM,
+          "Malayalam",
+          HB_SCRIPT_MALAYALAM,
+          HINTING_BOTTOM_TO_TOP,
+          "\xE0\xB4\xA0 \xE0\xB4\xB1" ) /* ഠ റ */
+
   SCRIPT( mymr, MYMR,
           "Myanmar",
           HB_SCRIPT_MYANMAR,
@@ -123,6 +141,19 @@
           HINTING_BOTTOM_TO_TOP,
           "" )
 
+  SCRIPT( sinh, SINH,
+          "Sinhala",
+          HB_SCRIPT_SINHALA,
+          HINTING_BOTTOM_TO_TOP,
+          "\xE0\xB6\xA7" ) /* ට */
+
+  /* only digit zero has a simple (round) shape in the Tamil script */
+  SCRIPT( taml, TAML,
+          "Tamil",
+          HB_SCRIPT_TAMIL,
+          HINTING_BOTTOM_TO_TOP,
+          "\xE0\xAF\xA6" ) /* ௦ */
+
   /* there are no simple forms for letters; we thus use two digit shapes */
   SCRIPT( telu, TELU,
           "Telugu",
@@ -156,24 +187,12 @@
           HINTING_BOTTOM_TO_TOP,
           "o" ) /* XXX */
 
-  SCRIPT( mlym, MLYM,
-          "Malayalam",
-          HB_SCRIPT_MALAYALAM,
-          HINTING_BOTTOM_TO_TOP,
-          "o" ) /* XXX */
-
   SCRIPT( orya, ORYA,
           "Oriya",
           HB_SCRIPT_ORIYA,
           HINTING_BOTTOM_TO_TOP,
           "o" ) /* XXX */
 
-  SCRIPT( sinh, SINH,
-          "Sinhala",
-          HB_SCRIPT_SINHALA,
-          HINTING_BOTTOM_TO_TOP,
-          "o" ) /* XXX */
-
   SCRIPT( sund, SUND,
           "Sundanese",
           HB_SCRIPT_SUNDANESE,
@@ -186,12 +205,6 @@
           HINTING_BOTTOM_TO_TOP,
           "o" ) /* XXX */
 
-  SCRIPT( taml, TAML,
-          "Tamil",
-          HB_SCRIPT_TAMIL,
-          HINTING_BOTTOM_TO_TOP,
-          "o" ) /* XXX */
-
   SCRIPT( tibt, TIBT,
           "Tibetan",
           HB_SCRIPT_TIBETAN,
diff --git src/autofit/afstyles.h src/autofit/afstyles.h
index 9c57258..f85fe87 100644
--- src/autofit/afstyles.h
+++ src/autofit/afstyles.h
@@ -52,10 +52,10 @@
 #undef  META_STYLE_LATIN
 #define META_STYLE_LATIN( s, S, ds )                     \
           STYLE_LATIN( s, S, c2cp, C2CP, ds,             \
-                       "petite capticals from capitals", \
+                       "petite capitals from capitals", \
                        PETITE_CAPITALS_FROM_CAPITALS )   \
           STYLE_LATIN( s, S, c2sc, C2SC, ds,             \
-                       "small capticals from capitals",  \
+                       "small capitals from capitals",  \
                        SMALL_CAPITALS_FROM_CAPITALS )    \
           STYLE_LATIN( s, S, ordn, ORDN, ds,             \
                        "ordinals",                       \
@@ -106,6 +106,20 @@
          AF_BLUE_STRINGSET_DEVA,
          AF_COVERAGE_DEFAULT )
 
+  STYLE( geor_dflt, GEOR_DFLT,
+         "Georgian (Mkhedruli) default style",
+         AF_WRITING_SYSTEM_LATIN,
+         AF_SCRIPT_GEOR,
+         AF_BLUE_STRINGSET_GEOR,
+         AF_COVERAGE_DEFAULT )
+
+  STYLE( geok_dflt, GEOK_DFLT,
+         "Georgian (Khutsuri) default style",
+         AF_WRITING_SYSTEM_LATIN,
+         AF_SCRIPT_GEOK,
+         AF_BLUE_STRINGSET_GEOK,
+         AF_COVERAGE_DEFAULT )
+
   META_STYLE_LATIN( grek, GREK, "Greek" )
 
   STYLE( hebr_dflt, HEBR_DFLT,
@@ -168,6 +182,13 @@
          AF_COVERAGE_DEFAULT )
 #endif
 
+  STYLE( mlym_dflt, MLYM_DFLT,
+         "Malayalam default style",
+         AF_WRITING_SYSTEM_LATIN,
+         AF_SCRIPT_MLYM,
+         AF_BLUE_STRINGSET_MLYM,
+         AF_COVERAGE_DEFAULT )
+
   STYLE( mymr_dflt, MYMR_DFLT,
          "Myanmar default style",
          AF_WRITING_SYSTEM_LATIN,
@@ -179,7 +200,21 @@
          "no style",
          AF_WRITING_SYSTEM_DUMMY,
          AF_SCRIPT_NONE,
-         (AF_Blue_Stringset)0,
+         AF_BLUE_STRINGSET_NONE,
+         AF_COVERAGE_DEFAULT )
+
+  STYLE( sinh_dflt, SINH_DFLT,
+         "Sinhala default style",
+         AF_WRITING_SYSTEM_LATIN,
+         AF_SCRIPT_SINH,
+         AF_BLUE_STRINGSET_SINH,
+         AF_COVERAGE_DEFAULT )
+
+  STYLE( taml_dflt, TAML_DFLT,
+         "Tamil default style",
+         AF_WRITING_SYSTEM_LATIN,
+         AF_SCRIPT_TAML,
+         AF_BLUE_STRINGSET_TAML,
          AF_COVERAGE_DEFAULT )
 
   STYLE( telu_dflt, TELU_DFLT,
@@ -211,12 +246,9 @@
   STYLE_DEFAULT_INDIC( gujr, GUJR, "Gujarati" )
   STYLE_DEFAULT_INDIC( guru, GURU, "Gurmukhi" )
   STYLE_DEFAULT_INDIC( limb, LIMB, "Limbu" )
-  STYLE_DEFAULT_INDIC( mlym, MLYM, "Malayalam" )
   STYLE_DEFAULT_INDIC( orya, ORYA, "Oriya" )
-  STYLE_DEFAULT_INDIC( sinh, SINH, "Sinhala" )
   STYLE_DEFAULT_INDIC( sund, SUND, "Sundanese" )
   STYLE_DEFAULT_INDIC( sylo, SYLO, "Syloti Nagri" )
-  STYLE_DEFAULT_INDIC( taml, TAML, "Tamil" )
   STYLE_DEFAULT_INDIC( tibt, TIBT, "Tibetan" )
 
 #endif /* AF_CONFIG_OPTION_INDIC */
diff --git src/autofit/aftypes.h src/autofit/aftypes.h
index eae6e11..ef62043 100644
--- src/autofit/aftypes.h
+++ src/autofit/aftypes.h
@@ -22,7 +22,7 @@
    *  Its main feature is the ability to differentiate between different
    *  writing systems and scripts in order to apply specific rules.
    *
-   *  The code has also been compartmentized into several entities that
+   *  The code has also been compartmentalized into several entities that
    *  should make algorithmic experimentation easier than with the old
    *  code.
    *
diff --git src/base/ftadvanc.c src/base/ftadvanc.c
index 2bfbe8a..9e2ab89 100644
--- src/base/ftadvanc.c
+++ src/base/ftadvanc.c
@@ -159,8 +159,8 @@
 
       /* scale from 26.6 to 16.16 */
       padvances[nn] = ( flags & FT_LOAD_VERTICAL_LAYOUT )
-                      ? face->glyph->advance.y << 10
-                      : face->glyph->advance.x << 10;
+                      ? face->glyph->advance.y * 1024
+                      : face->glyph->advance.x * 1024;
     }
 
     return error;
diff --git src/base/ftbitmap.c src/base/ftbitmap.c
index 8cc3a17..24fead3 100644
--- src/base/ftbitmap.c
+++ src/base/ftbitmap.c
@@ -351,7 +351,7 @@
     }
 
     /* for each row */
-    for ( y = 0; y < bitmap->rows ; y++ )
+    for ( y = 0; y < bitmap->rows; y++ )
     {
       /*
        * Horizontally:
diff --git src/base/fthash.c src/base/fthash.c
index 779f795..21bc8dd 100644
--- src/base/fthash.c
+++ src/base/fthash.c
@@ -41,6 +41,7 @@
 
 #include <ft2build.h>
 #include FT_INTERNAL_HASH_H
+#include FT_INTERNAL_MEMORY_H
 
 
 #define INITIAL_HT_SIZE  241
diff --git src/base/ftmac.c src/base/ftmac.c
index 5cfa012..e97fdbf 100644
--- src/base/ftmac.c
+++ src/base/ftmac.c
@@ -228,7 +228,7 @@
 
 
     if ( !fontName || !face_index )
-      return FT_THROW( Invalid_Argument) ;
+      return FT_THROW( Invalid_Argument);
 
     err = FT_GetFileRef_From_Mac_ATS_Name( fontName, &ref, face_index );
     if ( err )
diff --git src/base/ftobjs.c src/base/ftobjs.c
index fa05347..af38d04 100644
--- src/base/ftobjs.c
+++ src/base/ftobjs.c
@@ -1418,7 +1418,7 @@
 
   /* Type 1 and CID-keyed font drivers should recognize sfnt-wrapped */
   /* format too.  Here, since we can't expect that the TrueType font */
-  /* driver is loaded unconditially, we must parse the font by       */
+  /* driver is loaded unconditionally, we must parse the font by     */
   /* ourselves.  We are only interested in the name of the table and */
   /* the offset.                                                     */
 
diff --git src/base/ftrfork.c src/base/ftrfork.c
index 4d3de46..4660c97 100644
--- src/base/ftrfork.c
+++ src/base/ftrfork.c
@@ -403,7 +403,7 @@
         errors[i] = FT_Err_Ok;
 
       if ( errors[i] )
-        continue ;
+        continue;
 
       errors[i] = (FT_RACCESS_GUESS_TABLE_GET[i].func)( library,
                                                  stream, base_name,
diff --git src/base/ftstream.c src/base/ftstream.c
index 8b5bad8..bb512a7 100644
--- src/base/ftstream.c
+++ src/base/ftstream.c
@@ -778,7 +778,7 @@
 
       case ft_frame_short_be:
       case ft_frame_ushort_be:  /* read a 2-byte big-endian short */
-        value = FT_NEXT_USHORT( cursor) ;
+        value = FT_NEXT_USHORT( cursor );
         sign_shift = 16;
         break;
 
diff --git src/cache/ftcmru.h src/cache/ftcmru.h
index ea78a32..ae3c4ce 100644
--- src/cache/ftcmru.h
+++ src/cache/ftcmru.h
@@ -185,7 +185,7 @@ FT_BEGIN_HEADER
         }                                                                   \
         _node = _node->next;                                                \
                                                                             \
-      } while ( _node != _first) ;                                          \
+      } while ( _node != _first);                                           \
     }                                                                       \
                                                                             \
     error = FTC_MruList_New( (list), (key), (FTC_MruNode*)(void*)&(node) ); \
diff --git src/cff/cf2error.h src/cff/cf2error.h
index d9f8c66..512edd1 100644
--- src/cff/cf2error.h
+++ src/cff/cf2error.h
@@ -70,7 +70,7 @@ FT_BEGIN_HEADER
    * Upon a function call if the error code is anything other than
    * `FT_Err_Ok', which is guaranteed to be zero, we
    * will return without altering that error.  This will allow the
-   * error to propogate and be handled at the appropriate location in
+   * error to propagate and be handled at the appropriate location in
    * the code.
    *
    * This allows a style of code where the error code is initialized
diff --git src/cff/cf2hints.h src/cff/cf2hints.h
index 290f570..a898454 100644
--- src/cff/cf2hints.h
+++ src/cff/cf2hints.h
@@ -220,7 +220,7 @@ FT_BEGIN_HEADER
 
     /* character space miter limit threshold */
     CF2_Fixed  miterLimit;
-    /* vertical/horzizontal snap distance in character space */
+    /* vertical/horizontal snap distance in character space */
     CF2_Fixed  snapThreshold;
 
     FT_Vector  offsetStart0;  /* first and second points of first */
diff --git src/cff/cffgload.c src/cff/cffgload.c
index df57d67..752c18e 100644
--- src/cff/cffgload.c
+++ src/cff/cffgload.c
@@ -680,7 +680,7 @@
 #endif /* FT_CONFIG_OPTION_INCREMENTAL */
 
     {
-      CFF_Font  cff  = (CFF_Font)(face->extra.data);
+      CFF_Font  cff = (CFF_Font)(face->extra.data);
 
 
       return cff_index_access_element( &cff->charstrings_index, glyph_index,
@@ -826,7 +826,7 @@
       /* the seac operator must not be nested */
       decoder->seac = TRUE;
       error = cff_decoder_parse_charstrings( decoder, charstring,
-                                             charstring_len );
+                                             charstring_len, 0 );
       decoder->seac = FALSE;
 
       cff_free_glyph_data( face, &charstring, charstring_len );
@@ -856,7 +856,7 @@
       /* the seac operator must not be nested */
       decoder->seac = TRUE;
       error = cff_decoder_parse_charstrings( decoder, charstring,
-                                             charstring_len );
+                                             charstring_len, 0 );
       decoder->seac = FALSE;
 
       cff_free_glyph_data( face, &charstring, charstring_len );
@@ -895,13 +895,17 @@
   /*                                                                       */
   /*    charstring_len  :: The length in bytes of the charstring stream.   */
   /*                                                                       */
+  /*    in_dict         :: Set to 1 if function is called from top or      */
+  /*                       private DICT (needed for Multiple Master CFFs). */
+  /*                                                                       */
   /* <Return>                                                              */
   /*    FreeType error code.  0 means success.                             */
   /*                                                                       */
   FT_LOCAL_DEF( FT_Error )
   cff_decoder_parse_charstrings( CFF_Decoder*  decoder,
                                  FT_Byte*      charstring_base,
-                                 FT_ULong      charstring_len )
+                                 FT_ULong      charstring_len,
+                                 FT_Bool       in_dict )
   {
     FT_Error           error;
     CFF_Decoder_Zone*  zone;
@@ -913,6 +917,10 @@
     FT_Fixed*          stack;
     FT_Int             charstring_type =
                          decoder->cff->top_font.font_dict.charstring_type;
+    FT_UShort          num_designs =
+                         decoder->cff->top_font.font_dict.num_designs;
+    FT_UShort          num_axes =
+                         decoder->cff->top_font.font_dict.num_axes;
 
     T2_Hints_Funcs     hinter;
 
@@ -1241,6 +1249,44 @@
         if ( op == cff_op_unknown )
           continue;
 
+        /* in Multiple Master CFFs, T2 charstrings can appear in */
+        /* dictionaries, but some operators are prohibited       */
+        if ( in_dict )
+        {
+          switch ( op )
+          {
+          case cff_op_hstem:
+          case cff_op_vstem:
+          case cff_op_vmoveto:
+          case cff_op_rlineto:
+          case cff_op_hlineto:
+          case cff_op_vlineto:
+          case cff_op_rrcurveto:
+          case cff_op_hstemhm:
+          case cff_op_hintmask:
+          case cff_op_cntrmask:
+          case cff_op_rmoveto:
+          case cff_op_hmoveto:
+          case cff_op_vstemhm:
+          case cff_op_rcurveline:
+          case cff_op_rlinecurve:
+          case cff_op_vvcurveto:
+          case cff_op_hhcurveto:
+          case cff_op_vhcurveto:
+          case cff_op_hvcurveto:
+          case cff_op_hflex:
+          case cff_op_flex:
+          case cff_op_hflex1:
+          case cff_op_flex1:
+          case cff_op_callsubr:
+          case cff_op_callgsubr:
+            goto MM_Error;
+
+          default:
+            break;
+          }
+        }
+
         /* check arguments */
         req_args = cff_argument_counts[op];
         if ( req_args & CFF_COUNT_CHECK_WIDTH )
@@ -1278,7 +1324,9 @@
             case cff_op_endchar:
               /* If there is a width specified for endchar, we either have */
               /* 1 argument or 5 arguments.  We like to argue.             */
-              set_width_ok = ( num_args == 5 ) || ( num_args == 1 );
+              set_width_ok = in_dict
+                               ? 0
+                               : ( ( num_args == 5 ) || ( num_args == 1 ) );
               break;
 
             default:
@@ -1971,6 +2019,10 @@
             return error;
 
         case cff_op_endchar:
+          /* in dictionaries, `endchar' simply indicates end of data */
+          if ( in_dict )
+            return error;
+
           FT_TRACE4(( " endchar\n" ));
 
           /* We are going to emulate the seac operator. */
@@ -2198,6 +2250,10 @@
 
             FT_TRACE4(( " put\n" ));
 
+            /* the Type2 specification before version 16-March-2000 */
+            /* didn't give a hard-coded size limit of the temporary */
+            /* storage array; instead, an argument of the           */
+            /* `MultipleMaster' operator set the size               */
             if ( idx >= 0 && idx < CFF_MAX_TRANS_ELEMENTS )
               decoder->buildchar[idx] = val;
           }
@@ -2222,23 +2278,66 @@
         case cff_op_store:
           /* this operator was removed from the Type2 specification */
           /* in version 16-March-2000                               */
-          FT_TRACE4(( " store\n"));
 
-          goto Unimplemented;
+          /* since we currently don't handle interpolation of multiple */
+          /* master fonts, this is a no-op                             */
+          FT_TRACE4(( " store\n"));
+          break;
 
         case cff_op_load:
           /* this operator was removed from the Type2 specification */
           /* in version 16-March-2000                               */
-          FT_TRACE4(( " load\n" ));
+          {
+            FT_Int  reg_idx = (FT_Int)args[0];
+            FT_Int  idx     = (FT_Int)args[1];
+            FT_Int  count   = (FT_Int)args[2];
+
+
+            FT_TRACE4(( " load\n" ));
+
+            /* since we currently don't handle interpolation of multiple */
+            /* master fonts, we store a vector [1 0 0 ...] in the        */
+            /* temporary storage array regardless of the Registry index  */
+            if ( reg_idx >= 0 && reg_idx <= 2             &&
+                 idx >= 0 && idx < CFF_MAX_TRANS_ELEMENTS &&
+                 count >= 0 && count <= num_axes          )
+            {
+              FT_Int  end, i;
+
 
-          goto Unimplemented;
+              end = FT_MIN( idx + count, CFF_MAX_TRANS_ELEMENTS );
+
+              if ( idx < end )
+                decoder->buildchar[idx] = 1 << 16;
+
+              for ( i = idx + 1; i < end; i++ )
+                decoder->buildchar[i] = 0;
+            }
+          }
+          break;
 
         case cff_op_blend:
           /* this operator was removed from the Type2 specification */
           /* in version 16-March-2000                               */
-          FT_TRACE4(( " blend\n" ));
+          {
+            FT_Int  num_results = (FT_Int)( args[0] >> 16 );
+
+
+            FT_TRACE4(( " blend\n" ));
+
+            if ( num_results < 0 )
+              goto Syntax_Error;
+
+            if ( num_results * (FT_Int)num_designs > num_args )
+              goto Stack_Underflow;
 
-          goto Unimplemented;
+            /* since we currently don't handle interpolation of multiple */
+            /* master fonts, return the `num_results' values of the      */
+            /* first master                                              */
+            args     -= num_results * ( num_designs - 1 );
+            num_args -= num_results * ( num_designs - 1 );
+          }
+          break;
 
         case cff_op_dotsection:
           /* this operator is deprecated and ignored by the parser */
@@ -2511,7 +2610,6 @@
           break;
 
         default:
-        Unimplemented:
           FT_ERROR(( "Unimplemented opcode: %d", ip[-1] ));
 
           if ( ip[-1] == 12 )
@@ -2535,6 +2633,11 @@
   Fail:
     return error;
 
+  MM_Error:
+    FT_TRACE4(( "cff_decoder_parse_charstrings:"
+                " invalid opcode found in top DICT charstring\n"));
+    return FT_THROW( Invalid_File_Format );
+
   Syntax_Error:
     FT_TRACE4(( "cff_decoder_parse_charstrings: syntax error\n" ));
     return FT_THROW( Invalid_File_Format );
@@ -2608,7 +2711,8 @@
         if ( !error )
           error = cff_decoder_parse_charstrings( &decoder,
                                                  charstring,
-                                                 charstring_len );
+                                                 charstring_len,
+                                                 0 );
 
         cff_free_glyph_data( face, &charstring, &charstring_len );
       }
@@ -2859,7 +2963,8 @@
       if ( driver->hinting_engine == FT_CFF_HINTING_FREETYPE )
         error = cff_decoder_parse_charstrings( &decoder,
                                                charstring,
-                                               charstring_len );
+                                               charstring_len,
+                                               0 );
       else
 #endif
       {
diff --git src/cff/cffgload.h src/cff/cffgload.h
index 2257307..b875fbe 100644
--- src/cff/cffgload.h
+++ src/cff/cffgload.h
@@ -227,7 +227,8 @@ FT_BEGIN_HEADER
   FT_LOCAL( FT_Error )
   cff_decoder_parse_charstrings( CFF_Decoder*  decoder,
                                  FT_Byte*      charstring_base,
-                                 FT_ULong      charstring_len );
+                                 FT_ULong      charstring_len,
+                                 FT_Bool       in_dict );
 #endif
 
   FT_LOCAL( FT_Error )
diff --git src/cff/cffload.c src/cff/cffload.c
index 42cc37e..3d1bda9 100644
--- src/cff/cffload.c
+++ src/cff/cffload.c
@@ -382,13 +382,15 @@
   static FT_Error
   cff_index_get_pointers( CFF_Index   idx,
                           FT_Byte***  table,
-                          FT_Byte**   pool )
+                          FT_Byte**   pool,
+                          FT_ULong*   pool_size )
   {
     FT_Error   error     = FT_Err_Ok;
     FT_Memory  memory    = idx->stream->memory;
 
     FT_Byte**  t         = NULL;
     FT_Byte*   new_bytes = NULL;
+    FT_ULong   new_size;
 
 
     *table = NULL;
@@ -400,10 +402,11 @@
         goto Exit;
     }
 
-    if ( idx->count > 0                                        &&
-         !FT_NEW_ARRAY( t, idx->count + 1 )                    &&
-         ( !pool || !FT_ALLOC( new_bytes,
-                               idx->data_size + idx->count ) ) )
+    new_size = idx->data_size + idx->count;
+
+    if ( idx->count > 0                                &&
+         !FT_NEW_ARRAY( t, idx->count + 1 )            &&
+         ( !pool || !FT_ALLOC( new_bytes, new_size ) ) )
     {
       FT_ULong  n, cur_offset;
       FT_ULong  extra = 0;
@@ -459,6 +462,8 @@
 
       if ( pool )
         *pool = new_bytes;
+      if ( pool_size )
+        *pool_size = new_size;
     }
 
   Exit:
@@ -809,7 +814,7 @@
     /* When multiple GIDs map to the same CID, we choose the lowest */
     /* GID.  This is not described in any spec, but it matches the  */
     /* behaviour of recent Acroread versions.                       */
-    for ( j = (FT_Long)num_glyphs - 1; j >= 0 ; j-- )
+    for ( j = (FT_Long)num_glyphs - 1; j >= 0; j-- )
       charset->cids[charset->sids[j]] = (FT_UShort)j;
 
     charset->max_cid    = max_cid;
@@ -871,8 +876,8 @@
     FT_UShort  glyph_sid;
 
 
-    /* If the the offset is greater than 2, we have to parse the */
-    /* charset table.                                            */
+    /* If the offset is greater than 2, we have to parse the charset */
+    /* table.                                                        */
     if ( offset > 2 )
     {
       FT_UInt  j;
@@ -1316,7 +1321,12 @@
     CFF_Private      priv = &font->private_dict;
 
 
-    cff_parser_init( &parser, CFF_CODE_TOPDICT, &font->font_dict, library );
+    cff_parser_init( &parser,
+                     CFF_CODE_TOPDICT,
+                     &font->font_dict,
+                     library,
+                     0,
+                     0 );
 
     /* set defaults */
     FT_MEM_ZERO( top, sizeof ( *top ) );
@@ -1370,7 +1380,12 @@
       priv->expansion_factor = (FT_Fixed)( 0.06 * 0x10000L );
       priv->blue_scale       = (FT_Fixed)( 0.039625 * 0x10000L * 1000 );
 
-      cff_parser_init( &parser, CFF_CODE_PRIVATE, priv, library );
+      cff_parser_init( &parser,
+                       CFF_CODE_PRIVATE,
+                       priv,
+                       library,
+                       top->num_designs,
+                       top->num_axes );
 
       if ( FT_STREAM_SEEK( base_offset + font->font_dict.private_offset ) ||
            FT_FRAME_ENTER( font->font_dict.private_size )                 )
@@ -1400,7 +1415,7 @@
         goto Exit;
 
       error = cff_index_get_pointers( &font->local_subrs_index,
-                                      &font->local_subrs, NULL );
+                                      &font->local_subrs, NULL, NULL );
       if ( error )
         goto Exit;
     }
@@ -1478,16 +1493,17 @@
 
     /* read the name, top dict, string and global subrs index */
     if ( FT_SET_ERROR( cff_index_init( &font->name_index,
-                                       stream, 0 ) )                  ||
+                                       stream, 0 ) )                       ||
          FT_SET_ERROR( cff_index_init( &font->font_dict_index,
-                                       stream, 0 ) )                  ||
+                                       stream, 0 ) )                       ||
          FT_SET_ERROR( cff_index_init( &string_index,
-                                       stream, 1 ) )                  ||
+                                       stream, 1 ) )                       ||
          FT_SET_ERROR( cff_index_init( &font->global_subrs_index,
-                                       stream, 1 ) )                  ||
+                                       stream, 1 ) )                       ||
          FT_SET_ERROR( cff_index_get_pointers( &string_index,
                                                &font->strings,
-                                               &font->string_pool ) ) )
+                                               &font->string_pool,
+                                               &font->string_pool_size ) ) )
       goto Exit;
 
     font->num_strings = string_index.count;
@@ -1614,7 +1630,7 @@
     font->num_glyphs = font->charstrings_index.count;
 
     error = cff_index_get_pointers( &font->global_subrs_index,
-                                    &font->global_subrs, NULL );
+                                    &font->global_subrs, NULL, NULL );
 
     if ( error )
       goto Exit;
diff --git src/cff/cffobjs.c src/cff/cffobjs.c
index e22ae82..b49616d 100644
--- src/cff/cffobjs.c
+++ src/cff/cffobjs.c
@@ -625,11 +625,44 @@
         FT_TRACE4(( "SIDs\n" ));
 
         /* dump string index, including default strings for convenience */
-        for ( idx = 0; idx < cff->num_strings + 390; idx++ )
+        for ( idx = 0; idx <= 390; idx++ )
         {
           s = cff_index_get_sid_string( cff, idx );
           if ( s )
-            FT_TRACE4(("  %5d %s\n", idx, s ));
+            FT_TRACE4(( "  %5d %s\n", idx, s ));
+        }
+
+        /* In Multiple Master CFFs, two SIDs hold the Normalize Design  */
+        /* Vector (NDV) and Convert Design Vector (CDV) charstrings,    */
+        /* which may contain NULL bytes in the middle of the data, too. */
+        /* We thus access `cff->strings' directly.                      */
+        for ( idx = 1; idx < cff->num_strings; idx++ )
+        {
+          FT_Byte*    s1    = cff->strings[idx - 1];
+          FT_Byte*    s2    = cff->strings[idx];
+          FT_PtrDist  s1len = s2 - s1 - 1; /* without the final NULL byte */
+          FT_PtrDist  l;
+
+
+          FT_TRACE4(( "  %5d ", idx + 390 ));
+          for ( l = 0; l < s1len; l++ )
+            FT_TRACE4(( "%c", s1[l] ));
+          FT_TRACE4(( "\n" ));
+        }
+
+        /* print last element */
+        if ( cff->num_strings )
+        {
+          FT_Byte*    s1    = cff->strings[cff->num_strings - 1];
+          FT_Byte*    s2    = cff->string_pool + cff->string_pool_size;
+          FT_PtrDist  s1len = s2 - s1 - 1;
+          FT_PtrDist  l;
+
+
+          FT_TRACE4(( "  %5d ", cff->num_strings + 390 ));
+          for ( l = 0; l < s1len; l++ )
+            FT_TRACE4(( "%c", s1[l] ));
+          FT_TRACE4(( "\n" ));
         }
       }
 #endif /* FT_DEBUG_LEVEL_TRACE */
diff --git src/cff/cffparse.c src/cff/cffparse.c
index acbdc5a..2ece516 100644
--- src/cff/cffparse.c
+++ src/cff/cffparse.c
@@ -23,6 +23,7 @@
 
 #include "cfferrs.h"
 #include "cffpic.h"
+#include "cffgload.h"
 
 
   /*************************************************************************/
@@ -39,7 +40,9 @@
   cff_parser_init( CFF_Parser  parser,
                    FT_UInt     code,
                    void*       object,
-                   FT_Library  library)
+                   FT_Library  library,
+                   FT_UShort   num_designs,
+                   FT_UShort   num_axes )
   {
     FT_MEM_ZERO( parser, sizeof ( *parser ) );
 
@@ -47,6 +50,8 @@
     parser->object_code = code;
     parser->object      = object;
     parser->library     = library;
+    parser->num_designs = num_designs;
+    parser->num_axes    = num_axes;
   }
 
 
@@ -649,6 +654,56 @@
   }
 
 
+  /* The `MultipleMaster' operator comes before any  */
+  /* top DICT operators that contain T2 charstrings. */
+
+  static FT_Error
+  cff_parse_multiple_master( CFF_Parser  parser )
+  {
+    CFF_FontRecDict  dict = (CFF_FontRecDict)parser->object;
+    FT_Error         error;
+
+
+#ifdef FT_DEBUG_LEVEL_TRACE
+    /* beautify tracing message */
+    if ( ft_trace_levels[FT_COMPONENT] < 4 )
+      FT_TRACE1(( "Multiple Master CFFs not supported yet,"
+                  " handling first master design only\n" ));
+    else
+      FT_TRACE1(( " (not supported yet,"
+                  " handling first master design only)\n" ));
+#endif
+
+    error = FT_ERR( Stack_Underflow );
+
+    /* currently, we handle only the first argument */
+    if ( parser->top >= parser->stack + 5 )
+    {
+      FT_Long  num_designs = cff_parse_num( parser->stack );
+
+
+      if ( num_designs > 16 || num_designs < 2 )
+      {
+        FT_ERROR(( "cff_parse_multiple_master:"
+                   " Invalid number of designs\n" ));
+        error = FT_THROW( Invalid_File_Format );
+      }
+      else
+      {
+        dict->num_designs   = (FT_UShort)num_designs;
+        dict->num_axes      = (FT_UShort)( parser->top - parser->stack - 4 );
+
+        parser->num_designs = dict->num_designs;
+        parser->num_axes    = dict->num_axes;
+
+        error = FT_Err_Ok;
+      }
+    }
+
+    return error;
+  }
+
+
   static FT_Error
   cff_parse_cid_ros( CFF_Parser  parser )
   {
@@ -972,7 +1027,7 @@
         if ( parser->top - parser->stack >= CFF_MAX_STACK_DEPTH )
           goto Stack_Overflow;
 
-        *parser->top ++ = p;
+        *parser->top++ = p;
 
         /* now, skip it */
         if ( v == 30 )
@@ -1001,6 +1056,136 @@
         else if ( v > 246 )
           p += 1;
       }
+#ifdef CFF_CONFIG_OPTION_OLD_ENGINE
+      else if ( v == 31 )
+      {
+        /* a Type 2 charstring */
+
+        CFF_Decoder  decoder;
+        CFF_FontRec  cff_rec;
+        FT_Byte*     charstring_base;
+        FT_ULong     charstring_len;
+
+        FT_Fixed*  stack;
+        FT_Byte*   q;
+
+
+        charstring_base = ++p;
+
+        /* search `endchar' operator */
+        for (;;)
+        {
+          if ( p >= limit )
+            goto Exit;
+          if ( *p == 14 )
+            break;
+          p++;
+        }
+
+        charstring_len = (FT_ULong)( p - charstring_base ) + 1;
+
+        /* construct CFF_Decoder object */
+        FT_MEM_ZERO( &decoder, sizeof ( decoder ) );
+        FT_MEM_ZERO( &cff_rec, sizeof ( cff_rec ) );
+
+        cff_rec.top_font.font_dict.num_designs = parser->num_designs;
+        cff_rec.top_font.font_dict.num_axes    = parser->num_axes;
+        decoder.cff                            = &cff_rec;
+
+        error = cff_decoder_parse_charstrings( &decoder,
+                                               charstring_base,
+                                               charstring_len,
+                                               1 );
+
+        /* Now copy the stack data in the temporary decoder object,    */
+        /* converting it back to charstring number representations     */
+        /* (this is ugly, I know).                                     */
+        /*                                                             */
+        /* We overwrite the original top DICT charstring under the     */
+        /* assumption that the charstring representation of the result */
+        /* of `cff_decoder_parse_charstrings' is shorter, which should */
+        /* be always true.                                             */
+
+        q     = charstring_base - 1;
+        stack = decoder.stack;
+
+        while ( stack < decoder.top )
+        {
+          FT_ULong  num;
+          FT_Bool   neg;
+
+
+          if ( parser->top - parser->stack >= CFF_MAX_STACK_DEPTH )
+            goto Stack_Overflow;
+
+          *parser->top++ = q;
+
+          if ( *stack < 0 )
+          {
+            num = (FT_ULong)-*stack;
+            neg = 1;
+          }
+          else
+          {
+            num = (FT_ULong)*stack;
+            neg = 0;
+          }
+
+          if ( num & 0xFFFFU )
+          {
+            if ( neg )
+              num = (FT_ULong)-num;
+
+            *q++ = 255;
+            *q++ = ( num & 0xFF000000U ) >> 24;
+            *q++ = ( num & 0x00FF0000U ) >> 16;
+            *q++ = ( num & 0x0000FF00U ) >>  8;
+            *q++ =   num & 0x000000FFU;
+          }
+          else
+          {
+            num >>= 16;
+
+            if ( neg )
+            {
+              if ( num <= 107 )
+                *q++ = (FT_Byte)( 139 - num );
+              else if ( num <= 1131 )
+              {
+                *q++ = (FT_Byte)( ( ( num - 108 ) >> 8 ) + 251 );
+                *q++ = (FT_Byte)( ( num - 108 ) & 0xFF );
+              }
+              else
+              {
+                num = (FT_ULong)-num;
+
+                *q++ = 28;
+                *q++ = (FT_Byte)( num >> 8 );
+                *q++ = (FT_Byte)( num & 0xFF );
+              }
+            }
+            else
+            {
+              if ( num <= 107 )
+                *q++ = (FT_Byte)( num + 139 );
+              else if ( num <= 1131 )
+              {
+                *q++ = (FT_Byte)( ( ( num - 108 ) >> 8 ) + 247 );
+                *q++ = (FT_Byte)( ( num - 108 ) & 0xFF );
+              }
+              else
+              {
+                *q++ = 28;
+                *q++ = (FT_Byte)( num >> 8 );
+                *q++ = (FT_Byte)( num & 0xFF );
+              }
+            }
+          }
+
+          stack++;
+        }
+      }
+#endif /* CFF_CONFIG_OPTION_OLD_ENGINE */
       else
       {
         /* This is not a number, hence it's an operator.  Compute its code */
diff --git src/cff/cffparse.h src/cff/cffparse.h
index bb9425a..a95970e 100644
--- src/cff/cffparse.h
+++ src/cff/cffparse.h
@@ -36,16 +36,19 @@ FT_BEGIN_HEADER
 
   typedef struct  CFF_ParserRec_
   {
-    FT_Library library;
-    FT_Byte*   start;
-    FT_Byte*   limit;
-    FT_Byte*   cursor;
+    FT_Library  library;
+    FT_Byte*    start;
+    FT_Byte*    limit;
+    FT_Byte*    cursor;
 
-    FT_Byte*   stack[CFF_MAX_STACK_DEPTH + 1];
-    FT_Byte**  top;
+    FT_Byte*    stack[CFF_MAX_STACK_DEPTH + 1];
+    FT_Byte**   top;
 
-    FT_UInt    object_code;
-    void*      object;
+    FT_UInt     object_code;
+    void*       object;
+
+    FT_UShort   num_designs; /* a copy of `CFF_FontRecDict->num_designs' */
+    FT_UShort   num_axes;    /* a copy of `CFF_FontRecDict->num_axes'    */
 
   } CFF_ParserRec, *CFF_Parser;
 
@@ -54,7 +57,9 @@ FT_BEGIN_HEADER
   cff_parser_init( CFF_Parser  parser,
                    FT_UInt     code,
                    void*       object,
-                   FT_Library  library);
+                   FT_Library  library,
+                   FT_UShort   num_designs,
+                   FT_UShort   num_axes );
 
   FT_LOCAL( FT_Error )
   cff_parser_run( CFF_Parser  parser,
diff --git src/cff/cfftoken.h src/cff/cfftoken.h
index 44b6580..22637c7 100644
--- src/cff/cfftoken.h
+++ src/cff/cfftoken.h
@@ -38,6 +38,9 @@
   CFF_FIELD_NUM     ( 13,    unique_id,           "UniqueID" )
   CFF_FIELD_CALLBACK( 5,     font_bbox,           "FontBBox" )
   CFF_FIELD_NUM     ( 0x108, stroke_width,        "StrokeWidth" )
+#if 0
+  CFF_FIELD_DELTA   ( 14,    xuid, 16,            "XUID" )
+#endif
   CFF_FIELD_NUM     ( 15,    charset_offset,      "charset" )
   CFF_FIELD_NUM     ( 16,    encoding_offset,     "Encoding" )
   CFF_FIELD_NUM     ( 17,    charstrings_offset,  "CharStrings" )
@@ -48,8 +51,13 @@
 #if 0
   CFF_FIELD_STRING  ( 0x116, base_font_name,      "BaseFontName" )
   CFF_FIELD_DELTA   ( 0x117, base_font_blend, 16, "BaseFontBlend" )
+#endif
+
+  /* the next two operators were removed from the Type2 specification */
+  /* in version 16-March-2000                                         */
   CFF_FIELD_CALLBACK( 0x118, multiple_master,     "MultipleMaster" )
-  CFF_FIELD_CALLBACK( 0x119, blend_axis_types,    "BlendAxisTypes" )
+#if 0
+  CFF_FIELD_CALLBACK( 0x11A, blend_axis_types,    "BlendAxisTypes" )
 #endif
 
   CFF_FIELD_CALLBACK( 0x11E, cid_ros,              "ROS" )
diff --git src/cff/cfftypes.h src/cff/cfftypes.h
index 80f13fe..4426c7e 100644
--- src/cff/cfftypes.h
+++ src/cff/cfftypes.h
@@ -145,6 +145,12 @@ FT_BEGIN_HEADER
     FT_ULong   cid_fd_select_offset;
     FT_UInt    cid_font_name;
 
+    /* the next fields come from the data of the deprecated          */
+    /* `MultipleMaster' operator; they are needed to parse the (also */
+    /* deprecated) `blend' operator in Type 2 charstrings            */
+    FT_UShort  num_designs;
+    FT_UShort  num_axes;
+
   } CFF_FontRecDictRec, *CFF_FontRecDict;
 
 
@@ -250,6 +256,7 @@ FT_BEGIN_HEADER
     FT_UInt          num_strings;
     FT_Byte**        strings;
     FT_Byte*         string_pool;
+    FT_ULong         string_pool_size;
 
     CFF_SubFontRec   top_font;
     FT_UInt          num_subfonts;
diff --git src/gxvalid/gxvcommn.c src/gxvalid/gxvcommn.c
index 2606e57..4b5e415 100644
--- src/gxvalid/gxvcommn.c
+++ src/gxvalid/gxvcommn.c
@@ -900,7 +900,7 @@
     for ( i = 0; i < nnames; i++ )
     {
       if ( FT_Get_Sfnt_Name( gxvalid->face, i, &name ) != FT_Err_Ok )
-        continue ;
+        continue;
 
       if ( name.name_id == name_index )
         goto Out;
@@ -1472,7 +1472,7 @@
     if ( ( p + ( maxEntry + 1 ) * entrySize ) > limit )
       FT_INVALID_TOO_SHORT;
 
-    for (entry = 0; entry <= maxEntry ; entry++ )
+    for (entry = 0; entry <= maxEntry; entry++ )
     {
       FT_UShort                        newState_idx;
       FT_UShort                        flags;
diff --git src/gxvalid/gxvcommn.h src/gxvalid/gxvcommn.h
index d49c4b4..9470c84 100644
--- src/gxvalid/gxvcommn.h
+++ src/gxvalid/gxvcommn.h
@@ -338,7 +338,7 @@ FT_BEGIN_HEADER
                                                         \
                                                         \
               for ( b = p; b < (FT_Bytes)p + len; b++ ) \
-                FT_TRACE1(("\\x%02x", *b)) ;            \
+                FT_TRACE1(("\\x%02x", *b));             \
             }                                           \
           FT_END_STMNT
 
@@ -350,9 +350,9 @@ FT_BEGIN_HEADER
                                                         \
               for ( b = p; b < (FT_Bytes)p + len; b++ ) \
                 if ( 0x40 < *b && *b < 0x7E )           \
-                  FT_TRACE1(("%c", *b)) ;               \
+                  FT_TRACE1(("%c", *b));                \
                 else                                    \
-                  FT_TRACE1(("\\x%02x", *b)) ;          \
+                  FT_TRACE1(("\\x%02x", *b));           \
             }                                           \
           FT_END_STMNT
 
diff --git src/gxvalid/gxvjust.c src/gxvalid/gxvjust.c
index fc8db0d..20d29bf 100644
--- src/gxvalid/gxvjust.c
+++ src/gxvalid/gxvjust.c
@@ -152,7 +152,7 @@
                                         FT_Bytes       limit,
                                         GXV_Validator  gxvalid )
   {
-    FT_Bytes  p         = table ;
+    FT_Bytes  p         = table;
     FT_Bytes  wdc_end   = table + GXV_JUST_DATA( wdc_offset_max );
     FT_UInt   i;
 
diff --git src/gxvalid/gxvkern.c src/gxvalid/gxvkern.c
index 97ff3bf..ee1ab36 100644
--- src/gxvalid/gxvkern.c
+++ src/gxvalid/gxvkern.c
@@ -693,7 +693,7 @@
 
     GXV_NAME_ENTER( "validating coverage" );
 
-    GXV_TRACE(( "interprete coverage 0x%04x by Apple style\n", coverage ));
+    GXV_TRACE(( "interpret coverage 0x%04x by Apple style\n", coverage ));
 
     if ( KERN_IS_NEW( gxvalid ) )
     {
@@ -728,7 +728,7 @@
       }
     }
 
-    GXV_TRACE(( "cannot interprete coverage, broken kern subtable\n" ));
+    GXV_TRACE(( "cannot interpret coverage, broken kern subtable\n" ));
 
   Exit:
     GXV_EXIT;
diff --git src/gxvalid/gxvlcar.c src/gxvalid/gxvlcar.c
index d600fa3..d31b641 100644
--- src/gxvalid/gxvlcar.c
+++ src/gxvalid/gxvlcar.c
@@ -114,7 +114,7 @@
     +------ lcar --------------------+
     |                                |
     |      +===============+         |
-    |      | looup header  |         |
+    |      | lookup header |         |
     |      +===============+         |
     |      | BinSrchHeader |         |
     |      +===============+         |
diff --git src/gxvalid/gxvmort1.c src/gxvalid/gxvmort1.c
index 24fed63..fd761d0 100644
--- src/gxvalid/gxvmort1.c
+++ src/gxvalid/gxvmort1.c
@@ -192,7 +192,7 @@
 
 
     GXV_NAME_ENTER( "validating contents of substitutionTable" );
-    for ( i = 0; i < num_gids ; i ++ )
+    for ( i = 0; i < num_gids; i++ )
     {
       FT_UShort  dst_gid;
 
diff --git src/gxvalid/gxvtrak.c src/gxvalid/gxvtrak.c
index 8accdfb..0f07c04 100644
--- src/gxvalid/gxvtrak.c
+++ src/gxvalid/gxvtrak.c
@@ -111,7 +111,7 @@
 
     GXV_LIMIT_CHECK( nTracks * ( 4 + 2 + 2 ) );
 
-    for ( i = 0; i < nTracks; i ++ )
+    for ( i = 0; i < nTracks; i++ )
     {
       p = table + i * ( 4 + 2 + 2 );
       track     = FT_NEXT_LONG( p );
@@ -125,7 +125,7 @@
 
       gxv_sfntName_validate( nameIndex, 256, 32767, gxvalid );
 
-      for ( j = i; j < nTracks; j ++ )
+      for ( j = i; j < nTracks; j++ )
       {
          p = table + j * ( 4 + 2 + 2 );
          t = FT_NEXT_LONG( p );
diff --git src/gzip/ftgzip.c src/gzip/ftgzip.c
index 9c1f183..9cab80e 100644
--- src/gzip/ftgzip.c
+++ src/gzip/ftgzip.c
@@ -59,7 +59,7 @@
  /* original ZLib.                                                   */
 
 #ifndef USE_ZLIB_ZCALLOC
-#define MY_ZCALLOC /* prevent all zcalloc() & zfree() in zutils.c */
+#define MY_ZCALLOC /* prevent all zcalloc() & zfree() in zutil.c */
 #endif
 
 #include "zlib.h"
diff --git src/otvalid/otvmath.c src/otvalid/otvmath.c
index 6c46178..6c785b6 100644
--- src/otvalid/otvmath.c
+++ src/otvalid/otvmath.c
@@ -88,7 +88,7 @@
                                           FT_Int         isItalic )
   {
     FT_Bytes  p = table;
-    FT_UInt   i, cnt, table_size ;
+    FT_UInt   i, cnt, table_size;
 
     OTV_OPTIONAL_TABLE( Coverage );
     OTV_OPTIONAL_TABLE( DeviceTableOffset );
diff --git src/pcf/pcfread.c src/pcf/pcfread.c
index fca677f..dec05db 100644
--- src/pcf/pcfread.c
+++ src/pcf/pcfread.c
@@ -442,7 +442,7 @@ THE SOFTWARE.
     int           i;
 
 
-    for ( i = 0 ; i < face->nprops && !found; i++ )
+    for ( i = 0; i < face->nprops && !found; i++ )
     {
       if ( !ft_strcmp( properties[i].name, prop ) )
         found = 1;
diff --git src/pfr/pfrgload.c src/pfr/pfrgload.c
index 1dbbf95..f9cd1f6 100644
--- src/pfr/pfrgload.c
+++ src/pfr/pfrgload.c
@@ -336,7 +336,7 @@
     /* XXX: we ignore the secondary stroke and edge definitions */
     /*      since we don't support native PFR hinting           */
     /*                                                          */
-    if ( flags & PFR_GLYPH_EXTRA_ITEMS )
+    if ( flags & PFR_GLYPH_SINGLE_EXTRA_ITEMS )
     {
       error = pfr_extra_items_skip( &p, limit );
       if ( error )
@@ -579,7 +579,7 @@
 
     /* ignore extra items when present */
     /*                                 */
-    if ( flags & PFR_GLYPH_EXTRA_ITEMS )
+    if ( flags & PFR_GLYPH_COMPOUND_EXTRA_ITEMS )
     {
       error = pfr_extra_items_skip( &p, limit );
       if ( error )
diff --git src/pfr/pfrload.c src/pfr/pfrload.c
index ca1f37f..e509e70 100644
--- src/pfr/pfrload.c
+++ src/pfr/pfrload.c
@@ -299,9 +299,15 @@
          FT_READ_USHORT( count )          )
       goto Exit;
 
-    /* check maximum value and a rough minimum size */
+    /* check maximum value and a rough minimum size:     */
+    /* - no more than 13106 log fonts                    */
+    /* - we need 5 bytes for a log header record         */
+    /* - we need at least 18 bytes for a log font record */
+    /* - the overall size is at least 95 bytes plus the  */
+    /*   log header and log font records                 */
     if ( count > ( ( 1 << 16 ) - 2 ) / 5                ||
-         2 + count * 5 >= stream->size - section_offset )
+         2 + count * 5 >= stream->size - section_offset ||
+         95 + count * ( 5 + 18 ) >= stream->size        )
     {
       FT_ERROR(( "pfr_log_font_count:"
                  " invalid number of logical fonts\n" ));
@@ -377,7 +383,7 @@
         if ( flags & PFR_LOG_2BYTE_STROKE )
           local++;
 
-        if ( (flags & PFR_LINE_JOIN_MASK) == PFR_LINE_JOIN_MITER )
+        if ( ( flags & PFR_LINE_JOIN_MASK ) == PFR_LINE_JOIN_MITER )
           local += 3;
       }
       if ( flags & PFR_LOG_BOLD )
@@ -609,7 +615,7 @@
 
   Too_Short:
     error = FT_THROW( Invalid_Table );
-    FT_ERROR(( "pfr_exta_item_load_stem_snaps:"
+    FT_ERROR(( "pfr_extra_item_load_stem_snaps:"
                " invalid stem snaps table\n" ));
     goto Exit;
   }
@@ -737,12 +743,14 @@
     FT_UInt     n, ok;
 
 
+    if ( *astring )
+      FT_FREE( *astring );
+
     if ( len > 0 && p[len - 1] == 0 )
       len--;
 
-    /* check that each character is ASCII for making sure not to
-       load garbage
-     */
+    /* check that each character is ASCII  */
+    /* for making sure not to load garbage */
     ok = ( len > 0 );
     for ( n = 0; n < len; n++ )
       if ( p[n] < 32 || p[n] > 127 )
@@ -759,6 +767,7 @@
       FT_MEM_COPY( result, p, len );
       result[len] = 0;
     }
+
   Exit:
     *astring = result;
     return error;
diff --git src/pfr/pfrobjs.c src/pfr/pfrobjs.c
index 81b1312..769a3b6 100644
--- src/pfr/pfrobjs.c
+++ src/pfr/pfrobjs.c
@@ -524,8 +524,8 @@
         FT_UInt    probe       = power * size;
         FT_UInt    extra       = count - power;
         FT_Byte*   base        = stream->cursor;
-        FT_Bool    twobytes    = FT_BOOL( item->flags & 1 );
-        FT_Bool    twobyte_adj = FT_BOOL( item->flags & 2 );
+        FT_Bool    twobytes    = FT_BOOL( item->flags & PFR_KERN_2BYTE_CHAR );
+        FT_Bool    twobyte_adj = FT_BOOL( item->flags & PFR_KERN_2BYTE_ADJ  );
         FT_Byte*   p;
         FT_UInt32  cpair;
 
diff --git src/pfr/pfrsbit.c src/pfr/pfrsbit.c
index 22f6096..68da033 100644
--- src/pfr/pfrsbit.c
+++ src/pfr/pfrsbit.c
@@ -277,49 +277,99 @@
   pfr_lookup_bitmap_data( FT_Byte*   base,
                           FT_Byte*   limit,
                           FT_UInt    count,
-                          FT_UInt    flags,
+                          FT_UInt*   flags,
                           FT_UInt    char_code,
                           FT_ULong*  found_offset,
                           FT_ULong*  found_size )
   {
-    FT_UInt   left, right, char_len;
-    FT_Bool   two = FT_BOOL( flags & 1 );
+    FT_UInt   min, max, char_len;
+    FT_Bool   two = FT_BOOL( *flags & PFR_BITMAP_2BYTE_CHARCODE );
     FT_Byte*  buff;
 
 
     char_len = 4;
-    if ( two )       char_len += 1;
-    if ( flags & 2 ) char_len += 1;
-    if ( flags & 4 ) char_len += 1;
+    if ( two )
+      char_len += 1;
+    if ( *flags & PFR_BITMAP_2BYTE_SIZE )
+      char_len += 1;
+    if ( *flags & PFR_BITMAP_3BYTE_OFFSET )
+      char_len += 1;
+
+    if ( !( *flags & PFR_BITMAP_CHARCODES_VALIDATED ) )
+    {
+      FT_Byte*  p;
+      FT_Byte*  lim;
+      FT_UInt   code;
+      FT_Long   prev_code;
 
-    left  = 0;
-    right = count;
 
-    while ( left < right )
-    {
-      FT_UInt  middle, code;
+      *flags    |= PFR_BITMAP_VALID_CHARCODES;
+      prev_code  = -1;
+      lim        = base + count * char_len;
 
+      if ( lim > limit )
+      {
+        FT_TRACE0(( "pfr_lookup_bitmap_data:"
+                    " number of bitmap records too large,\n"
+                    "                       "
+                    " thus ignoring all bitmaps in this strike\n" ));
+        *flags &= ~PFR_BITMAP_VALID_CHARCODES;
+      }
+      else
+      {
+        /* check whether records are sorted by code */
+        for ( p = base; p < lim; p += char_len )
+        {
+          if ( two )
+            code = FT_PEEK_USHORT( p );
+          else
+            code = *p;
 
-      middle = ( left + right ) >> 1;
-      buff   = base + middle * char_len;
+          if ( code <= prev_code )
+          {
+            FT_TRACE0(( "pfr_lookup_bitmap_data:"
+                        " bitmap records are not sorted,\n"
+                        "                       "
+                        " thus ignoring all bitmaps in this strike\n" ));
+            *flags &= ~PFR_BITMAP_VALID_CHARCODES;
+            break;
+          }
 
-      /* check that we are not outside of the table -- */
-      /* this is possible with broken fonts...         */
-      if ( buff + char_len > limit )
-        goto Fail;
+          prev_code = code;
+        }
+      }
+
+      *flags |= PFR_BITMAP_CHARCODES_VALIDATED;
+    }
+
+    /* ignore bitmaps in case table is not valid     */
+    /* (this might be sanitized, but PFR is dead...) */
+    if ( !( *flags & PFR_BITMAP_VALID_CHARCODES ) )
+      goto Fail;
+
+    min = 0;
+    max = count;
+
+    /* binary search */
+    while ( min < max )
+    {
+      FT_UInt  mid, code;
+
+
+      mid  = ( min + max ) >> 1;
+      buff = base + mid * char_len;
 
       if ( two )
         code = PFR_NEXT_USHORT( buff );
       else
         code = PFR_NEXT_BYTE( buff );
 
-      if ( code == char_code )
-        goto Found_It;
-
-      if ( code < char_code )
-        left = middle;
+      if ( char_code < code )
+        max = mid;
+      else if ( char_code > code )
+        min = mid + 1;
       else
-        right = middle;
+        goto Found_It;
     }
 
   Fail:
@@ -329,12 +379,12 @@
     return;
 
   Found_It:
-    if ( flags & 2 )
+    if ( *flags & PFR_BITMAP_2BYTE_SIZE )
       *found_size = PFR_NEXT_USHORT( buff );
     else
       *found_size = PFR_NEXT_BYTE( buff );
 
-    if ( flags & 4 )
+    if ( *flags & PFR_BITMAP_3BYTE_OFFSET )
       *found_offset = PFR_NEXT_ULONG( buff );
     else
       *found_offset = PFR_NEXT_USHORT( buff );
@@ -357,7 +407,6 @@
   {
     FT_Error  error = FT_Err_Ok;
     FT_Byte   flags;
-    FT_Char   c;
     FT_Byte   b;
     FT_Byte*  p = *pdata;
     FT_Long   xpos, ypos, advance;
@@ -377,9 +426,9 @@
     {
     case 0:
       PFR_CHECK( 1 );
-      c    = PFR_NEXT_INT8( p );
-      xpos = c >> 4;
-      ypos = ( (FT_Char)( c << 4 ) ) >> 4;
+      b    = PFR_NEXT_BYTE( p );
+      xpos = (FT_Char)b >> 4;
+      ypos = ( (FT_Char)( b << 4 ) ) >> 4;
       break;
 
     case 1:
@@ -445,7 +494,7 @@
 
     case 1:
       PFR_CHECK( 1 );
-      advance = PFR_NEXT_INT8( p ) << 8;
+      advance = PFR_NEXT_INT8( p ) * 256;
       break;
 
     case 2:
@@ -571,9 +620,12 @@
 
 
       char_len = 4;
-      if ( strike->flags & 1 ) char_len += 1;
-      if ( strike->flags & 2 ) char_len += 1;
-      if ( strike->flags & 4 ) char_len += 1;
+      if ( strike->flags & PFR_BITMAP_2BYTE_CHARCODE )
+        char_len += 1;
+      if ( strike->flags & PFR_BITMAP_2BYTE_SIZE )
+        char_len += 1;
+      if ( strike->flags & PFR_BITMAP_3BYTE_OFFSET )
+        char_len += 1;
 
       /* access data directly in the frame to speed lookups */
       if ( FT_STREAM_SEEK( phys->bct_offset + strike->bct_offset ) ||
@@ -583,7 +635,7 @@
       pfr_lookup_bitmap_data( stream->cursor,
                               stream->limit,
                               strike->num_bitmaps,
-                              strike->flags,
+                              &strike->flags,
                               character->char_code,
                               &gps_offset,
                               &gps_size );
@@ -630,6 +682,8 @@
                                        &xpos, &ypos,
                                        &xsize, &ysize,
                                        &advance, &format );
+      if ( error )
+        goto Exit1;
 
       /*
        * Before allocating the target bitmap, we check whether the given
@@ -675,7 +729,7 @@
       {
         if ( FT_ERR_EQ( error, Invalid_Table ) )
           FT_ERROR(( "pfr_slot_load_bitmap: invalid bitmap dimensions\n" ));
-        goto Exit;
+        goto Exit1;
       }
 
       /*
@@ -710,8 +764,8 @@
         /* XXX: needs casts to fit FT_Glyph_Metrics.{width|height} */
         glyph->root.metrics.width        = (FT_Pos)xsize << 6;
         glyph->root.metrics.height       = (FT_Pos)ysize << 6;
-        glyph->root.metrics.horiBearingX = xpos << 6;
-        glyph->root.metrics.horiBearingY = ypos << 6;
+        glyph->root.metrics.horiBearingX = xpos * 64;
+        glyph->root.metrics.horiBearingY = ypos * 64;
         glyph->root.metrics.horiAdvance  = FT_PIX_ROUND( ( advance >> 2 ) );
         glyph->root.metrics.vertBearingX = - glyph->root.metrics.width >> 1;
         glyph->root.metrics.vertBearingY = 0;
@@ -732,11 +786,13 @@
                       p,
                       stream->limit,
                       format,
-                      FT_BOOL(face->header.color_flags & 2),
+                      FT_BOOL( face->header.color_flags &
+                               PFR_FLAG_INVERT_BITMAP   ),
                       &glyph->root.bitmap );
         }
       }
 
+    Exit1:
       FT_FRAME_EXIT();
     }
 
diff --git src/pfr/pfrtypes.h src/pfr/pfrtypes.h
index 592acbd..bd6c2cd 100644
--- src/pfr/pfrtypes.h
+++ src/pfr/pfrtypes.h
@@ -69,12 +69,8 @@ FT_BEGIN_HEADER
 
 
   /* used in `color_flags' field of the PFR_Header */
-  typedef enum  PFR_HeaderFlags_
-  {
-    PFR_FLAG_BLACK_PIXEL   = 1,
-    PFR_FLAG_INVERT_BITMAP = 2
-
-  } PFR_HeaderFlags;
+#define PFR_FLAG_BLACK_PIXEL    0x01U
+#define PFR_FLAG_INVERT_BITMAP  0x02U
 
 
   /************************************************************************/
@@ -96,36 +92,27 @@ FT_BEGIN_HEADER
   } PFR_LogFontRec, *PFR_LogFont;
 
 
-  typedef enum  PFR_LogFlags_
-  {
-    PFR_LOG_EXTRA_ITEMS  = 0x40,
-    PFR_LOG_2BYTE_BOLD   = 0x20,
-    PFR_LOG_BOLD         = 0x10,
-    PFR_LOG_2BYTE_STROKE = 8,
-    PFR_LOG_STROKE       = 4,
-    PFR_LINE_JOIN_MASK   = 3
+#define PFR_LINE_JOIN_MITER   0x00U
+#define PFR_LINE_JOIN_ROUND   0x01U
+#define PFR_LINE_JOIN_BEVEL   0x02U
+#define PFR_LINE_JOIN_MASK    ( PFR_LINE_JOIN_ROUND | PFR_LINE_JOIN_BEVEL )
 
-  } PFR_LogFlags;
-
-
-  typedef enum  PFR_LineJoinFlags_
-  {
-    PFR_LINE_JOIN_MITER = 0,
-    PFR_LINE_JOIN_ROUND = 1,
-    PFR_LINE_JOIN_BEVEL = 2
-
-  } PFR_LineJoinFlags;
+#define PFR_LOG_STROKE        0x04U
+#define PFR_LOG_2BYTE_STROKE  0x08U
+#define PFR_LOG_BOLD          0x10U
+#define PFR_LOG_2BYTE_BOLD    0x20U
+#define PFR_LOG_EXTRA_ITEMS   0x40U
 
 
   /************************************************************************/
 
-  typedef enum  PFR_BitmapFlags_
-  {
-    PFR_BITMAP_3BYTE_OFFSET   = 4,
-    PFR_BITMAP_2BYTE_SIZE     = 2,
-    PFR_BITMAP_2BYTE_CHARCODE = 1
+#define PFR_BITMAP_2BYTE_CHARCODE  0x01U
+#define PFR_BITMAP_2BYTE_SIZE      0x02U
+#define PFR_BITMAP_3BYTE_OFFSET    0x04U
 
-  } PFR_BitmapFlags;
+  /*not part of the specification but used for implementation */
+#define PFR_BITMAP_CHARCODES_VALIDATED  0x40U
+#define PFR_BITMAP_VALID_CHARCODES      0x80U
 
 
   typedef struct  PFR_BitmapCharRec_
@@ -137,15 +124,11 @@ FT_BEGIN_HEADER
   } PFR_BitmapCharRec, *PFR_BitmapChar;
 
 
-  typedef enum  PFR_StrikeFlags_
-  {
-    PFR_STRIKE_2BYTE_COUNT  = 0x10,
-    PFR_STRIKE_3BYTE_OFFSET = 0x08,
-    PFR_STRIKE_3BYTE_SIZE   = 0x04,
-    PFR_STRIKE_2BYTE_YPPM   = 0x02,
-    PFR_STRIKE_2BYTE_XPPM   = 0x01
-
-  } PFR_StrikeFlags;
+#define PFR_STRIKE_2BYTE_XPPM    0x01U
+#define PFR_STRIKE_2BYTE_YPPM    0x02U
+#define PFR_STRIKE_3BYTE_SIZE    0x04U
+#define PFR_STRIKE_3BYTE_OFFSET  0x08U
+#define PFR_STRIKE_2BYTE_COUNT   0x10U
 
 
   typedef struct  PFR_StrikeRec_
@@ -266,38 +249,29 @@ FT_BEGIN_HEADER
   } PFR_PhyFontRec, *PFR_PhyFont;
 
 
-  typedef enum  PFR_PhyFlags_
-  {
-    PFR_PHY_EXTRA_ITEMS      = 0x80,
-    PFR_PHY_3BYTE_GPS_OFFSET = 0x20,
-    PFR_PHY_2BYTE_GPS_SIZE   = 0x10,
-    PFR_PHY_ASCII_CODE       = 0x08,
-    PFR_PHY_PROPORTIONAL     = 0x04,
-    PFR_PHY_2BYTE_CHARCODE   = 0x02,
-    PFR_PHY_VERTICAL         = 0x01
-
-  } PFR_PhyFlags;
+#define PFR_PHY_VERTICAL          0x01U
+#define PFR_PHY_2BYTE_CHARCODE    0x02U
+#define PFR_PHY_PROPORTIONAL      0x04U
+#define PFR_PHY_ASCII_CODE        0x08U
+#define PFR_PHY_2BYTE_GPS_SIZE    0x10U
+#define PFR_PHY_3BYTE_GPS_OFFSET  0x20U
+#define PFR_PHY_EXTRA_ITEMS       0x80U
 
 
-  typedef enum PFR_KernFlags_
-  {
-    PFR_KERN_2BYTE_CHAR  = 0x01,
-    PFR_KERN_2BYTE_ADJ   = 0x02
-
-  } PFR_KernFlags;
+#define PFR_KERN_2BYTE_CHAR  0x01U
+#define PFR_KERN_2BYTE_ADJ   0x02U
 
 
   /************************************************************************/
 
-  typedef enum  PFR_GlyphFlags_
-  {
-    PFR_GLYPH_IS_COMPOUND   = 0x80,
-    PFR_GLYPH_EXTRA_ITEMS   = 0x08,
-    PFR_GLYPH_1BYTE_XYCOUNT = 0x04,
-    PFR_GLYPH_XCOUNT        = 0x02,
-    PFR_GLYPH_YCOUNT        = 0x01
+#define PFR_GLYPH_YCOUNT         0x01U
+#define PFR_GLYPH_XCOUNT         0x02U
+#define PFR_GLYPH_1BYTE_XYCOUNT  0x04U
+
+#define PFR_GLYPH_SINGLE_EXTRA_ITEMS    0x08U
+#define PFR_GLYPH_COMPOUND_EXTRA_ITEMS  0x40U
 
-  } PFR_GlyphFlags;
+#define PFR_GLYPH_IS_COMPOUND  0x80U
 
 
   /* controlled coordinate */
@@ -321,14 +295,10 @@ FT_BEGIN_HEADER
   } PFR_SubGlyphRec, *PFR_SubGlyph;
 
 
-  typedef enum  PFR_SubgGlyphFlags_
-  {
-    PFR_SUBGLYPH_3BYTE_OFFSET = 0x80,
-    PFR_SUBGLYPH_2BYTE_SIZE   = 0x40,
-    PFR_SUBGLYPH_YSCALE       = 0x20,
-    PFR_SUBGLYPH_XSCALE       = 0x10
-
-  } PFR_SubGlyphFlags;
+#define PFR_SUBGLYPH_XSCALE        0x10U
+#define PFR_SUBGLYPH_YSCALE        0x20U
+#define PFR_SUBGLYPH_2BYTE_SIZE    0x40U
+#define PFR_SUBGLYPH_3BYTE_OFFSET  0x80U
 
 
   typedef struct  PFR_GlyphRec_
diff --git src/pshinter/pshalgo.c src/pshinter/pshalgo.c
index 86181cd..8f131be 100644
--- src/pshinter/pshalgo.c
+++ src/pshinter/pshalgo.c
@@ -779,7 +779,7 @@
            * It turns out though that minimizing the total number of lit
            * pixels is also important, so position C), with one edge
            * aligned with a pixel boundary is actually preferable
-           * to A).  There are also more possibile positions for C) than
+           * to A).  There are also more possible positions for C) than
            * for A) or B), so it involves less distortion of the overall
            * character shape.
            */
@@ -802,7 +802,7 @@
             }
 
             /* We choose between B) and C) above based on the amount
-             * of fractinal stem width; for small amounts, choose
+             * of fractional stem width; for small amounts, choose
              * C) always, for large amounts, B) always, and inbetween,
              * pick whichever one involves less stem movement.
              */
diff --git src/raster/ftraster.c src/raster/ftraster.c
index d6c5ded..01ed1c5 100644
--- src/raster/ftraster.c
+++ src/raster/ftraster.c
@@ -3106,9 +3106,9 @@
 
 
   static void
-  ft_black_reset( black_PRaster  raster,
-                  char*          pool_base,
-                  Long           pool_size )
+  ft_black_reset( FT_Raster  raster,
+                  PByte      pool_base,
+                  ULong      pool_size )
   {
     FT_UNUSED( raster );
     FT_UNUSED( pool_base );
@@ -3117,20 +3117,20 @@
 
 
   static int
-  ft_black_set_mode( black_PRaster  raster,
-                     ULong          mode,
-                     const char*    palette )
+  ft_black_set_mode( FT_Raster  raster,
+                     ULong      mode,
+                     void*      args )
   {
     FT_UNUSED( raster );
     FT_UNUSED( mode );
-    FT_UNUSED( palette );
+    FT_UNUSED( args );
 
     return 0;
   }
 
 
   static int
-  ft_black_render( black_PRaster            raster,
+  ft_black_render( FT_Raster                raster,
                    const FT_Raster_Params*  params )
   {
     const FT_Outline*  outline    = (const FT_Outline*)params->source;
@@ -3175,6 +3175,20 @@
     if ( !target_map->buffer )
       return FT_THROW( Invalid );
 
+    /* reject too large outline coordinates */
+    {
+      FT_Vector*  vec   = outline->points;
+      FT_Vector*  limit = vec + outline->n_points;
+
+
+      for ( ; vec < limit; vec++ )
+      {
+        if ( vec->x < -0x1000000L || vec->x > 0x1000000L ||
+             vec->y < -0x1000000L || vec->y > 0x1000000L )
+         return FT_THROW( Invalid );
+      }
+    }
+
     ras.outline = *outline;
     ras.target  = *target_map;
 
diff --git src/sfnt/sfobjs.c src/sfnt/sfobjs.c
index 2cf2ee2..2e8c1ec 100644
--- src/sfnt/sfobjs.c
+++ src/sfnt/sfobjs.c
@@ -949,6 +949,10 @@
              instance_size * num_instances > fvar_len )
         num_instances = 0;
 
+      /* we don't support Multiple Master CFFs yet */
+      if ( !face->goto_table( face, TTAG_CFF, stream, 0 ) )
+        num_instances = 0;
+
       /* we support at most 2^15 - 1 instances */
       if ( num_instances >= ( 1U << 15 ) - 1 )
       {
diff --git src/sfnt/ttcmap.c src/sfnt/ttcmap.c
index 92ec523..01255a8 100644
--- src/sfnt/ttcmap.c
+++ src/sfnt/ttcmap.c
@@ -1245,7 +1245,7 @@
             mid = max + 1;
 
           /* search in segments before the current segment */
-          for ( i = max ; i > 0; i-- )
+          for ( i = max; i > 0; i-- )
           {
             FT_UInt   prev_end;
             FT_Byte*  old_p;
@@ -3104,7 +3104,7 @@
 
       if ( char_code < start )
         max = mid;
-      else if ( char_code > start+cnt )
+      else if ( char_code > start + cnt )
         min = mid + 1;
       else
         return TRUE;
diff --git src/sfnt/ttpost.c src/sfnt/ttpost.c
index f228f62..3277f1e 100644
--- src/sfnt/ttpost.c
+++ src/sfnt/ttpost.c
@@ -2,7 +2,7 @@
 /*                                                                         */
 /*  ttpost.c                                                               */
 /*                                                                         */
-/*    Postcript name table processing for TrueType and OpenType fonts      */
+/*    PostScript name table processing for TrueType and OpenType fonts     */
 /*    (body).                                                              */
 /*                                                                         */
 /*  Copyright 1996-2016 by                                                 */
diff --git src/sfnt/ttpost.h src/sfnt/ttpost.h
index 93762b0..ede45fd 100644
--- src/sfnt/ttpost.h
+++ src/sfnt/ttpost.h
@@ -2,7 +2,7 @@
 /*                                                                         */
 /*  ttpost.h                                                               */
 /*                                                                         */
-/*    Postcript name table processing for TrueType and OpenType fonts      */
+/*    PostScript name table processing for TrueType and OpenType fonts     */
 /*    (specification).                                                     */
 /*                                                                         */
 /*  Copyright 1996-2016 by                                                 */
diff --git src/smooth/ftgrays.c src/smooth/ftgrays.c
index dac332d..885b0df 100644
--- src/smooth/ftgrays.c
+++ src/smooth/ftgrays.c
@@ -320,17 +320,17 @@ typedef ptrdiff_t  FT_PtrDist;
 
 #define ONE_PIXEL       ( 1L << PIXEL_BITS )
 #define TRUNC( x )      ( (TCoord)( (x) >> PIXEL_BITS ) )
-#define SUBPIXELS( x )  ( (TPos)(x) << PIXEL_BITS )
+#define SUBPIXELS( x )  ( (TPos)(x) * ONE_PIXEL )
 #define FLOOR( x )      ( (x) & -ONE_PIXEL )
 #define CEILING( x )    ( ( (x) + ONE_PIXEL - 1 ) & -ONE_PIXEL )
 #define ROUND( x )      ( ( (x) + ONE_PIXEL / 2 ) & -ONE_PIXEL )
 
 #if PIXEL_BITS >= 6
-#define UPSCALE( x )    ( (x) << ( PIXEL_BITS - 6 ) )
+#define UPSCALE( x )    ( (x) * ( ONE_PIXEL >> 6 ) )
 #define DOWNSCALE( x )  ( (x) >> ( PIXEL_BITS - 6 ) )
 #else
 #define UPSCALE( x )    ( (x) >> ( 6 - PIXEL_BITS ) )
-#define DOWNSCALE( x )  ( (x) << ( 6 - PIXEL_BITS ) )
+#define DOWNSCALE( x )  ( (x) * ( 64 >> PIXEL_BITS ) )
 #endif
 
 
@@ -388,25 +388,7 @@ typedef ptrdiff_t  FT_PtrDist;
 
   typedef long  TCoord;   /* integer scanline/pixel coordinate */
   typedef long  TPos;     /* sub-pixel coordinate              */
-
-  /* determine the type used to store cell areas.  This normally takes at */
-  /* least PIXEL_BITS*2 + 1 bits.  On 16-bit systems, we need to use      */
-  /* `long' instead of `int', otherwise bad things happen                 */
-
-#if PIXEL_BITS <= 7
-
-  typedef int  TArea;
-
-#else /* PIXEL_BITS >= 8 */
-
-  /* approximately determine the size of integers using an ANSI-C header */
-#if FT_UINT_MAX == 0xFFFFU
-  typedef long  TArea;
-#else
-  typedef int   TArea;
-#endif
-
-#endif /* PIXEL_BITS >= 8 */
+  typedef long  TArea;    /* cell areas, coordinate products   */
 
 
   /* maximum number of gray spans in a call to the span callback */
@@ -689,7 +671,7 @@ typedef ptrdiff_t  FT_PtrDist;
     gray_set_cell( RAS_VAR_ ex, ey );
   }
 
-#if 0
+#if 1
 
   /*************************************************************************/
   /*                                                                       */
@@ -707,12 +689,8 @@ typedef ptrdiff_t  FT_PtrDist;
     int     incr;
 
 
-    dx = x2 - x1;
-
     ex1 = TRUNC( x1 );
     ex2 = TRUNC( x2 );
-    fx1 = (TCoord)( x1 - SUBPIXELS( ex1 ) );
-    fx2 = (TCoord)( x2 - SUBPIXELS( ex2 ) );
 
     /* trivial case.  Happens often */
     if ( y1 == y2 )
@@ -721,6 +699,9 @@ typedef ptrdiff_t  FT_PtrDist;
       return;
     }
 
+    fx1 = (TCoord)( x1 - SUBPIXELS( ex1 ) );
+    fx2 = (TCoord)( x2 - SUBPIXELS( ex2 ) );
+
     /* everything is located in a single cell.  That is easy! */
     /*                                                        */
     if ( ex1 == ex2 )
@@ -737,6 +718,7 @@ typedef ptrdiff_t  FT_PtrDist;
     p     = ( ONE_PIXEL - fx1 ) * ( y2 - y1 );
     first = ONE_PIXEL;
     incr  = 1;
+    dx    = x2 - x1;
 
     if ( dx < 0 )
     {
@@ -805,17 +787,15 @@ typedef ptrdiff_t  FT_PtrDist;
 
     ey1 = TRUNC( ras.y );
     ey2 = TRUNC( to_y );     /* if (ey2 >= ras.max_ey) ey2 = ras.max_ey-1; */
-    fy1 = (TCoord)( ras.y - SUBPIXELS( ey1 ) );
-    fy2 = (TCoord)( to_y - SUBPIXELS( ey2 ) );
-
-    dx = to_x - ras.x;
-    dy = to_y - ras.y;
 
     /* perform vertical clipping */
     if ( ( ey1 >= ras.max_ey && ey2 >= ras.max_ey ) ||
          ( ey1 <  ras.min_ey && ey2 <  ras.min_ey ) )
       goto End;
 
+    fy1 = (TCoord)( ras.y - SUBPIXELS( ey1 ) );
+    fy2 = (TCoord)( to_y - SUBPIXELS( ey2 ) );
+
     /* everything is on a single scanline */
     if ( ey1 == ey2 )
     {
@@ -823,6 +803,9 @@ typedef ptrdiff_t  FT_PtrDist;
       goto End;
     }
 
+    dx = to_x - ras.x;
+    dy = to_y - ras.y;
+
     /* vertical line - avoid calling gray_render_scanline */
     incr = 1;
 
@@ -936,8 +919,6 @@ typedef ptrdiff_t  FT_PtrDist;
     TCoord  ex1, ex2, ey1, ey2;
 
 
-    ex1 = TRUNC( ras.x );
-    ex2 = TRUNC( to_x );
     ey1 = TRUNC( ras.y );
     ey2 = TRUNC( to_y );
 
@@ -946,12 +927,15 @@ typedef ptrdiff_t  FT_PtrDist;
          ( ey1 <  ras.min_ey && ey2 <  ras.min_ey ) )
       goto End;
 
-    dx = to_x - ras.x;
-    dy = to_y - ras.y;
+    ex1 = TRUNC( ras.x );
+    ex2 = TRUNC( to_x );
 
     fx1 = ras.x - SUBPIXELS( ex1 );
     fy1 = ras.y - SUBPIXELS( ey1 );
 
+    dx = to_x - ras.x;
+    dy = to_y - ras.y;
+
     if ( ex1 == ex2 && ey1 == ey2 )       /* inside one cell */
       ;
     else if ( dy == 0 ) /* ex1 != ex2 */  /* any horizontal line */
@@ -1081,25 +1065,14 @@ typedef ptrdiff_t  FT_PtrDist;
 
 
   static void
-  gray_render_conic( RAS_ARG_ const FT_Vector*  control,
-                              const FT_Vector*  to )
+  gray_render_conic( RAS_ARG )
   {
     TPos        dx, dy;
-    TPos        min, max, y;
     int         top, level;
-    int*        levels;
-    FT_Vector*  arc;
-
+    int*        levels = ras.lev_stack;
+    FT_Vector*  arc = ras.bez_stack;
 
-    levels = ras.lev_stack;
 
-    arc      = ras.bez_stack;
-    arc[0].x = UPSCALE( to->x );
-    arc[0].y = UPSCALE( to->y );
-    arc[1].x = UPSCALE( control->x );
-    arc[1].y = UPSCALE( control->y );
-    arc[2].x = ras.x;
-    arc[2].y = ras.y;
     top      = 0;
 
     dx = FT_ABS( arc[2].x + arc[0].x - 2 * arc[1].x );
@@ -1110,20 +1083,8 @@ typedef ptrdiff_t  FT_PtrDist;
     if ( dx < ONE_PIXEL / 4 )
       goto Draw;
 
-    /* short-cut the arc that crosses the current band */
-    min = max = arc[0].y;
-
-    y = arc[1].y;
-    if ( y < min ) min = y;
-    if ( y > max ) max = y;
-
-    y = arc[2].y;
-    if ( y < min ) min = y;
-    if ( y > max ) max = y;
-
-    if ( TRUNC( min ) >= ras.max_ey || TRUNC( max ) < ras.min_ey )
-      goto Draw;
-
+    /* we can calculate the number of necessary bisections because  */
+    /* each bisection predictably reduces deviation at least 4-fold */
     level = 0;
     do
     {
@@ -1183,47 +1144,13 @@ typedef ptrdiff_t  FT_PtrDist;
 
 
   static void
-  gray_render_cubic( RAS_ARG_ const FT_Vector*  control1,
-                              const FT_Vector*  control2,
-                              const FT_Vector*  to )
+  gray_render_cubic( RAS_ARG )
   {
-    FT_Vector*  arc;
-    TPos        min, max, y;
-
-
-    arc      = ras.bez_stack;
-    arc[0].x = UPSCALE( to->x );
-    arc[0].y = UPSCALE( to->y );
-    arc[1].x = UPSCALE( control2->x );
-    arc[1].y = UPSCALE( control2->y );
-    arc[2].x = UPSCALE( control1->x );
-    arc[2].y = UPSCALE( control1->y );
-    arc[3].x = ras.x;
-    arc[3].y = ras.y;
+    FT_Vector*  arc = ras.bez_stack;
+    TPos        dx, dy, dx_, dy_;
+    TPos        dx1, dy1, dx2, dy2;
+    TPos        L, s, s_limit;
 
-    /* Short-cut the arc that crosses the current band. */
-    min = max = arc[0].y;
-
-    y = arc[1].y;
-    if ( y < min )
-      min = y;
-    if ( y > max )
-      max = y;
-
-    y = arc[2].y;
-    if ( y < min )
-      min = y;
-    if ( y > max )
-      max = y;
-
-    y = arc[3].y;
-    if ( y < min )
-      min = y;
-    if ( y > max )
-      max = y;
-
-    if ( TRUNC( min ) >= ras.max_ey || TRUNC( max ) < ras.min_ey )
-      goto Draw;
 
     for (;;)
     {
@@ -1232,64 +1159,53 @@ typedef ptrdiff_t  FT_PtrDist;
       /* F. Hain, at                                                      */
       /* http://www.cis.southalabama.edu/~hain/general/Publications/Bezier/Camera-ready%20CISST02%202.pdf */
 
-      {
-        TPos  dx, dy, dx_, dy_;
-        TPos  dx1, dy1, dx2, dy2;
-        TPos  L, s, s_limit;
-
+      /* dx and dy are x and y components of the P0-P3 chord vector. */
+      dx = dx_ = arc[3].x - arc[0].x;
+      dy = dy_ = arc[3].y - arc[0].y;
 
-        /* dx and dy are x and y components of the P0-P3 chord vector. */
-        dx = dx_ = arc[3].x - arc[0].x;
-        dy = dy_ = arc[3].y - arc[0].y;
+      L = FT_HYPOT( dx_, dy_ );
 
-        L = FT_HYPOT( dx_, dy_ );
+      /* Avoid possible arithmetic overflow below by splitting. */
+      if ( L > 32767 )
+        goto Split;
 
-        /* Avoid possible arithmetic overflow below by splitting. */
-        if ( L > 32767 )
-          goto Split;
+      /* Max deviation may be as much as (s/L) * 3/4 (if Hain's v = 1). */
+      s_limit = L * (TPos)( ONE_PIXEL / 6 );
 
-        /* Max deviation may be as much as (s/L) * 3/4 (if Hain's v = 1). */
-        s_limit = L * (TPos)( ONE_PIXEL / 6 );
+      /* s is L * the perpendicular distance from P1 to the line P0-P3. */
+      dx1 = arc[1].x - arc[0].x;
+      dy1 = arc[1].y - arc[0].y;
+      s = FT_ABS( dy * dx1 - dx * dy1 );
 
-        /* s is L * the perpendicular distance from P1 to the line P0-P3. */
-        dx1 = arc[1].x - arc[0].x;
-        dy1 = arc[1].y - arc[0].y;
-        s = FT_ABS( dy * dx1 - dx * dy1 );
+      if ( s > s_limit )
+        goto Split;
 
-        if ( s > s_limit )
-          goto Split;
+      /* s is L * the perpendicular distance from P2 to the line P0-P3. */
+      dx2 = arc[2].x - arc[0].x;
+      dy2 = arc[2].y - arc[0].y;
+      s = FT_ABS( dy * dx2 - dx * dy2 );
 
-        /* s is L * the perpendicular distance from P2 to the line P0-P3. */
-        dx2 = arc[2].x - arc[0].x;
-        dy2 = arc[2].y - arc[0].y;
-        s = FT_ABS( dy * dx2 - dx * dy2 );
+      if ( s > s_limit )
+        goto Split;
 
-        if ( s > s_limit )
-          goto Split;
-
-        /* Split super curvy segments where the off points are so far
-           from the chord that the angles P0-P1-P3 or P0-P2-P3 become
-           acute as detected by appropriate dot products. */
-        if ( dx1 * ( dx1 - dx ) + dy1 * ( dy1 - dy ) > 0 ||
-             dx2 * ( dx2 - dx ) + dy2 * ( dy2 - dy ) > 0 )
-          goto Split;
-
-        /* No reason to split. */
-        goto Draw;
-      }
-
-    Split:
-      gray_split_cubic( arc );
-      arc += 3;
-      continue;
+      /* Split super curvy segments where the off points are so far
+         from the chord that the angles P0-P1-P3 or P0-P2-P3 become
+         acute as detected by appropriate dot products. */
+      if ( dx1 * ( dx1 - dx ) + dy1 * ( dy1 - dy ) > 0 ||
+           dx2 * ( dx2 - dx ) + dy2 * ( dy2 - dy ) > 0 )
+        goto Split;
 
-    Draw:
       gray_render_line( RAS_VAR_ arc[0].x, arc[0].y );
 
       if ( arc == ras.bez_stack )
         return;
 
       arc -= 3;
+      continue;
+
+    Split:
+      gray_split_cubic( arc );
+      arc += 3;
     }
   }
 
@@ -1331,7 +1247,27 @@ typedef ptrdiff_t  FT_PtrDist;
                  const FT_Vector*  to,
                  gray_PWorker      worker )
   {
-    gray_render_conic( RAS_VAR_ control, to );
+    FT_Vector*  arc = ras.bez_stack;
+
+
+    arc[0].x = UPSCALE( to->x );
+    arc[0].y = UPSCALE( to->y );
+    arc[1].x = UPSCALE( control->x );
+    arc[1].y = UPSCALE( control->y );
+    arc[2].x = ras.x;
+    arc[2].y = ras.y;
+
+    /* short-cut the arc that crosses the current band */
+    if ( ( TRUNC( arc[0].y ) >= ras.max_ey &&
+           TRUNC( arc[1].y ) >= ras.max_ey &&
+           TRUNC( arc[2].y ) >= ras.max_ey ) ||
+         ( TRUNC( arc[0].y ) <  ras.min_ey &&
+           TRUNC( arc[1].y ) <  ras.min_ey &&
+           TRUNC( arc[2].y ) <  ras.min_ey ) )
+      gray_render_line( RAS_VAR_ arc[0].x, arc[0].y );
+    else
+      gray_render_conic( RAS_VAR );
+
     return 0;
   }
 
@@ -1342,7 +1278,31 @@ typedef ptrdiff_t  FT_PtrDist;
                  const FT_Vector*  to,
                  gray_PWorker      worker )
   {
-    gray_render_cubic( RAS_VAR_ control1, control2, to );
+    FT_Vector*  arc = ras.bez_stack;
+
+
+    arc[0].x = UPSCALE( to->x );
+    arc[0].y = UPSCALE( to->y );
+    arc[1].x = UPSCALE( control2->x );
+    arc[1].y = UPSCALE( control2->y );
+    arc[2].x = UPSCALE( control1->x );
+    arc[2].y = UPSCALE( control1->y );
+    arc[3].x = ras.x;
+    arc[3].y = ras.y;
+
+    /* short-cut the arc that crosses the current band */
+    if ( ( TRUNC( arc[0].y ) >= ras.max_ey &&
+           TRUNC( arc[1].y ) >= ras.max_ey &&
+           TRUNC( arc[2].y ) >= ras.max_ey &&
+           TRUNC( arc[3].y ) >= ras.max_ey ) ||
+         ( TRUNC( arc[0].y ) <  ras.min_ey &&
+           TRUNC( arc[1].y ) <  ras.min_ey &&
+           TRUNC( arc[2].y ) <  ras.min_ey &&
+           TRUNC( arc[3].y ) <  ras.min_ey ) )
+      gray_render_line( RAS_VAR_ arc[0].x, arc[0].y );
+    else
+      gray_render_cubic( RAS_VAR );
+
     return 0;
   }
 
@@ -1521,7 +1481,8 @@ typedef ptrdiff_t  FT_PtrDist;
       printf( "%3d:", yindex );
 
       for ( cell = ras.ycells[yindex]; cell != NULL; cell = cell->next )
-        printf( " (%3ld, c:%4ld, a:%6d)", cell->x, cell->cover, cell->area );
+        printf( " (%3ld, c:%4ld, a:%6ld)",
+                cell->x, cell->cover, cell->area );
       printf( "\n" );
     }
   }
@@ -2066,7 +2027,7 @@ typedef ptrdiff_t  FT_PtrDist;
 
 
   static int
-  gray_raster_render( gray_PRaster             raster,
+  gray_raster_render( FT_Raster                raster,
                       const FT_Raster_Params*  params )
   {
     const FT_Outline*  outline     = (const FT_Outline*)params->source;
@@ -2115,6 +2076,20 @@ typedef ptrdiff_t  FT_PtrDist;
     if ( !( params->flags & FT_RASTER_FLAG_AA ) )
       return FT_THROW( Invalid_Mode );
 
+    /* reject too large outline coordinates */
+    {
+      FT_Vector*  vec   = outline->points;
+      FT_Vector*  limit = vec + outline->n_points;
+
+
+      for ( ; vec < limit; vec++ )
+      {
+        if ( vec->x < -0x1000000L || vec->x > 0x1000000L ||
+             vec->y < -0x1000000L || vec->y > 0x1000000L )
+         return FT_THROW( Invalid_Outline );
+      }
+    }
+
     /* compute clipping box */
     if ( !( params->flags & FT_RASTER_FLAG_DIRECT ) )
     {
@@ -2221,9 +2196,9 @@ typedef ptrdiff_t  FT_PtrDist;
 
 
   static void
-  gray_raster_reset( FT_Raster  raster,
-                     char*      pool_base,
-                     long       pool_size )
+  gray_raster_reset( FT_Raster       raster,
+                     unsigned char*  pool_base,
+                     unsigned long   pool_size )
   {
     FT_UNUSED( raster );
     FT_UNUSED( pool_base );
diff --git src/tools/docmaker/tohtml.py src/tools/docmaker/tohtml.py
index 8da10b8..9b28780 100644
--- src/tools/docmaker/tohtml.py
+++ src/tools/docmaker/tohtml.py
@@ -390,7 +390,7 @@ class  HtmlFormatter( Formatter ):
         """Convert a code sequence to HTML."""
         line = code_header + '\n'
         for l in lines:
-            line = line + html_quote( l ) + '\n'
+            line = line + html_quote( l ).rstrip() + '\n'
 
         return line + code_footer
 
diff --git src/tools/ftfuzzer/ftfuzzer.cc src/tools/ftfuzzer/ftfuzzer.cc
index 7df7abc..39f2b39 100644
--- src/tools/ftfuzzer/ftfuzzer.cc
+++ src/tools/ftfuzzer/ftfuzzer.cc
@@ -161,7 +161,7 @@
                     variations->axis[i].def     ) / 2;
 
     if ( FT_Set_Var_Design_Coordinates( face,
-                                        coords.size(),
+                                        FT_UInt( coords.size() ),
                                         coords.data() ) )
       return;
   }
@@ -248,7 +248,7 @@
 
         // loop over all bitmap stroke sizes
         // and an arbitrary size for outlines
-        for ( long  fixed_sizes_index = 0;
+        for ( int  fixed_sizes_index = 0;
               fixed_sizes_index < face->num_fixed_sizes + 1;
               fixed_sizes_index++ )
         {
diff --git src/tools/ftfuzzer/rasterfuzzer.cc src/tools/ftfuzzer/rasterfuzzer.cc
new file mode 100644
index 0000000..05187b0
--- /dev/null
+++ src/tools/ftfuzzer/rasterfuzzer.cc
@@ -0,0 +1,129 @@
+// rasterfuzzer.cc
+//
+//   A fuzzing function to test FreeType's rasterizers with libFuzzer.
+//
+// Copyright 2016 by
+// David Turner, Robert Wilhelm, and Werner Lemberg.
+//
+// This file is part of the FreeType project, and may only be used,
+// modified, and distributed under the terms of the FreeType project
+// license, LICENSE.TXT.  By continuing to use, modify, or distribute
+// this file you indicate that you have read the license and
+// understand and accept it fully.
+
+
+#include <stdint.h>
+
+#include <vector>
+
+
+  using namespace std;
+
+
+#include <ft2build.h>
+
+#include FT_FREETYPE_H
+#include FT_IMAGE_H
+#include FT_OUTLINE_H
+
+
+  static FT_Library  library;
+  static int         InitResult;
+
+
+  struct FT_Global {
+    FT_Global() {
+      InitResult = FT_Init_FreeType( &library );
+    }
+    ~FT_Global() {
+      FT_Done_FreeType( library );
+    }
+  };
+
+  FT_Global  global_ft;
+
+
+  extern "C" int
+  LLVMFuzzerTestOneInput( const uint8_t*  data,
+                          size_t          size_ )
+  {
+    unsigned char  pixels[4];
+
+    FT_Bitmap  bitmap_mono = {
+      1,                  // rows
+      1,                  // width
+      4,                  // pitch
+      pixels,             // buffer
+      2,                  // num_grays
+      FT_PIXEL_MODE_MONO, // pixel_mode
+      0,                  // palette_mode
+      NULL                // palette
+    };
+
+    FT_Bitmap  bitmap_gray = {
+      1,                  // rows
+      1,                  // width
+      4,                  // pitch
+      pixels,             // buffer
+      256,                // num_grays
+      FT_PIXEL_MODE_GRAY, // pixel_mode
+      0,                  // palette_mode
+      NULL                // palette
+    };
+
+    const size_t vsize = sizeof ( FT_Vector );
+    const size_t tsize = sizeof ( char );
+
+    // we use the input data for both points and tags
+    short  n_points = short( size_ / ( vsize + tsize ) );
+    if ( n_points <= 2 )
+      return 0;
+
+    FT_Vector*  points = reinterpret_cast<FT_Vector*>(
+                           const_cast<uint8_t*>(
+                             data ) );
+    char*       tags   = reinterpret_cast<char*>(
+                           const_cast<uint8_t*>(
+                             data + size_t( n_points ) * vsize ) );
+
+    // to reduce the number of invalid outlines that are immediately
+    // rejected in `FT_Outline_Render', limit values to 2^18 pixels
+    // (i.e., 2^24 bits)
+    for ( short  i = 0; i < n_points; i++ )
+    {
+      if ( points[i].x == LONG_MIN )
+        points[i].x = 0;
+      else if ( points[i].x < 0 )
+        points[i].x = -( -points[i].x & 0xFFFFFF ) - 1;
+      else
+        points[i].x = ( points[i].x & 0xFFFFFF ) + 1;
+
+      if ( points[i].y == LONG_MIN )
+        points[i].y = 0;
+      else if ( points[i].y < 0 )
+        points[i].y = -( -points[i].y & 0xFFFFFF ) - 1;
+      else
+        points[i].y = ( points[i].y & 0xFFFFFF ) + 1;
+    }
+
+    short  contours[1];
+    contours[0] = n_points - 1;
+
+    FT_Outline  outline =
+    {
+      1,               // n_contours
+      n_points,        // n_points
+      points,          // points
+      tags,            // tags
+      contours,        // contours
+      FT_OUTLINE_NONE  // flags
+    };
+
+    FT_Outline_Get_Bitmap( library, &outline, &bitmap_mono );
+    FT_Outline_Get_Bitmap( library, &outline, &bitmap_gray );
+
+    return 0;
+  }
+
+
+// END
diff --git src/tools/ftfuzzer/runinput.cc src/tools/ftfuzzer/runinput.cc
index 8fa75ad..d5f9f15 100644
--- src/tools/ftfuzzer/runinput.cc
+++ src/tools/ftfuzzer/runinput.cc
@@ -1,6 +1,6 @@
 // runinput.cc
 //
-//   A `main' function for `ftfuzzer.cc'.
+//   A `main' function for fuzzers like `ftfuzzer.cc'.
 //
 // Copyright 2015-2016 by
 // David Turner, Robert Wilhelm, and Werner Lemberg.
diff --git src/truetype/ttgload.c src/truetype/ttgload.c
index 4ab6603..d1cb357 100644
--- src/truetype/ttgload.c
+++ src/truetype/ttgload.c
@@ -427,7 +427,8 @@
       load->glyph->control_len  = n_ins;
       load->glyph->control_data = load->exec->glyphIns;
 
-      FT_MEM_COPY( load->exec->glyphIns, p, (FT_Long)n_ins );
+      if ( n_ins )
+        FT_MEM_COPY( load->exec->glyphIns, p, (FT_Long)n_ins );
     }
 
 #endif /* TT_USE_BYTECODE_INTERPRETER */
diff --git src/truetype/ttgxvar.c src/truetype/ttgxvar.c
index 5f760a2..9a02c5a 100644
--- src/truetype/ttgxvar.c
+++ src/truetype/ttgxvar.c
@@ -551,7 +551,7 @@
       for ( i = 0; i < blend->tuplecount; i++ )
       {
         FT_TRACE5(( "  [ " ));
-        for ( j = 0 ; j < (FT_UInt)gvar_head.axisCount; j++ )
+        for ( j = 0; j < (FT_UInt)gvar_head.axisCount; j++ )
         {
           blend->tuplecoords[i * gvar_head.axisCount + j] =
             FT_GET_SHORT() * 4;                 /* convert to FT_Fixed */
@@ -613,6 +613,11 @@
     {
       FT_TRACE6(( "    axis coordinate %d (%.4f):\n",
                   i, blend->normalizedcoords[i] / 65536.0 ));
+      if ( !( tupleIndex & GX_TI_INTERMEDIATE_TUPLE ) )
+        FT_TRACE6(( "      intermediate coordinates %d (%.4f, %.4f):\n",
+                    i,
+                    im_start_coords[i] / 65536.0,
+                    im_end_coords[i] / 65536.0 ));
 
       /* It's not clear why (for intermediate tuples) we don't need     */
       /* to check against start/end -- the documentation says we don't. */
@@ -625,62 +630,74 @@
         continue;
       }
 
-      else if ( blend->normalizedcoords[i] == 0 )
+      if ( blend->normalizedcoords[i] == 0 )
       {
         FT_TRACE6(( "      axis coordinate is zero, stop\n" ));
         apply = 0;
         break;
       }
 
-      else if ( ( blend->normalizedcoords[i] < 0 && tuple_coords[i] > 0 ) ||
-                ( blend->normalizedcoords[i] > 0 && tuple_coords[i] < 0 ) )
+      if ( blend->normalizedcoords[i] == tuple_coords[i] )
       {
-        FT_TRACE6(( "      tuple coordinate value %.4f is exceeded, stop\n",
+        FT_TRACE6(( "      tuple coordinate value %.4f fits perfectly\n",
                     tuple_coords[i] / 65536.0 ));
-        apply = 0;
-        break;
+        /* `apply' does not change */
+        continue;
       }
 
-      else if ( !( tupleIndex & GX_TI_INTERMEDIATE_TUPLE ) )
+      if ( !( tupleIndex & GX_TI_INTERMEDIATE_TUPLE ) )
       {
-        FT_TRACE6(( "      tuple coordinate value %.4f fits\n",
-                    tuple_coords[i] / 65536.0 ));
         /* not an intermediate tuple */
-        apply = FT_MulFix( apply,
-                           blend->normalizedcoords[i] > 0
-                             ? blend->normalizedcoords[i]
-                             : -blend->normalizedcoords[i] );
-      }
 
-      else if ( blend->normalizedcoords[i] < im_start_coords[i] ||
-                blend->normalizedcoords[i] > im_end_coords[i]   )
-      {
-        FT_TRACE6(( "      intermediate tuple range [%.4f;%.4f] is exceeded,"
-                    " stop\n",
-                    im_start_coords[i] / 65536.0,
-                    im_end_coords[i] / 65536.0 ));
-        apply = 0;
-        break;
-      }
+        if ( blend->normalizedcoords[i] < FT_MIN( 0, tuple_coords[i] ) ||
+             blend->normalizedcoords[i] > FT_MAX( 0, tuple_coords[i] ) )
+        {
+          FT_TRACE6(( "      tuple coordinate value %.4f is exceeded, stop\n",
+                      tuple_coords[i] / 65536.0 ));
+          apply = 0;
+          break;
+        }
 
-      else if ( blend->normalizedcoords[i] < tuple_coords[i] )
-      {
-        FT_TRACE6(( "      intermediate tuple range [%.4f;%.4f] fits\n",
-                    im_start_coords[i] / 65536.0,
-                    im_end_coords[i] / 65536.0 ));
+        FT_TRACE6(( "      tuple coordinate value %.4f fits\n",
+                    tuple_coords[i] / 65536.0 ));
         apply = FT_MulDiv( apply,
-                           blend->normalizedcoords[i] - im_start_coords[i],
-                           tuple_coords[i] - im_start_coords[i] );
+                           blend->normalizedcoords[i],
+                           tuple_coords[i] );
       }
-
       else
       {
-        FT_TRACE6(( "      intermediate tuple range [%.4f;%.4f] fits\n",
-                    im_start_coords[i] / 65536.0,
-                    im_end_coords[i] / 65536.0 ));
-        apply = FT_MulDiv( apply,
-                           im_end_coords[i] - blend->normalizedcoords[i],
-                           im_end_coords[i] - tuple_coords[i] );
+        /* intermediate tuple */
+
+        if ( blend->normalizedcoords[i] < im_start_coords[i] ||
+             blend->normalizedcoords[i] > im_end_coords[i]   )
+        {
+          FT_TRACE6(( "      intermediate tuple range [%.4f;%.4f] is exceeded,"
+                      " stop\n",
+                      im_start_coords[i] / 65536.0,
+                      im_end_coords[i] / 65536.0 ));
+          apply = 0;
+          break;
+        }
+
+        else if ( blend->normalizedcoords[i] < tuple_coords[i] )
+        {
+          FT_TRACE6(( "      intermediate tuple range [%.4f;%.4f] fits\n",
+                      im_start_coords[i] / 65536.0,
+                      im_end_coords[i] / 65536.0 ));
+          apply = FT_MulDiv( apply,
+                             blend->normalizedcoords[i] - im_start_coords[i],
+                             tuple_coords[i] - im_start_coords[i] );
+        }
+
+        else
+        {
+          FT_TRACE6(( "      intermediate tuple range [%.4f;%.4f] fits\n",
+                      im_start_coords[i] / 65536.0,
+                      im_end_coords[i] / 65536.0 ));
+          apply = FT_MulDiv( apply,
+                             im_end_coords[i] - blend->normalizedcoords[i],
+                             im_end_coords[i] - tuple_coords[i] );
+        }
       }
     }
 
diff --git src/truetype/ttinterp.c src/truetype/ttinterp.c
index ccbb1d7..78c35f2 100644
--- src/truetype/ttinterp.c
+++ src/truetype/ttinterp.c
@@ -1561,7 +1561,7 @@
   static FT_Short
   GetShortIns( TT_ExecContext  exc )
   {
-    /* Reading a byte stream so there is no endianess (DaveP) */
+    /* Reading a byte stream so there is no endianness (DaveP) */
     exc->IP += 2;
     return (FT_Short)( ( exc->code[exc->IP - 2] << 8 ) +
                          exc->code[exc->IP - 1]      );
diff --git src/truetype/ttobjs.c src/truetype/ttobjs.c
index cd4e294..a05f216 100644
--- src/truetype/ttobjs.c
+++ src/truetype/ttobjs.c
@@ -398,11 +398,11 @@
     for ( j = 0; j < TRICK_SFNT_IDS_NUM_FACES; j++ )
     {
       if ( !has_cvt  && !sfnt_id[j][TRICK_SFNT_ID_cvt].Length )
-        num_matched_ids[j] ++;
+        num_matched_ids[j]++;
       if ( !has_fpgm && !sfnt_id[j][TRICK_SFNT_ID_fpgm].Length )
-        num_matched_ids[j] ++;
+        num_matched_ids[j]++;
       if ( !has_prep && !sfnt_id[j][TRICK_SFNT_ID_prep].Length )
-        num_matched_ids[j] ++;
+        num_matched_ids[j]++;
       if ( num_matched_ids[j] == TRICK_SFNT_IDS_PER_FACE )
         return TRUE;
     }
diff --git src/type1/t1afm.c src/type1/t1afm.c
index 3c7735d..bbd843c 100644
--- src/type1/t1afm.c
+++ src/type1/t1afm.c
@@ -197,7 +197,7 @@
     /*   encoding of first glyph (1 byte)     */
     /*   encoding of second glyph (1 byte)    */
     /*   offset (little-endian short)         */
-    for ( ; p < limit ; p += 4 )
+    for ( ; p < limit; p += 4 )
     {
       kp->index1 = FT_Get_Char_Index( t1_face, p[0] );
       kp->index2 = FT_Get_Char_Index( t1_face, p[1] );
diff --git src/type1/t1load.c src/type1/t1load.c
index a53037c..ccf00b4 100644
--- src/type1/t1load.c
+++ src/type1/t1load.c
@@ -326,7 +326,7 @@
                                       /* Point to axes after MM_Var struct */
     mmvar->namedstyle      = NULL;
 
-    for ( i = 0 ; i < mmaster.num_axis; ++i )
+    for ( i = 0; i < mmaster.num_axis; ++i )
     {
       mmvar->axis[i].name    = mmaster.axis[i].name;
       mmvar->axis[i].minimum = INT_TO_FIXED( mmaster.axis[i].minimum);
diff --git src/type1/t1objs.c src/type1/t1objs.c
index f553f86..a009117 100644
--- src/type1/t1objs.c
+++ src/type1/t1objs.c
@@ -67,7 +67,7 @@
                             "pshinter" );
     return ( module && pshinter && pshinter->get_globals_funcs )
            ? pshinter->get_globals_funcs( module )
-           : 0 ;
+           : 0;
   }
 
 
diff --git vms_make.com vms_make.com
index e5a4928..be8c615 100644
--- vms_make.com
+++ vms_make.com
@@ -1090,13 +1090,13 @@ $   type/out=vmslib.dat sys$input
 !          might look like. They are site specific and the locations of the
 !          library and include files need almost certainly to be changed.
 !
-! Location: All of the libaries can be found at the following addresses
+! Location: All of the libraries can be found at the following addresses
 !
 !   ZLIB:     http://zinser.no-ip.info/vms/sw/zlib.htmlx
 !
 ZLIB # sys$library:libz.olb # sys$library: # zlib.h # FT_CONFIG_OPTION_SYSTEM_ZLIB
 $   write sys$output "New driver file vmslib.dat created."
-$   write sys$output "Please customize libary locations for your site"
+$   write sys$output "Please customize library locations for your site"
 $   write sys$output "and afterwards re-execute ''myproc'"
 $   goto err_exit
 $ endif
