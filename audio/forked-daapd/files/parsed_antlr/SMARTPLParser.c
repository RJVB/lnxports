/** \file
 *  This C source file was generated by $ANTLR version 3.2 debian-7ubuntu3
 *
 *     -  From the grammar source file : SMARTPL.g
 *     -                            On : 2020-05-28 00:12:27
 *     -                for the parser : SMARTPLParserParser *
 * Editing it, at least manually, is not wise. 
 *
 * C language generator and runtime by Jim Idle, jimi|hereisanat|idle|dotgoeshere|ws.
 *
 *
*/
// [The "BSD licence"]
// Copyright (c) 2005-2009 Jim Idle, Temporal Wave LLC
// http://www.temporal-wave.com
// http://www.linkedin.com/in/jimidle
//
// All rights reserved.
//
// Redistribution and use in source and binary forms, with or without
// modification, are permitted provided that the following conditions
// are met:
// 1. Redistributions of source code must retain the above copyright
//    notice, this list of conditions and the following disclaimer.
// 2. Redistributions in binary form must reproduce the above copyright
//    notice, this list of conditions and the following disclaimer in the
//    documentation and/or other materials provided with the distribution.
// 3. The name of the author may not be used to endorse or promote products
//    derived from this software without specific prior written permission.
//
// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

/* -----------------------------------------
 * Include the ANTLR3 generated header file.
 */
#include    "SMARTPLParser.h"
/* ----------------------------------------- */





/* MACROS that hide the C interface implementations from the
 * generated code, which makes it a little more understandable to the human eye.
 * I am very much against using C pre-processor macros for function calls and bits
 * of code as you cannot see what is happening when single stepping in debuggers
 * and so on. The exception (in my book at least) is for generated code, where you are
 * not maintaining it, but may wish to read and understand it. If you single step it, you know that input()
 * hides some indirect calls, but is always referring to the input stream. This is
 * probably more readable than ctx->input->istream->input(snarfle0->blarg) and allows me to rejig
 * the runtime interfaces without changing the generated code too often, without
 * confusing the reader of the generated output, who may not wish to know the gory
 * details of the interface inheritance.
 */
 
#define		CTX	ctx

/* Aids in accessing scopes for grammar programmers
 */
#undef	SCOPE_TYPE
#undef	SCOPE_STACK
#undef	SCOPE_TOP
#define	SCOPE_TYPE(scope)   pSMARTPLParser_##scope##_SCOPE
#define SCOPE_STACK(scope)  pSMARTPLParser_##scope##Stack
#define	SCOPE_TOP(scope)    ctx->pSMARTPLParser_##scope##Top
#define	SCOPE_SIZE(scope)		ctx->pSMARTPLParser_##scope##Stack_limit
#define SCOPE_INSTANCE(scope, i)	(ctx->SCOPE_STACK(scope)->get(ctx->SCOPE_STACK(scope),i))

/* Macros for accessing things in the parser
 */
 
#undef	    PARSER		    
#undef	    RECOGNIZER		    
#undef	    HAVEPARSEDRULE
#undef		MEMOIZE
#undef	    INPUT
#undef	    STRSTREAM
#undef	    HASEXCEPTION
#undef	    EXCEPTION
#undef	    MATCHT
#undef	    MATCHANYT
#undef	    FOLLOWSTACK
#undef	    FOLLOWPUSH
#undef	    FOLLOWPOP
#undef	    PRECOVER
#undef	    PREPORTERROR
#undef	    LA
#undef	    LT
#undef	    CONSTRUCTEX
#undef	    CONSUME
#undef	    MARK
#undef	    REWIND
#undef	    REWINDLAST
#undef	    PERRORRECOVERY
#undef	    HASFAILED
#undef	    FAILEDFLAG
#undef	    RECOVERFROMMISMATCHEDSET
#undef	    RECOVERFROMMISMATCHEDELEMENT
#undef		INDEX
#undef      ADAPTOR
#undef		SEEK
#undef	    RULEMEMO		    
#undef		DBG

#define	    PARSER							ctx->pParser  
#define	    RECOGNIZER						PARSER->rec
#define		PSRSTATE						RECOGNIZER->state
#define	    HAVEPARSEDRULE(r)				RECOGNIZER->alreadyParsedRule(RECOGNIZER, r)
#define		MEMOIZE(ri,si)					RECOGNIZER->memoize(RECOGNIZER, ri, si)
#define	    INPUT							PARSER->tstream
#define	    STRSTREAM						INPUT
#define		ISTREAM							INPUT->istream
#define		INDEX()							ISTREAM->index(INPUT->istream)
#define	    HASEXCEPTION()					(PSRSTATE->error == ANTLR3_TRUE)
#define	    EXCEPTION						PSRSTATE->exception
#define	    MATCHT(t, fs)					RECOGNIZER->match(RECOGNIZER, t, fs)
#define	    MATCHANYT()						RECOGNIZER->matchAny(RECOGNIZER)
#define	    FOLLOWSTACK					    PSRSTATE->following
#define	    FOLLOWPUSH(x)					FOLLOWSTACK->push(FOLLOWSTACK, ((void *)(&(x))), NULL)
#define	    FOLLOWPOP()						FOLLOWSTACK->pop(FOLLOWSTACK)
#define	    PRECOVER()						RECOGNIZER->recover(RECOGNIZER)
#define	    PREPORTERROR()					RECOGNIZER->reportError(RECOGNIZER)
#define	    LA(n)							INPUT->istream->_LA(ISTREAM, n)
#define	    LT(n)							INPUT->_LT(INPUT, n)
#define	    CONSTRUCTEX()					RECOGNIZER->exConstruct(RECOGNIZER)
#define	    CONSUME()						ISTREAM->consume(ISTREAM)
#define	    MARK()							ISTREAM->mark(ISTREAM)
#define	    REWIND(m)						ISTREAM->rewind(ISTREAM, m)
#define	    REWINDLAST()					ISTREAM->rewindLast(ISTREAM)
#define		SEEK(n)							ISTREAM->seek(ISTREAM, n)
#define	    PERRORRECOVERY					PSRSTATE->errorRecovery
#define	    FAILEDFLAG						PSRSTATE->failed
#define	    HASFAILED()						(FAILEDFLAG == ANTLR3_TRUE)
#define	    BACKTRACKING					PSRSTATE->backtracking
#define	    RECOVERFROMMISMATCHEDSET(s)		RECOGNIZER->recoverFromMismatchedSet(RECOGNIZER, s)
#define	    RECOVERFROMMISMATCHEDELEMENT(e)	RECOGNIZER->recoverFromMismatchedElement(RECOGNIZER, s)
#define     ADAPTOR                         ctx->adaptor
#define		RULEMEMO						PSRSTATE->ruleMemo
#define		DBG								RECOGNIZER->debugger

#define		TOKTEXT(tok, txt)				tok, (pANTLR3_UINT8)txt

/* The 4 tokens defined below may well clash with your own #defines or token types. If so
 * then for the present you must use different names for your defines as these are hard coded
 * in the code generator. It would be better not to use such names internally, and maybe
 * we can change this in a forthcoming release. I deliberately do not #undef these
 * here as this will at least give you a redefined error somewhere if they clash.
 */
#define	    UP	    ANTLR3_TOKEN_UP
#define	    DOWN    ANTLR3_TOKEN_DOWN
#define	    EOR	    ANTLR3_TOKEN_EOR
#define	    INVALID ANTLR3_TOKEN_INVALID


/* =============================================================================
 * Functions to create and destroy scopes. First come the rule scopes, followed
 * by the global declared scopes.
 */



/* ============================================================================= */

/* =============================================================================
 * Start of recognizer
 */



/** \brief Table of all token names in symbolic order, mainly used for
 *         error reporting.
 */
pANTLR3_UINT8   SMARTPLParserTokenNames[36+4]
     = {
        (pANTLR3_UINT8) "<invalid>",       /* String to print to indicate an invalid token */
        (pANTLR3_UINT8) "<EOR>",
        (pANTLR3_UINT8) "<DOWN>", 
        (pANTLR3_UINT8) "<UP>", 
        (pANTLR3_UINT8) "STR",
        (pANTLR3_UINT8) "OR",
        (pANTLR3_UINT8) "HAVING",
        (pANTLR3_UINT8) "ORDERBY",
        (pANTLR3_UINT8) "LIMIT",
        (pANTLR3_UINT8) "SORTDIR",
        (pANTLR3_UINT8) "STRTAG",
        (pANTLR3_UINT8) "INTTAG",
        (pANTLR3_UINT8) "DATETAG",
        (pANTLR3_UINT8) "ENUMTAG",
        (pANTLR3_UINT8) "XXX",
        (pANTLR3_UINT8) "NeverUsedRule",
        (pANTLR3_UINT8) "INT",
        (pANTLR3_UINT8) "AND",
        (pANTLR3_UINT8) "NOT",
        (pANTLR3_UINT8) "LPAR",
        (pANTLR3_UINT8) "RPAR",
        (pANTLR3_UINT8) "INCLUDES",
        (pANTLR3_UINT8) "IS",
        (pANTLR3_UINT8) "STARTSWITH",
        (pANTLR3_UINT8) "INTBOOL",
        (pANTLR3_UINT8) "AFTER",
        (pANTLR3_UINT8) "BEFORE",
        (pANTLR3_UINT8) "ENUMVAL",
        (pANTLR3_UINT8) "GROUPTAG",
        (pANTLR3_UINT8) "DATE",
        (pANTLR3_UINT8) "AGO",
        (pANTLR3_UINT8) "DATINTERVAL",
        (pANTLR3_UINT8) "GREATER",
        (pANTLR3_UINT8) "GREATEREQUAL",
        (pANTLR3_UINT8) "LESS",
        (pANTLR3_UINT8) "LESSEQUAL",
        (pANTLR3_UINT8) "EQUAL",
        (pANTLR3_UINT8) "WHITESPACE",
        (pANTLR3_UINT8) "'{'",
        (pANTLR3_UINT8) "'}'"
       };

        

// Forward declare the locally static matching functions we have generated.
//
static SMARTPLParser_playlist_return	playlist    (pSMARTPLParser ctx);
static SMARTPLParser_expression_return	expression    (pSMARTPLParser ctx);
static SMARTPLParser_orderexpr_return	orderexpr    (pSMARTPLParser ctx);
static SMARTPLParser_ordertag_return	ordertag    (pSMARTPLParser ctx);
static SMARTPLParser_limitexpr_return	limitexpr    (pSMARTPLParser ctx);
static SMARTPLParser_aexpr_return	aexpr    (pSMARTPLParser ctx);
static SMARTPLParser_nexpr_return	nexpr    (pSMARTPLParser ctx);
static SMARTPLParser_crit_return	crit    (pSMARTPLParser ctx);
static SMARTPLParser_dateval_return	dateval    (pSMARTPLParser ctx);
static SMARTPLParser_interval_return	interval    (pSMARTPLParser ctx);
static void	SMARTPLParserFree(pSMARTPLParser ctx);
/* For use in tree output where we are accumulating rule labels via label += ruleRef
 * we need a function that knows how to free a return scope when the list is destroyed. 
 * We cannot just use ANTLR3_FREE because in debug tracking mode, this is a macro.
 */
static	void ANTLR3_CDECL freeScope(void * scope)
{
    ANTLR3_FREE(scope);
}

/** \brief Name of the grammar file that generated this code
 */
static const char fileName[] = "SMARTPL.g";

/** \brief Return the name of the grammar file that generated this code.
 */
static const char * getGrammarFileName()
{
	return fileName;
}
/** \brief Create a new SMARTPLParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pSMARTPLParser
SMARTPLParserNew   (pANTLR3_COMMON_TOKEN_STREAM instream)
{
	// See if we can create a new parser with the standard constructor
	//
	return SMARTPLParserNewSSD(instream, NULL);
}

/** \brief Create a new SMARTPLParser parser and return a context for it.
 *
 * \param[in] instream Pointer to an input stream interface.
 *
 * \return Pointer to new parser context upon success.
 */
ANTLR3_API pSMARTPLParser
SMARTPLParserNewSSD   (pANTLR3_COMMON_TOKEN_STREAM instream, pANTLR3_RECOGNIZER_SHARED_STATE state)
{
    pSMARTPLParser ctx;	    /* Context structure we will build and return   */
    
    ctx	= (pSMARTPLParser) ANTLR3_CALLOC(1, sizeof(SMARTPLParser));
    
    if	(ctx == NULL)
    {
		// Failed to allocate memory for parser context
		//
        return  NULL;
    }
    
    /* -------------------------------------------------------------------
     * Memory for basic structure is allocated, now to fill in
     * the base ANTLR3 structures. We initialize the function pointers
     * for the standard ANTLR3 parser function set, but upon return
     * from here, the programmer may set the pointers to provide custom
     * implementations of each function. 
     *
     * We don't use the macros defined in SMARTPLParser.h here, in order that you can get a sense
     * of what goes where.
     */

    /* Create a base parser/recognizer, using the supplied token stream
     */
    ctx->pParser	    = antlr3ParserNewStream(ANTLR3_SIZE_HINT, instream->tstream, state);
    /* Install the implementation of our SMARTPLParser interface
     */
    ctx->playlist	= playlist;
    ctx->expression	= expression;
    ctx->orderexpr	= orderexpr;
    ctx->ordertag	= ordertag;
    ctx->limitexpr	= limitexpr;
    ctx->aexpr	= aexpr;
    ctx->nexpr	= nexpr;
    ctx->crit	= crit;
    ctx->dateval	= dateval;
    ctx->interval	= interval;
    ctx->free			= SMARTPLParserFree;
    ctx->getGrammarFileName	= getGrammarFileName;
    
    /* Install the scope pushing methods.
     */
    ADAPTOR	= ANTLR3_TREE_ADAPTORNew(instream->tstream->tokenSource->strFactory);
    ctx->vectors	= antlr3VectorFactoryNew(0);
    

	
    /* Install the token table
     */
    PSRSTATE->tokenNames   = SMARTPLParserTokenNames;
    
    
    /* Return the newly built parser to the caller
     */
    return  ctx;
}

/** Free the parser resources
 */
 static void
 SMARTPLParserFree(pSMARTPLParser ctx)
 {
    /* Free any scope memory
     */
    
    ctx->vectors->close(ctx->vectors);
    /* We created the adaptor so we must free it
     */
    ADAPTOR->free(ADAPTOR);
	// Free this parser
	//
    ctx->pParser->free(ctx->pParser);
    ANTLR3_FREE(ctx);

    /* Everything is released, so we can return
     */
    return;
 }
 
/** Return token names used by this parser
 *
 * The returned pointer is used as an index into the token names table (using the token 
 * number as the index).
 * 
 * \return Pointer to first char * in the table.
 */
static pANTLR3_UINT8    *getTokenNames() 
{
        return SMARTPLParserTokenNames; 
}

    
/* Declare the bitsets
 */

/** Bitset defining follow set for error recovery in rule state: FOLLOW_STR_in_playlist42  */
static	ANTLR3_BITWORD FOLLOW_STR_in_playlist42_bits[]	= { ANTLR3_UINT64_LIT(0x0000004000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_STR_in_playlist42	= { FOLLOW_STR_in_playlist42_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_38_in_playlist44  */
static	ANTLR3_BITWORD FOLLOW_38_in_playlist44_bits[]	= { ANTLR3_UINT64_LIT(0x00000000100C3C00) };
static  ANTLR3_BITSET_LIST FOLLOW_38_in_playlist44	= { FOLLOW_38_in_playlist44_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_playlist46  */
static	ANTLR3_BITWORD FOLLOW_expression_in_playlist46_bits[]	= { ANTLR3_UINT64_LIT(0x0000008000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_playlist46	= { FOLLOW_expression_in_playlist46_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_39_in_playlist48  */
static	ANTLR3_BITWORD FOLLOW_39_in_playlist48_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000000) };
static  ANTLR3_BITSET_LIST FOLLOW_39_in_playlist48	= { FOLLOW_39_in_playlist48_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_EOF_in_playlist50  */
static	ANTLR3_BITWORD FOLLOW_EOF_in_playlist50_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_EOF_in_playlist50	= { FOLLOW_EOF_in_playlist50_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_aexpr_in_expression62  */
static	ANTLR3_BITWORD FOLLOW_aexpr_in_expression62_bits[]	= { ANTLR3_UINT64_LIT(0x00000000000001E2) };
static  ANTLR3_BITSET_LIST FOLLOW_aexpr_in_expression62	= { FOLLOW_aexpr_in_expression62_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_OR_in_expression65  */
static	ANTLR3_BITWORD FOLLOW_OR_in_expression65_bits[]	= { ANTLR3_UINT64_LIT(0x00000000100C3C00) };
static  ANTLR3_BITSET_LIST FOLLOW_OR_in_expression65	= { FOLLOW_OR_in_expression65_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_aexpr_in_expression68  */
static	ANTLR3_BITWORD FOLLOW_aexpr_in_expression68_bits[]	= { ANTLR3_UINT64_LIT(0x00000000000001E2) };
static  ANTLR3_BITSET_LIST FOLLOW_aexpr_in_expression68	= { FOLLOW_aexpr_in_expression68_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_HAVING_in_expression73  */
static	ANTLR3_BITWORD FOLLOW_HAVING_in_expression73_bits[]	= { ANTLR3_UINT64_LIT(0x00000000100C3C00) };
static  ANTLR3_BITSET_LIST FOLLOW_HAVING_in_expression73	= { FOLLOW_HAVING_in_expression73_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_aexpr_in_expression76  */
static	ANTLR3_BITWORD FOLLOW_aexpr_in_expression76_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000182) };
static  ANTLR3_BITSET_LIST FOLLOW_aexpr_in_expression76	= { FOLLOW_aexpr_in_expression76_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ORDERBY_in_expression81  */
static	ANTLR3_BITWORD FOLLOW_ORDERBY_in_expression81_bits[]	= { ANTLR3_UINT64_LIT(0x000000000000FC00) };
static  ANTLR3_BITSET_LIST FOLLOW_ORDERBY_in_expression81	= { FOLLOW_ORDERBY_in_expression81_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_orderexpr_in_expression84  */
static	ANTLR3_BITWORD FOLLOW_orderexpr_in_expression84_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000102) };
static  ANTLR3_BITSET_LIST FOLLOW_orderexpr_in_expression84	= { FOLLOW_orderexpr_in_expression84_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LIMIT_in_expression89  */
static	ANTLR3_BITWORD FOLLOW_LIMIT_in_expression89_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_LIMIT_in_expression89	= { FOLLOW_LIMIT_in_expression89_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_limitexpr_in_expression92  */
static	ANTLR3_BITWORD FOLLOW_limitexpr_in_expression92_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_limitexpr_in_expression92	= { FOLLOW_limitexpr_in_expression92_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ordertag_in_orderexpr106  */
static	ANTLR3_BITWORD FOLLOW_ordertag_in_orderexpr106_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000200) };
static  ANTLR3_BITSET_LIST FOLLOW_ordertag_in_orderexpr106	= { FOLLOW_ordertag_in_orderexpr106_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_SORTDIR_in_orderexpr108  */
static	ANTLR3_BITWORD FOLLOW_SORTDIR_in_orderexpr108_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_SORTDIR_in_orderexpr108	= { FOLLOW_SORTDIR_in_orderexpr108_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRTAG_in_ordertag120  */
static	ANTLR3_BITWORD FOLLOW_STRTAG_in_ordertag120_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STRTAG_in_ordertag120	= { FOLLOW_STRTAG_in_ordertag120_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTTAG_in_ordertag127  */
static	ANTLR3_BITWORD FOLLOW_INTTAG_in_ordertag127_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INTTAG_in_ordertag127	= { FOLLOW_INTTAG_in_ordertag127_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DATETAG_in_ordertag134  */
static	ANTLR3_BITWORD FOLLOW_DATETAG_in_ordertag134_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DATETAG_in_ordertag134	= { FOLLOW_DATETAG_in_ordertag134_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ENUMTAG_in_ordertag141  */
static	ANTLR3_BITWORD FOLLOW_ENUMTAG_in_ordertag141_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ENUMTAG_in_ordertag141	= { FOLLOW_ENUMTAG_in_ordertag141_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_XXX_in_ordertag149  */
static	ANTLR3_BITWORD FOLLOW_XXX_in_ordertag149_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000008000) };
static  ANTLR3_BITSET_LIST FOLLOW_XXX_in_ordertag149	= { FOLLOW_XXX_in_ordertag149_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NeverUsedRule_in_ordertag153  */
static	ANTLR3_BITWORD FOLLOW_NeverUsedRule_in_ordertag153_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_NeverUsedRule_in_ordertag153	= { FOLLOW_NeverUsedRule_in_ordertag153_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INT_in_limitexpr192  */
static	ANTLR3_BITWORD FOLLOW_INT_in_limitexpr192_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INT_in_limitexpr192	= { FOLLOW_INT_in_limitexpr192_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nexpr_in_aexpr205  */
static	ANTLR3_BITWORD FOLLOW_nexpr_in_aexpr205_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020002) };
static  ANTLR3_BITSET_LIST FOLLOW_nexpr_in_aexpr205	= { FOLLOW_nexpr_in_aexpr205_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AND_in_aexpr208  */
static	ANTLR3_BITWORD FOLLOW_AND_in_aexpr208_bits[]	= { ANTLR3_UINT64_LIT(0x00000000100C3C00) };
static  ANTLR3_BITSET_LIST FOLLOW_AND_in_aexpr208	= { FOLLOW_AND_in_aexpr208_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_nexpr_in_aexpr211  */
static	ANTLR3_BITWORD FOLLOW_nexpr_in_aexpr211_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000020002) };
static  ANTLR3_BITSET_LIST FOLLOW_nexpr_in_aexpr211	= { FOLLOW_nexpr_in_aexpr211_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_NOT_in_nexpr226  */
static	ANTLR3_BITWORD FOLLOW_NOT_in_nexpr226_bits[]	= { ANTLR3_UINT64_LIT(0x00000000100C3C00) };
static  ANTLR3_BITSET_LIST FOLLOW_NOT_in_nexpr226	= { FOLLOW_NOT_in_nexpr226_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_crit_in_nexpr229  */
static	ANTLR3_BITWORD FOLLOW_crit_in_nexpr229_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_crit_in_nexpr229	= { FOLLOW_crit_in_nexpr229_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_crit_in_nexpr236  */
static	ANTLR3_BITWORD FOLLOW_crit_in_nexpr236_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_crit_in_nexpr236	= { FOLLOW_crit_in_nexpr236_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_LPAR_in_crit249  */
static	ANTLR3_BITWORD FOLLOW_LPAR_in_crit249_bits[]	= { ANTLR3_UINT64_LIT(0x00000000100C3C00) };
static  ANTLR3_BITSET_LIST FOLLOW_LPAR_in_crit249	= { FOLLOW_LPAR_in_crit249_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_expression_in_crit251  */
static	ANTLR3_BITWORD FOLLOW_expression_in_crit251_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000100000) };
static  ANTLR3_BITSET_LIST FOLLOW_expression_in_crit251	= { FOLLOW_expression_in_crit251_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_RPAR_in_crit253  */
static	ANTLR3_BITWORD FOLLOW_RPAR_in_crit253_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_RPAR_in_crit253	= { FOLLOW_RPAR_in_crit253_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STRTAG_in_crit264  */
static	ANTLR3_BITWORD FOLLOW_STRTAG_in_crit264_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000E00000) };
static  ANTLR3_BITSET_LIST FOLLOW_STRTAG_in_crit264	= { FOLLOW_STRTAG_in_crit264_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_crit266  */
static	ANTLR3_BITWORD FOLLOW_set_in_crit266_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000010) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_crit266	= { FOLLOW_set_in_crit266_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_STR_in_crit274  */
static	ANTLR3_BITWORD FOLLOW_STR_in_crit274_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_STR_in_crit274	= { FOLLOW_STR_in_crit274_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTTAG_in_crit281  */
static	ANTLR3_BITWORD FOLLOW_INTTAG_in_crit281_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTTAG_in_crit281	= { FOLLOW_INTTAG_in_crit281_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTBOOL_in_crit283  */
static	ANTLR3_BITWORD FOLLOW_INTBOOL_in_crit283_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTBOOL_in_crit283	= { FOLLOW_INTBOOL_in_crit283_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INT_in_crit285  */
static	ANTLR3_BITWORD FOLLOW_INT_in_crit285_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INT_in_crit285	= { FOLLOW_INT_in_crit285_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DATETAG_in_crit292  */
static	ANTLR3_BITWORD FOLLOW_DATETAG_in_crit292_bits[]	= { ANTLR3_UINT64_LIT(0x0000000006000000) };
static  ANTLR3_BITSET_LIST FOLLOW_DATETAG_in_crit292	= { FOLLOW_DATETAG_in_crit292_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_set_in_crit294  */
static	ANTLR3_BITWORD FOLLOW_set_in_crit294_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020010000) };
static  ANTLR3_BITSET_LIST FOLLOW_set_in_crit294	= { FOLLOW_set_in_crit294_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_dateval_in_crit300  */
static	ANTLR3_BITWORD FOLLOW_dateval_in_crit300_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_dateval_in_crit300	= { FOLLOW_dateval_in_crit300_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ENUMTAG_in_crit307  */
static	ANTLR3_BITWORD FOLLOW_ENUMTAG_in_crit307_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000400000) };
static  ANTLR3_BITSET_LIST FOLLOW_ENUMTAG_in_crit307	= { FOLLOW_ENUMTAG_in_crit307_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_IS_in_crit309  */
static	ANTLR3_BITWORD FOLLOW_IS_in_crit309_bits[]	= { ANTLR3_UINT64_LIT(0x0000000008000000) };
static  ANTLR3_BITSET_LIST FOLLOW_IS_in_crit309	= { FOLLOW_IS_in_crit309_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_ENUMVAL_in_crit311  */
static	ANTLR3_BITWORD FOLLOW_ENUMVAL_in_crit311_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_ENUMVAL_in_crit311	= { FOLLOW_ENUMVAL_in_crit311_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_GROUPTAG_in_crit318  */
static	ANTLR3_BITWORD FOLLOW_GROUPTAG_in_crit318_bits[]	= { ANTLR3_UINT64_LIT(0x0000000001000000) };
static  ANTLR3_BITSET_LIST FOLLOW_GROUPTAG_in_crit318	= { FOLLOW_GROUPTAG_in_crit318_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INTBOOL_in_crit320  */
static	ANTLR3_BITWORD FOLLOW_INTBOOL_in_crit320_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000010000) };
static  ANTLR3_BITSET_LIST FOLLOW_INTBOOL_in_crit320	= { FOLLOW_INTBOOL_in_crit320_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INT_in_crit322  */
static	ANTLR3_BITWORD FOLLOW_INT_in_crit322_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_INT_in_crit322	= { FOLLOW_INT_in_crit322_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DATE_in_dateval335  */
static	ANTLR3_BITWORD FOLLOW_DATE_in_dateval335_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DATE_in_dateval335	= { FOLLOW_DATE_in_dateval335_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_interval_in_dateval342  */
static	ANTLR3_BITWORD FOLLOW_interval_in_dateval342_bits[]	= { ANTLR3_UINT64_LIT(0x0000000004000000) };
static  ANTLR3_BITSET_LIST FOLLOW_interval_in_dateval342	= { FOLLOW_interval_in_dateval342_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_BEFORE_in_dateval344  */
static	ANTLR3_BITWORD FOLLOW_BEFORE_in_dateval344_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020000000) };
static  ANTLR3_BITSET_LIST FOLLOW_BEFORE_in_dateval344	= { FOLLOW_BEFORE_in_dateval344_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DATE_in_dateval346  */
static	ANTLR3_BITWORD FOLLOW_DATE_in_dateval346_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DATE_in_dateval346	= { FOLLOW_DATE_in_dateval346_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_interval_in_dateval353  */
static	ANTLR3_BITWORD FOLLOW_interval_in_dateval353_bits[]	= { ANTLR3_UINT64_LIT(0x0000000002000000) };
static  ANTLR3_BITSET_LIST FOLLOW_interval_in_dateval353	= { FOLLOW_interval_in_dateval353_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AFTER_in_dateval355  */
static	ANTLR3_BITWORD FOLLOW_AFTER_in_dateval355_bits[]	= { ANTLR3_UINT64_LIT(0x0000000020000000) };
static  ANTLR3_BITSET_LIST FOLLOW_AFTER_in_dateval355	= { FOLLOW_AFTER_in_dateval355_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DATE_in_dateval357  */
static	ANTLR3_BITWORD FOLLOW_DATE_in_dateval357_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DATE_in_dateval357	= { FOLLOW_DATE_in_dateval357_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_interval_in_dateval364  */
static	ANTLR3_BITWORD FOLLOW_interval_in_dateval364_bits[]	= { ANTLR3_UINT64_LIT(0x0000000040000000) };
static  ANTLR3_BITSET_LIST FOLLOW_interval_in_dateval364	= { FOLLOW_interval_in_dateval364_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_AGO_in_dateval366  */
static	ANTLR3_BITWORD FOLLOW_AGO_in_dateval366_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_AGO_in_dateval366	= { FOLLOW_AGO_in_dateval366_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_INT_in_interval378  */
static	ANTLR3_BITWORD FOLLOW_INT_in_interval378_bits[]	= { ANTLR3_UINT64_LIT(0x0000000080000000) };
static  ANTLR3_BITSET_LIST FOLLOW_INT_in_interval378	= { FOLLOW_INT_in_interval378_bits, 1	};
/** Bitset defining follow set for error recovery in rule state: FOLLOW_DATINTERVAL_in_interval380  */
static	ANTLR3_BITWORD FOLLOW_DATINTERVAL_in_interval380_bits[]	= { ANTLR3_UINT64_LIT(0x0000000000000002) };
static  ANTLR3_BITSET_LIST FOLLOW_DATINTERVAL_in_interval380	= { FOLLOW_DATINTERVAL_in_interval380_bits, 1	};
     

 
 
/* ==============================================
 * Parsing rules
 */
/** 
 * $ANTLR start playlist
 * SMARTPL.g:27:1: playlist : STR '{' expression '}' EOF ;
 */
static SMARTPLParser_playlist_return
playlist(pSMARTPLParser ctx)
{   
    SMARTPLParser_playlist_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    STR1;
    pANTLR3_COMMON_TOKEN    char_literal2;
    pANTLR3_COMMON_TOKEN    char_literal4;
    pANTLR3_COMMON_TOKEN    EOF5;
    SMARTPLParser_expression_return expression3;
    #undef	RETURN_TYPE_expression3
    #define	RETURN_TYPE_expression3 SMARTPLParser_expression_return

    pANTLR3_BASE_TREE STR1_tree;
    pANTLR3_BASE_TREE char_literal2_tree;
    pANTLR3_BASE_TREE char_literal4_tree;
    pANTLR3_BASE_TREE EOF5_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    STR1       = NULL;
    char_literal2       = NULL;
    char_literal4       = NULL;
    EOF5       = NULL;
    expression3.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    STR1_tree   = NULL;
    char_literal2_tree   = NULL;
    char_literal4_tree   = NULL;
    EOF5_tree   = NULL;


    retval.tree  = NULL;
    {
        // SMARTPL.g:27:10: ( STR '{' expression '}' EOF )
        // SMARTPL.g:27:12: STR '{' expression '}' EOF
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            STR1 = (pANTLR3_COMMON_TOKEN) MATCHT(STR, &FOLLOW_STR_in_playlist42); 
            if  (HASEXCEPTION())
            {
                goto ruleplaylistEx;
            }

            STR1_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, STR1));
            ADAPTOR->addChild(ADAPTOR, root_0, STR1_tree);

            char_literal2 = (pANTLR3_COMMON_TOKEN) MATCHT(38, &FOLLOW_38_in_playlist44); 
            if  (HASEXCEPTION())
            {
                goto ruleplaylistEx;
            }

            char_literal2_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal2));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal2_tree);

            FOLLOWPUSH(FOLLOW_expression_in_playlist46);
            expression3=expression(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleplaylistEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, expression3.tree);
            char_literal4 = (pANTLR3_COMMON_TOKEN) MATCHT(39, &FOLLOW_39_in_playlist48); 
            if  (HASEXCEPTION())
            {
                goto ruleplaylistEx;
            }

            char_literal4_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, char_literal4));
            ADAPTOR->addChild(ADAPTOR, root_0, char_literal4_tree);

            EOF5 = (pANTLR3_COMMON_TOKEN) MATCHT(EOF, &FOLLOW_EOF_in_playlist50); 
            if  (HASEXCEPTION())
            {
                goto ruleplaylistEx;
            }

            EOF5_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, EOF5));
            ADAPTOR->addChild(ADAPTOR, root_0, EOF5_tree);


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleplaylistEx; /* Prevent compiler warnings */
    ruleplaylistEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end playlist */

/** 
 * $ANTLR start expression
 * SMARTPL.g:30:1: expression : aexpr ( OR aexpr )* ( HAVING aexpr )? ( ORDERBY orderexpr )? ( LIMIT limitexpr )? ;
 */
static SMARTPLParser_expression_return
expression(pSMARTPLParser ctx)
{   
    SMARTPLParser_expression_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    OR7;
    pANTLR3_COMMON_TOKEN    HAVING9;
    pANTLR3_COMMON_TOKEN    ORDERBY11;
    pANTLR3_COMMON_TOKEN    LIMIT13;
    SMARTPLParser_aexpr_return aexpr6;
    #undef	RETURN_TYPE_aexpr6
    #define	RETURN_TYPE_aexpr6 SMARTPLParser_aexpr_return

    SMARTPLParser_aexpr_return aexpr8;
    #undef	RETURN_TYPE_aexpr8
    #define	RETURN_TYPE_aexpr8 SMARTPLParser_aexpr_return

    SMARTPLParser_aexpr_return aexpr10;
    #undef	RETURN_TYPE_aexpr10
    #define	RETURN_TYPE_aexpr10 SMARTPLParser_aexpr_return

    SMARTPLParser_orderexpr_return orderexpr12;
    #undef	RETURN_TYPE_orderexpr12
    #define	RETURN_TYPE_orderexpr12 SMARTPLParser_orderexpr_return

    SMARTPLParser_limitexpr_return limitexpr14;
    #undef	RETURN_TYPE_limitexpr14
    #define	RETURN_TYPE_limitexpr14 SMARTPLParser_limitexpr_return

    pANTLR3_BASE_TREE OR7_tree;
    pANTLR3_BASE_TREE HAVING9_tree;
    pANTLR3_BASE_TREE ORDERBY11_tree;
    pANTLR3_BASE_TREE LIMIT13_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    OR7       = NULL;
    HAVING9       = NULL;
    ORDERBY11       = NULL;
    LIMIT13       = NULL;
    aexpr6.tree = NULL;

    aexpr8.tree = NULL;

    aexpr10.tree = NULL;

    orderexpr12.tree = NULL;

    limitexpr14.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    OR7_tree   = NULL;
    HAVING9_tree   = NULL;
    ORDERBY11_tree   = NULL;
    LIMIT13_tree   = NULL;


    retval.tree  = NULL;
    {
        // SMARTPL.g:30:12: ( aexpr ( OR aexpr )* ( HAVING aexpr )? ( ORDERBY orderexpr )? ( LIMIT limitexpr )? )
        // SMARTPL.g:30:14: aexpr ( OR aexpr )* ( HAVING aexpr )? ( ORDERBY orderexpr )? ( LIMIT limitexpr )?
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            FOLLOWPUSH(FOLLOW_aexpr_in_expression62);
            aexpr6=aexpr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleexpressionEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, aexpr6.tree);

            // SMARTPL.g:30:20: ( OR aexpr )*

            for (;;)
            {
                int alt1=2;
                switch ( LA(1) ) 
                {
                case OR:
                	{
                		alt1=1;
                	}
                    break;

                }

                switch (alt1) 
                {
            	case 1:
            	    // SMARTPL.g:30:21: OR aexpr
            	    {
            	        OR7 = (pANTLR3_COMMON_TOKEN) MATCHT(OR, &FOLLOW_OR_in_expression65); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexpressionEx;
            	        }

            	        OR7_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, OR7));
            	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, OR7_tree, root_0));

            	        FOLLOWPUSH(FOLLOW_aexpr_in_expression68);
            	        aexpr8=aexpr(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexpressionEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, aexpr8.tree);

            	    }
            	    break;

            	default:
            	    goto loop1;	/* break out of the loop */
            	    break;
                }
            }
            loop1: ; /* Jump out to here if this rule does not match */


            // SMARTPL.g:30:33: ( HAVING aexpr )?
            {
                int alt2=2;
                switch ( LA(1) ) 
                {
                    case HAVING:
                    	{
                    		alt2=1;
                    	}
                        break;
                }

                switch (alt2) 
                {
            	case 1:
            	    // SMARTPL.g:30:34: HAVING aexpr
            	    {
            	        HAVING9 = (pANTLR3_COMMON_TOKEN) MATCHT(HAVING, &FOLLOW_HAVING_in_expression73); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexpressionEx;
            	        }

            	        HAVING9_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, HAVING9));
            	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, HAVING9_tree, root_0));

            	        FOLLOWPUSH(FOLLOW_aexpr_in_expression76);
            	        aexpr10=aexpr(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexpressionEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, aexpr10.tree);

            	    }
            	    break;

                }
            }

            // SMARTPL.g:30:50: ( ORDERBY orderexpr )?
            {
                int alt3=2;
                switch ( LA(1) ) 
                {
                    case ORDERBY:
                    	{
                    		alt3=1;
                    	}
                        break;
                }

                switch (alt3) 
                {
            	case 1:
            	    // SMARTPL.g:30:51: ORDERBY orderexpr
            	    {
            	        ORDERBY11 = (pANTLR3_COMMON_TOKEN) MATCHT(ORDERBY, &FOLLOW_ORDERBY_in_expression81); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexpressionEx;
            	        }

            	        ORDERBY11_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, ORDERBY11));
            	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, ORDERBY11_tree, root_0));

            	        FOLLOWPUSH(FOLLOW_orderexpr_in_expression84);
            	        orderexpr12=orderexpr(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexpressionEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, orderexpr12.tree);

            	    }
            	    break;

                }
            }

            // SMARTPL.g:30:72: ( LIMIT limitexpr )?
            {
                int alt4=2;
                switch ( LA(1) ) 
                {
                    case LIMIT:
                    	{
                    		alt4=1;
                    	}
                        break;
                }

                switch (alt4) 
                {
            	case 1:
            	    // SMARTPL.g:30:73: LIMIT limitexpr
            	    {
            	        LIMIT13 = (pANTLR3_COMMON_TOKEN) MATCHT(LIMIT, &FOLLOW_LIMIT_in_expression89); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexpressionEx;
            	        }

            	        LIMIT13_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, LIMIT13));
            	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, LIMIT13_tree, root_0));

            	        FOLLOWPUSH(FOLLOW_limitexpr_in_expression92);
            	        limitexpr14=limitexpr(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleexpressionEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, limitexpr14.tree);

            	    }
            	    break;

                }
            }

        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleexpressionEx; /* Prevent compiler warnings */
    ruleexpressionEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end expression */

/** 
 * $ANTLR start orderexpr
 * SMARTPL.g:33:1: orderexpr : ordertag SORTDIR ;
 */
static SMARTPLParser_orderexpr_return
orderexpr(pSMARTPLParser ctx)
{   
    SMARTPLParser_orderexpr_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    SORTDIR16;
    SMARTPLParser_ordertag_return ordertag15;
    #undef	RETURN_TYPE_ordertag15
    #define	RETURN_TYPE_ordertag15 SMARTPLParser_ordertag_return

    pANTLR3_BASE_TREE SORTDIR16_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    SORTDIR16       = NULL;
    ordertag15.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    SORTDIR16_tree   = NULL;


    retval.tree  = NULL;
    {
        // SMARTPL.g:33:11: ( ordertag SORTDIR )
        // SMARTPL.g:33:13: ordertag SORTDIR
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            FOLLOWPUSH(FOLLOW_ordertag_in_orderexpr106);
            ordertag15=ordertag(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleorderexprEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, ordertag15.tree);
            SORTDIR16 = (pANTLR3_COMMON_TOKEN) MATCHT(SORTDIR, &FOLLOW_SORTDIR_in_orderexpr108); 
            if  (HASEXCEPTION())
            {
                goto ruleorderexprEx;
            }

            SORTDIR16_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, SORTDIR16));
            ADAPTOR->addChild(ADAPTOR, root_0, SORTDIR16_tree);


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleorderexprEx; /* Prevent compiler warnings */
    ruleorderexprEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end orderexpr */

/** 
 * $ANTLR start ordertag
 * SMARTPL.g:36:1: ordertag : ( STRTAG | INTTAG | DATETAG | ENUMTAG | ( XXX )? NeverUsedRule );
 */
static SMARTPLParser_ordertag_return
ordertag(pSMARTPLParser ctx)
{   
    SMARTPLParser_ordertag_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    STRTAG17;
    pANTLR3_COMMON_TOKEN    INTTAG18;
    pANTLR3_COMMON_TOKEN    DATETAG19;
    pANTLR3_COMMON_TOKEN    ENUMTAG20;
    pANTLR3_COMMON_TOKEN    XXX21;
    pANTLR3_COMMON_TOKEN    NeverUsedRule22;

    pANTLR3_BASE_TREE STRTAG17_tree;
    pANTLR3_BASE_TREE INTTAG18_tree;
    pANTLR3_BASE_TREE DATETAG19_tree;
    pANTLR3_BASE_TREE ENUMTAG20_tree;
    pANTLR3_BASE_TREE XXX21_tree;
    pANTLR3_BASE_TREE NeverUsedRule22_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    STRTAG17       = NULL;
    INTTAG18       = NULL;
    DATETAG19       = NULL;
    ENUMTAG20       = NULL;
    XXX21       = NULL;
    NeverUsedRule22       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    STRTAG17_tree   = NULL;
    INTTAG18_tree   = NULL;
    DATETAG19_tree   = NULL;
    ENUMTAG20_tree   = NULL;
    XXX21_tree   = NULL;
    NeverUsedRule22_tree   = NULL;


    retval.tree  = NULL;
    {
        {
            //  SMARTPL.g:36:10: ( STRTAG | INTTAG | DATETAG | ENUMTAG | ( XXX )? NeverUsedRule )
            
            ANTLR3_UINT32 alt6;

            alt6=5;

            switch ( LA(1) ) 
            {
            case STRTAG:
            	{
            		alt6=1;
            	}
                break;
            case INTTAG:
            	{
            		alt6=2;
            	}
                break;
            case DATETAG:
            	{
            		alt6=3;
            	}
                break;
            case ENUMTAG:
            	{
            		alt6=4;
            	}
                break;
            case XXX:
            case NeverUsedRule:
            	{
            		alt6=5;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 6;
                EXCEPTION->state        = 0;


                goto ruleordertagEx;
            }

            switch (alt6) 
            {
        	case 1:
        	    // SMARTPL.g:36:12: STRTAG
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        STRTAG17 = (pANTLR3_COMMON_TOKEN) MATCHT(STRTAG, &FOLLOW_STRTAG_in_ordertag120); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleordertagEx;
        	        }

        	        STRTAG17_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, STRTAG17));
        	        ADAPTOR->addChild(ADAPTOR, root_0, STRTAG17_tree);


        	    }
        	    break;
        	case 2:
        	    // SMARTPL.g:37:6: INTTAG
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        INTTAG18 = (pANTLR3_COMMON_TOKEN) MATCHT(INTTAG, &FOLLOW_INTTAG_in_ordertag127); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleordertagEx;
        	        }

        	        INTTAG18_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, INTTAG18));
        	        ADAPTOR->addChild(ADAPTOR, root_0, INTTAG18_tree);


        	    }
        	    break;
        	case 3:
        	    // SMARTPL.g:38:6: DATETAG
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        DATETAG19 = (pANTLR3_COMMON_TOKEN) MATCHT(DATETAG, &FOLLOW_DATETAG_in_ordertag134); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleordertagEx;
        	        }

        	        DATETAG19_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DATETAG19));
        	        ADAPTOR->addChild(ADAPTOR, root_0, DATETAG19_tree);


        	    }
        	    break;
        	case 4:
        	    // SMARTPL.g:39:6: ENUMTAG
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        ENUMTAG20 = (pANTLR3_COMMON_TOKEN) MATCHT(ENUMTAG, &FOLLOW_ENUMTAG_in_ordertag141); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleordertagEx;
        	        }

        	        ENUMTAG20_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, ENUMTAG20));
        	        ADAPTOR->addChild(ADAPTOR, root_0, ENUMTAG20_tree);


        	    }
        	    break;
        	case 5:
        	    // SMARTPL.g:40:6: ( XXX )? NeverUsedRule
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));


        	        // SMARTPL.g:40:6: ( XXX )?
        	        {
        	            int alt5=2;
        	            switch ( LA(1) ) 
        	            {
        	                case XXX:
        	                	{
        	                		alt5=1;
        	                	}
        	                    break;
        	            }

        	            switch (alt5) 
        	            {
        	        	case 1:
        	        	    // SMARTPL.g:40:7: XXX
        	        	    {
        	        	        XXX21 = (pANTLR3_COMMON_TOKEN) MATCHT(XXX, &FOLLOW_XXX_in_ordertag149); 
        	        	        if  (HASEXCEPTION())
        	        	        {
        	        	            goto ruleordertagEx;
        	        	        }

        	        	        XXX21_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, XXX21));
        	        	        ADAPTOR->addChild(ADAPTOR, root_0, XXX21_tree);


        	        	    }
        	        	    break;

        	            }
        	        }
        	        NeverUsedRule22 = (pANTLR3_COMMON_TOKEN) MATCHT(NeverUsedRule, &FOLLOW_NeverUsedRule_in_ordertag153); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruleordertagEx;
        	        }

        	        NeverUsedRule22_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, NeverUsedRule22));
        	        ADAPTOR->addChild(ADAPTOR, root_0, NeverUsedRule22_tree);


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruleordertagEx; /* Prevent compiler warnings */
    ruleordertagEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end ordertag */

/** 
 * $ANTLR start limitexpr
 * SMARTPL.g:49:1: limitexpr : INT ;
 */
static SMARTPLParser_limitexpr_return
limitexpr(pSMARTPLParser ctx)
{   
    SMARTPLParser_limitexpr_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    INT23;

    pANTLR3_BASE_TREE INT23_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    INT23       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    INT23_tree   = NULL;


    retval.tree  = NULL;
    {
        // SMARTPL.g:49:11: ( INT )
        // SMARTPL.g:49:13: INT
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            INT23 = (pANTLR3_COMMON_TOKEN) MATCHT(INT, &FOLLOW_INT_in_limitexpr192); 
            if  (HASEXCEPTION())
            {
                goto rulelimitexprEx;
            }

            INT23_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, INT23));
            ADAPTOR->addChild(ADAPTOR, root_0, INT23_tree);


        }

    }
    

    // This is where rules clean up and exit
    //
    goto rulelimitexprEx; /* Prevent compiler warnings */
    rulelimitexprEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end limitexpr */

/** 
 * $ANTLR start aexpr
 * SMARTPL.g:52:1: aexpr : nexpr ( AND nexpr )* ;
 */
static SMARTPLParser_aexpr_return
aexpr(pSMARTPLParser ctx)
{   
    SMARTPLParser_aexpr_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    AND25;
    SMARTPLParser_nexpr_return nexpr24;
    #undef	RETURN_TYPE_nexpr24
    #define	RETURN_TYPE_nexpr24 SMARTPLParser_nexpr_return

    SMARTPLParser_nexpr_return nexpr26;
    #undef	RETURN_TYPE_nexpr26
    #define	RETURN_TYPE_nexpr26 SMARTPLParser_nexpr_return

    pANTLR3_BASE_TREE AND25_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    AND25       = NULL;
    nexpr24.tree = NULL;

    nexpr26.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    AND25_tree   = NULL;


    retval.tree  = NULL;
    {
        // SMARTPL.g:52:8: ( nexpr ( AND nexpr )* )
        // SMARTPL.g:52:10: nexpr ( AND nexpr )*
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            FOLLOWPUSH(FOLLOW_nexpr_in_aexpr205);
            nexpr24=nexpr(ctx);

            FOLLOWPOP();
            if  (HASEXCEPTION())
            {
                goto ruleaexprEx;
            }

            ADAPTOR->addChild(ADAPTOR, root_0, nexpr24.tree);

            // SMARTPL.g:52:16: ( AND nexpr )*

            for (;;)
            {
                int alt7=2;
                switch ( LA(1) ) 
                {
                case AND:
                	{
                		alt7=1;
                	}
                    break;

                }

                switch (alt7) 
                {
            	case 1:
            	    // SMARTPL.g:52:17: AND nexpr
            	    {
            	        AND25 = (pANTLR3_COMMON_TOKEN) MATCHT(AND, &FOLLOW_AND_in_aexpr208); 
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleaexprEx;
            	        }

            	        AND25_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, AND25));
            	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, AND25_tree, root_0));

            	        FOLLOWPUSH(FOLLOW_nexpr_in_aexpr211);
            	        nexpr26=nexpr(ctx);

            	        FOLLOWPOP();
            	        if  (HASEXCEPTION())
            	        {
            	            goto ruleaexprEx;
            	        }

            	        ADAPTOR->addChild(ADAPTOR, root_0, nexpr26.tree);

            	    }
            	    break;

            	default:
            	    goto loop7;	/* break out of the loop */
            	    break;
                }
            }
            loop7: ; /* Jump out to here if this rule does not match */


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleaexprEx; /* Prevent compiler warnings */
    ruleaexprEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end aexpr */

/** 
 * $ANTLR start nexpr
 * SMARTPL.g:55:1: nexpr : ( NOT crit | crit );
 */
static SMARTPLParser_nexpr_return
nexpr(pSMARTPLParser ctx)
{   
    SMARTPLParser_nexpr_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    NOT27;
    SMARTPLParser_crit_return crit28;
    #undef	RETURN_TYPE_crit28
    #define	RETURN_TYPE_crit28 SMARTPLParser_crit_return

    SMARTPLParser_crit_return crit29;
    #undef	RETURN_TYPE_crit29
    #define	RETURN_TYPE_crit29 SMARTPLParser_crit_return

    pANTLR3_BASE_TREE NOT27_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    NOT27       = NULL;
    crit28.tree = NULL;

    crit29.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    NOT27_tree   = NULL;


    retval.tree  = NULL;
    {
        {
            //  SMARTPL.g:55:8: ( NOT crit | crit )
            
            ANTLR3_UINT32 alt8;

            alt8=2;

            switch ( LA(1) ) 
            {
            case NOT:
            	{
            		alt8=1;
            	}
                break;
            case STRTAG:
            case INTTAG:
            case DATETAG:
            case ENUMTAG:
            case LPAR:
            case GROUPTAG:
            	{
            		alt8=2;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 8;
                EXCEPTION->state        = 0;


                goto rulenexprEx;
            }

            switch (alt8) 
            {
        	case 1:
        	    // SMARTPL.g:55:10: NOT crit
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        NOT27 = (pANTLR3_COMMON_TOKEN) MATCHT(NOT, &FOLLOW_NOT_in_nexpr226); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenexprEx;
        	        }

        	        NOT27_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, NOT27));
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->becomeRoot(ADAPTOR, NOT27_tree, root_0));

        	        FOLLOWPUSH(FOLLOW_crit_in_nexpr229);
        	        crit28=crit(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenexprEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, crit28.tree);

        	    }
        	    break;
        	case 2:
        	    // SMARTPL.g:56:6: crit
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_crit_in_nexpr236);
        	        crit29=crit(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulenexprEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, crit29.tree);

        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulenexprEx; /* Prevent compiler warnings */
    rulenexprEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end nexpr */

/** 
 * $ANTLR start crit
 * SMARTPL.g:59:1: crit : ( LPAR expression RPAR -> expression | STRTAG ( INCLUDES | IS | STARTSWITH ) STR | INTTAG INTBOOL INT | DATETAG ( AFTER | BEFORE ) dateval | ENUMTAG IS ENUMVAL | GROUPTAG INTBOOL INT );
 */
static SMARTPLParser_crit_return
crit(pSMARTPLParser ctx)
{   
    SMARTPLParser_crit_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    LPAR30;
    pANTLR3_COMMON_TOKEN    RPAR32;
    pANTLR3_COMMON_TOKEN    STRTAG33;
    pANTLR3_COMMON_TOKEN    set34;
    pANTLR3_COMMON_TOKEN    STR35;
    pANTLR3_COMMON_TOKEN    INTTAG36;
    pANTLR3_COMMON_TOKEN    INTBOOL37;
    pANTLR3_COMMON_TOKEN    INT38;
    pANTLR3_COMMON_TOKEN    DATETAG39;
    pANTLR3_COMMON_TOKEN    set40;
    pANTLR3_COMMON_TOKEN    ENUMTAG42;
    pANTLR3_COMMON_TOKEN    IS43;
    pANTLR3_COMMON_TOKEN    ENUMVAL44;
    pANTLR3_COMMON_TOKEN    GROUPTAG45;
    pANTLR3_COMMON_TOKEN    INTBOOL46;
    pANTLR3_COMMON_TOKEN    INT47;
    SMARTPLParser_expression_return expression31;
    #undef	RETURN_TYPE_expression31
    #define	RETURN_TYPE_expression31 SMARTPLParser_expression_return

    SMARTPLParser_dateval_return dateval41;
    #undef	RETURN_TYPE_dateval41
    #define	RETURN_TYPE_dateval41 SMARTPLParser_dateval_return

    pANTLR3_BASE_TREE LPAR30_tree;
    pANTLR3_BASE_TREE RPAR32_tree;
    pANTLR3_BASE_TREE STRTAG33_tree;
    pANTLR3_BASE_TREE set34_tree;
    pANTLR3_BASE_TREE STR35_tree;
    pANTLR3_BASE_TREE INTTAG36_tree;
    pANTLR3_BASE_TREE INTBOOL37_tree;
    pANTLR3_BASE_TREE INT38_tree;
    pANTLR3_BASE_TREE DATETAG39_tree;
    pANTLR3_BASE_TREE set40_tree;
    pANTLR3_BASE_TREE ENUMTAG42_tree;
    pANTLR3_BASE_TREE IS43_tree;
    pANTLR3_BASE_TREE ENUMVAL44_tree;
    pANTLR3_BASE_TREE GROUPTAG45_tree;
    pANTLR3_BASE_TREE INTBOOL46_tree;
    pANTLR3_BASE_TREE INT47_tree;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_RPAR;
    pANTLR3_REWRITE_RULE_TOKEN_STREAM stream_LPAR;
    pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_expression;
    /* Initialize rule variables
     */


    root_0 = NULL;

    LPAR30       = NULL;
    RPAR32       = NULL;
    STRTAG33       = NULL;
    set34       = NULL;
    STR35       = NULL;
    INTTAG36       = NULL;
    INTBOOL37       = NULL;
    INT38       = NULL;
    DATETAG39       = NULL;
    set40       = NULL;
    ENUMTAG42       = NULL;
    IS43       = NULL;
    ENUMVAL44       = NULL;
    GROUPTAG45       = NULL;
    INTBOOL46       = NULL;
    INT47       = NULL;
    expression31.tree = NULL;

    dateval41.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    LPAR30_tree   = NULL;
    RPAR32_tree   = NULL;
    STRTAG33_tree   = NULL;
    set34_tree   = NULL;
    STR35_tree   = NULL;
    INTTAG36_tree   = NULL;
    INTBOOL37_tree   = NULL;
    INT38_tree   = NULL;
    DATETAG39_tree   = NULL;
    set40_tree   = NULL;
    ENUMTAG42_tree   = NULL;
    IS43_tree   = NULL;
    ENUMVAL44_tree   = NULL;
    GROUPTAG45_tree   = NULL;
    INTBOOL46_tree   = NULL;
    INT47_tree   = NULL;

    stream_RPAR   = NULL;
    #define CREATE_stream_RPAR  if (stream_RPAR == NULL) {stream_RPAR = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token RPAR"); } 
    stream_LPAR   = NULL;
    #define CREATE_stream_LPAR  if (stream_LPAR == NULL) {stream_LPAR = antlr3RewriteRuleTOKENStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"token LPAR"); } 
    stream_expression   = NULL;
    #define CREATE_stream_expression  if (stream_expression == NULL) {stream_expression = antlr3RewriteRuleSubtreeStreamNewAE(ADAPTOR, RECOGNIZER, (pANTLR3_UINT8)"rule expression"); }

    retval.tree  = NULL;
    {
        {
            //  SMARTPL.g:59:7: ( LPAR expression RPAR -> expression | STRTAG ( INCLUDES | IS | STARTSWITH ) STR | INTTAG INTBOOL INT | DATETAG ( AFTER | BEFORE ) dateval | ENUMTAG IS ENUMVAL | GROUPTAG INTBOOL INT )
            
            ANTLR3_UINT32 alt9;

            alt9=6;

            switch ( LA(1) ) 
            {
            case LPAR:
            	{
            		alt9=1;
            	}
                break;
            case STRTAG:
            	{
            		alt9=2;
            	}
                break;
            case INTTAG:
            	{
            		alt9=3;
            	}
                break;
            case DATETAG:
            	{
            		alt9=4;
            	}
                break;
            case ENUMTAG:
            	{
            		alt9=5;
            	}
                break;
            case GROUPTAG:
            	{
            		alt9=6;
            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 9;
                EXCEPTION->state        = 0;


                goto rulecritEx;
            }

            switch (alt9) 
            {
        	case 1:
        	    // SMARTPL.g:59:9: LPAR expression RPAR
        	    {
        	        LPAR30 = (pANTLR3_COMMON_TOKEN) MATCHT(LPAR, &FOLLOW_LPAR_in_crit249); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecritEx;
        	        }
        	         
        	        CREATE_stream_LPAR; stream_LPAR->add(stream_LPAR, LPAR30, NULL);

        	        FOLLOWPUSH(FOLLOW_expression_in_crit251);
        	        expression31=expression(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecritEx;
        	        }

        	        CREATE_stream_expression; stream_expression->add(stream_expression, expression31.tree, NULL);
        	        RPAR32 = (pANTLR3_COMMON_TOKEN) MATCHT(RPAR, &FOLLOW_RPAR_in_crit253); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecritEx;
        	        }
        	         
        	        CREATE_stream_RPAR; stream_RPAR->add(stream_RPAR, RPAR32, NULL);


        	         
        	        /* AST REWRITE
        	         * elements          : expression
        	         * token labels      : 
        	         * rule labels       : retval
        	         * token list labels : 
        	         * rule list labels  : 
        	         */
        	        {
        	        	pANTLR3_REWRITE_RULE_SUBTREE_STREAM stream_retval;

        	        	stream_retval=antlr3RewriteRuleSubtreeStreamNewAEE(ADAPTOR,  RECOGNIZER, (pANTLR3_UINT8)"token retval", retval.tree != NULL ? retval.tree : NULL);

        	        	root_0			    = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));
        	        	retval.tree    = root_0;
        	        	// 59:30: -> expression
        	        	{
        	        	    ADAPTOR->addChild(ADAPTOR, root_0, stream_expression == NULL ? NULL : stream_expression->nextTree(stream_expression));

        	        	}

        	        	retval.tree = root_0; // set result root
        	        	if (stream_retval != NULL) stream_retval->free(stream_retval);


        	        }
        	    }
        	    break;
        	case 2:
        	    // SMARTPL.g:60:6: STRTAG ( INCLUDES | IS | STARTSWITH ) STR
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        STRTAG33 = (pANTLR3_COMMON_TOKEN) MATCHT(STRTAG, &FOLLOW_STRTAG_in_crit264); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecritEx;
        	        }

        	        STRTAG33_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, STRTAG33));
        	        ADAPTOR->addChild(ADAPTOR, root_0, STRTAG33_tree);

        	        set34=(pANTLR3_COMMON_TOKEN)LT(1);
        	        if ( ((LA(1) >= INCLUDES) && (LA(1) <= STARTSWITH)) )
        	        {
        	            CONSUME();
        	            ADAPTOR->addChild(ADAPTOR, root_0, (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set34)));
        	            PERRORRECOVERY=ANTLR3_FALSE;
        	        }
        	        else 
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
        	            EXCEPTION->expectingSet = &FOLLOW_set_in_crit266;
        	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_crit266);    goto rulecritEx;
        	        }

        	        STR35 = (pANTLR3_COMMON_TOKEN) MATCHT(STR, &FOLLOW_STR_in_crit274); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecritEx;
        	        }

        	        STR35_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, STR35));
        	        ADAPTOR->addChild(ADAPTOR, root_0, STR35_tree);


        	    }
        	    break;
        	case 3:
        	    // SMARTPL.g:61:6: INTTAG INTBOOL INT
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        INTTAG36 = (pANTLR3_COMMON_TOKEN) MATCHT(INTTAG, &FOLLOW_INTTAG_in_crit281); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecritEx;
        	        }

        	        INTTAG36_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, INTTAG36));
        	        ADAPTOR->addChild(ADAPTOR, root_0, INTTAG36_tree);

        	        INTBOOL37 = (pANTLR3_COMMON_TOKEN) MATCHT(INTBOOL, &FOLLOW_INTBOOL_in_crit283); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecritEx;
        	        }

        	        INTBOOL37_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, INTBOOL37));
        	        ADAPTOR->addChild(ADAPTOR, root_0, INTBOOL37_tree);

        	        INT38 = (pANTLR3_COMMON_TOKEN) MATCHT(INT, &FOLLOW_INT_in_crit285); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecritEx;
        	        }

        	        INT38_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, INT38));
        	        ADAPTOR->addChild(ADAPTOR, root_0, INT38_tree);


        	    }
        	    break;
        	case 4:
        	    // SMARTPL.g:62:6: DATETAG ( AFTER | BEFORE ) dateval
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        DATETAG39 = (pANTLR3_COMMON_TOKEN) MATCHT(DATETAG, &FOLLOW_DATETAG_in_crit292); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecritEx;
        	        }

        	        DATETAG39_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DATETAG39));
        	        ADAPTOR->addChild(ADAPTOR, root_0, DATETAG39_tree);

        	        set40=(pANTLR3_COMMON_TOKEN)LT(1);
        	        if ( ((LA(1) >= AFTER) && (LA(1) <= BEFORE)) )
        	        {
        	            CONSUME();
        	            ADAPTOR->addChild(ADAPTOR, root_0, (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, set40)));
        	            PERRORRECOVERY=ANTLR3_FALSE;
        	        }
        	        else 
        	        {
        	            CONSTRUCTEX();
        	            EXCEPTION->type         = ANTLR3_MISMATCHED_SET_EXCEPTION;
        	            EXCEPTION->name         = (void *)ANTLR3_MISMATCHED_SET_NAME;
        	            EXCEPTION->expectingSet = &FOLLOW_set_in_crit294;
        	            RECOVERFROMMISMATCHEDSET(&FOLLOW_set_in_crit294);    goto rulecritEx;
        	        }

        	        FOLLOWPUSH(FOLLOW_dateval_in_crit300);
        	        dateval41=dateval(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecritEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, dateval41.tree);

        	    }
        	    break;
        	case 5:
        	    // SMARTPL.g:63:6: ENUMTAG IS ENUMVAL
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        ENUMTAG42 = (pANTLR3_COMMON_TOKEN) MATCHT(ENUMTAG, &FOLLOW_ENUMTAG_in_crit307); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecritEx;
        	        }

        	        ENUMTAG42_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, ENUMTAG42));
        	        ADAPTOR->addChild(ADAPTOR, root_0, ENUMTAG42_tree);

        	        IS43 = (pANTLR3_COMMON_TOKEN) MATCHT(IS, &FOLLOW_IS_in_crit309); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecritEx;
        	        }

        	        IS43_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, IS43));
        	        ADAPTOR->addChild(ADAPTOR, root_0, IS43_tree);

        	        ENUMVAL44 = (pANTLR3_COMMON_TOKEN) MATCHT(ENUMVAL, &FOLLOW_ENUMVAL_in_crit311); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecritEx;
        	        }

        	        ENUMVAL44_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, ENUMVAL44));
        	        ADAPTOR->addChild(ADAPTOR, root_0, ENUMVAL44_tree);


        	    }
        	    break;
        	case 6:
        	    // SMARTPL.g:64:6: GROUPTAG INTBOOL INT
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        GROUPTAG45 = (pANTLR3_COMMON_TOKEN) MATCHT(GROUPTAG, &FOLLOW_GROUPTAG_in_crit318); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecritEx;
        	        }

        	        GROUPTAG45_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, GROUPTAG45));
        	        ADAPTOR->addChild(ADAPTOR, root_0, GROUPTAG45_tree);

        	        INTBOOL46 = (pANTLR3_COMMON_TOKEN) MATCHT(INTBOOL, &FOLLOW_INTBOOL_in_crit320); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecritEx;
        	        }

        	        INTBOOL46_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, INTBOOL46));
        	        ADAPTOR->addChild(ADAPTOR, root_0, INTBOOL46_tree);

        	        INT47 = (pANTLR3_COMMON_TOKEN) MATCHT(INT, &FOLLOW_INT_in_crit322); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto rulecritEx;
        	        }

        	        INT47_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, INT47));
        	        ADAPTOR->addChild(ADAPTOR, root_0, INT47_tree);


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto rulecritEx; /* Prevent compiler warnings */
    rulecritEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);
        if (stream_RPAR != NULL) stream_RPAR->free(stream_RPAR);
        if (stream_LPAR != NULL) stream_LPAR->free(stream_LPAR);
        if (stream_expression != NULL) stream_expression->free(stream_expression);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end crit */

/** 
 * $ANTLR start dateval
 * SMARTPL.g:67:1: dateval : ( DATE | interval BEFORE DATE | interval AFTER DATE | interval AGO );
 */
static SMARTPLParser_dateval_return
dateval(pSMARTPLParser ctx)
{   
    SMARTPLParser_dateval_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    DATE48;
    pANTLR3_COMMON_TOKEN    BEFORE50;
    pANTLR3_COMMON_TOKEN    DATE51;
    pANTLR3_COMMON_TOKEN    AFTER53;
    pANTLR3_COMMON_TOKEN    DATE54;
    pANTLR3_COMMON_TOKEN    AGO56;
    SMARTPLParser_interval_return interval49;
    #undef	RETURN_TYPE_interval49
    #define	RETURN_TYPE_interval49 SMARTPLParser_interval_return

    SMARTPLParser_interval_return interval52;
    #undef	RETURN_TYPE_interval52
    #define	RETURN_TYPE_interval52 SMARTPLParser_interval_return

    SMARTPLParser_interval_return interval55;
    #undef	RETURN_TYPE_interval55
    #define	RETURN_TYPE_interval55 SMARTPLParser_interval_return

    pANTLR3_BASE_TREE DATE48_tree;
    pANTLR3_BASE_TREE BEFORE50_tree;
    pANTLR3_BASE_TREE DATE51_tree;
    pANTLR3_BASE_TREE AFTER53_tree;
    pANTLR3_BASE_TREE DATE54_tree;
    pANTLR3_BASE_TREE AGO56_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    DATE48       = NULL;
    BEFORE50       = NULL;
    DATE51       = NULL;
    AFTER53       = NULL;
    DATE54       = NULL;
    AGO56       = NULL;
    interval49.tree = NULL;

    interval52.tree = NULL;

    interval55.tree = NULL;

    retval.start = LT(1); retval.stop = retval.start;

    DATE48_tree   = NULL;
    BEFORE50_tree   = NULL;
    DATE51_tree   = NULL;
    AFTER53_tree   = NULL;
    DATE54_tree   = NULL;
    AGO56_tree   = NULL;


    retval.tree  = NULL;
    {
        {
            //  SMARTPL.g:67:10: ( DATE | interval BEFORE DATE | interval AFTER DATE | interval AGO )
            
            ANTLR3_UINT32 alt10;

            alt10=4;

            switch ( LA(1) ) 
            {
            case DATE:
            	{
            		alt10=1;
            	}
                break;
            case INT:
            	{
            		switch ( LA(2) ) 
            		{
            		case DATINTERVAL:
            			{
            				switch ( LA(3) ) 
            				{
            				case AFTER:
            					{
            						alt10=3;
            					}
            				    break;
            				case BEFORE:
            					{
            						alt10=2;
            					}
            				    break;
            				case AGO:
            					{
            						alt10=4;
            					}
            				    break;

            				default:
            				    CONSTRUCTEX();
            				    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            				    EXCEPTION->message      = (void *)"";
            				    EXCEPTION->decisionNum  = 10;
            				    EXCEPTION->state        = 3;


            				    goto ruledatevalEx;
            				}

            			}
            		    break;

            		default:
            		    CONSTRUCTEX();
            		    EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
            		    EXCEPTION->message      = (void *)"";
            		    EXCEPTION->decisionNum  = 10;
            		    EXCEPTION->state        = 2;


            		    goto ruledatevalEx;
            		}

            	}
                break;

            default:
                CONSTRUCTEX();
                EXCEPTION->type         = ANTLR3_NO_VIABLE_ALT_EXCEPTION;
                EXCEPTION->message      = (void *)"";
                EXCEPTION->decisionNum  = 10;
                EXCEPTION->state        = 0;


                goto ruledatevalEx;
            }

            switch (alt10) 
            {
        	case 1:
        	    // SMARTPL.g:67:12: DATE
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        DATE48 = (pANTLR3_COMMON_TOKEN) MATCHT(DATE, &FOLLOW_DATE_in_dateval335); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledatevalEx;
        	        }

        	        DATE48_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DATE48));
        	        ADAPTOR->addChild(ADAPTOR, root_0, DATE48_tree);


        	    }
        	    break;
        	case 2:
        	    // SMARTPL.g:68:6: interval BEFORE DATE
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_interval_in_dateval342);
        	        interval49=interval(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledatevalEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, interval49.tree);
        	        BEFORE50 = (pANTLR3_COMMON_TOKEN) MATCHT(BEFORE, &FOLLOW_BEFORE_in_dateval344); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledatevalEx;
        	        }

        	        BEFORE50_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, BEFORE50));
        	        ADAPTOR->addChild(ADAPTOR, root_0, BEFORE50_tree);

        	        DATE51 = (pANTLR3_COMMON_TOKEN) MATCHT(DATE, &FOLLOW_DATE_in_dateval346); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledatevalEx;
        	        }

        	        DATE51_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DATE51));
        	        ADAPTOR->addChild(ADAPTOR, root_0, DATE51_tree);


        	    }
        	    break;
        	case 3:
        	    // SMARTPL.g:69:6: interval AFTER DATE
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_interval_in_dateval353);
        	        interval52=interval(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledatevalEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, interval52.tree);
        	        AFTER53 = (pANTLR3_COMMON_TOKEN) MATCHT(AFTER, &FOLLOW_AFTER_in_dateval355); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledatevalEx;
        	        }

        	        AFTER53_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, AFTER53));
        	        ADAPTOR->addChild(ADAPTOR, root_0, AFTER53_tree);

        	        DATE54 = (pANTLR3_COMMON_TOKEN) MATCHT(DATE, &FOLLOW_DATE_in_dateval357); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledatevalEx;
        	        }

        	        DATE54_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DATE54));
        	        ADAPTOR->addChild(ADAPTOR, root_0, DATE54_tree);


        	    }
        	    break;
        	case 4:
        	    // SMARTPL.g:70:6: interval AGO
        	    {
        	        root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

        	        FOLLOWPUSH(FOLLOW_interval_in_dateval364);
        	        interval55=interval(ctx);

        	        FOLLOWPOP();
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledatevalEx;
        	        }

        	        ADAPTOR->addChild(ADAPTOR, root_0, interval55.tree);
        	        AGO56 = (pANTLR3_COMMON_TOKEN) MATCHT(AGO, &FOLLOW_AGO_in_dateval366); 
        	        if  (HASEXCEPTION())
        	        {
        	            goto ruledatevalEx;
        	        }

        	        AGO56_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, AGO56));
        	        ADAPTOR->addChild(ADAPTOR, root_0, AGO56_tree);


        	    }
        	    break;

            }
        }
    }
    

    // This is where rules clean up and exit
    //
    goto ruledatevalEx; /* Prevent compiler warnings */
    ruledatevalEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end dateval */

/** 
 * $ANTLR start interval
 * SMARTPL.g:73:1: interval : INT DATINTERVAL ;
 */
static SMARTPLParser_interval_return
interval(pSMARTPLParser ctx)
{   
    SMARTPLParser_interval_return retval;

    pANTLR3_BASE_TREE root_0;

    pANTLR3_COMMON_TOKEN    INT57;
    pANTLR3_COMMON_TOKEN    DATINTERVAL58;

    pANTLR3_BASE_TREE INT57_tree;
    pANTLR3_BASE_TREE DATINTERVAL58_tree;

    /* Initialize rule variables
     */


    root_0 = NULL;

    INT57       = NULL;
    DATINTERVAL58       = NULL;
    retval.start = LT(1); retval.stop = retval.start;

    INT57_tree   = NULL;
    DATINTERVAL58_tree   = NULL;


    retval.tree  = NULL;
    {
        // SMARTPL.g:73:10: ( INT DATINTERVAL )
        // SMARTPL.g:73:12: INT DATINTERVAL
        {
            root_0 = (pANTLR3_BASE_TREE)(ADAPTOR->nilNode(ADAPTOR));

            INT57 = (pANTLR3_COMMON_TOKEN) MATCHT(INT, &FOLLOW_INT_in_interval378); 
            if  (HASEXCEPTION())
            {
                goto ruleintervalEx;
            }

            INT57_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, INT57));
            ADAPTOR->addChild(ADAPTOR, root_0, INT57_tree);

            DATINTERVAL58 = (pANTLR3_COMMON_TOKEN) MATCHT(DATINTERVAL, &FOLLOW_DATINTERVAL_in_interval380); 
            if  (HASEXCEPTION())
            {
                goto ruleintervalEx;
            }

            DATINTERVAL58_tree = (pANTLR3_BASE_TREE)(ADAPTOR->create(ADAPTOR, DATINTERVAL58));
            ADAPTOR->addChild(ADAPTOR, root_0, DATINTERVAL58_tree);


        }

    }
    

    // This is where rules clean up and exit
    //
    goto ruleintervalEx; /* Prevent compiler warnings */
    ruleintervalEx: ;
    retval.stop = LT(-1);

    	retval.stop = LT(-1);
    	retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->rulePostProcessing(ADAPTOR, root_0));
    	ADAPTOR->setTokenBoundaries(ADAPTOR, retval.tree, retval.start, retval.stop);

            if (HASEXCEPTION())
            {
                PREPORTERROR();
                PRECOVER();
                retval.tree = (pANTLR3_BASE_TREE)(ADAPTOR->errorNode(ADAPTOR, INPUT, retval.start, LT(-1), EXCEPTION));
            }


    return retval;
}
/* $ANTLR end interval */
/* End of parsing rules
 * ==============================================
 */

/* ==============================================
 * Syntactic predicates
 */
/* End of syntactic predicates
 * ==============================================
 */

 
 



/* End of code
 * =============================================================================
 */
