diff --git a/3rdparty/angle/CMakeLists.txt b/3rdparty/angle/CMakeLists.txt
index bc4a42c2417ef72b76f3fd8b011520db29a6d17f..4aecd08c9893f7c2a7eeb4964f80aa44bd333d68 100644
--- a/3rdparty/angle/CMakeLists.txt
+++ b/3rdparty/angle/CMakeLists.txt
@@ -2,7 +2,12 @@ include_directories(include)
 include_directories(src)
 
 set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -fno-strict-aliasing")
-set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fno-strict-aliasing")
+if(USE_CXX11_THREAD_LOCAL_STORAGE)
+    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fno-strict-aliasing -std=c++11")
+    add_definitions(-DUSE_CXX11_THREAD_LOCAL)
+else()
+    set(CMAKE_CXX_FLAGS "${CMAKE_CXX_FLAGS} -fno-strict-aliasing")
+endif()
 
 add_library(shader_translator STATIC
     src/common/Float16ToFloat32.cpp
diff --git a/3rdparty/angle/src/common/tls.cpp b/3rdparty/angle/src/common/tls.cpp
index cb1b32d3258a85803e01f9b4906a49a30960e5d6..0edf0a7f2361726860ad7229ae00a7ac52640ef6 100644
--- a/3rdparty/angle/src/common/tls.cpp
+++ b/3rdparty/angle/src/common/tls.cpp
@@ -10,7 +10,7 @@
 
 #include <assert.h>
 
-#ifdef ANGLE_ENABLE_WINDOWS_STORE
+#if defined(ANGLE_ENABLE_WINDOWS_STORE)
 #include <vector>
 #include <set>
 #include <map>
@@ -29,8 +29,21 @@ typedef vector<void*> ThreadLocalData;
 
 static __declspec(thread) ThreadLocalData* currentThreadData = nullptr;
 static set<ThreadLocalData*> allThreadData;
-static DWORD nextTlsIndex = 0;
-static vector<DWORD> freeTlsIndices;
+static TLSIndex nextTlsIndex = 0;
+static vector<TLSIndex> freeTlsIndices;
+
+#elif defined(USE_CXX11_THREAD_LOCAL)
+#include <vector>
+#include <set>
+
+using namespace std;
+// Thread local storage using C++11 thread_local
+typedef vector<void*> ThreadLocalData;
+
+static thread_local ThreadLocalData* currentThreadData = nullptr;
+static set<ThreadLocalData*> allThreadData;
+static TLSIndex nextTlsIndex = 0;
+static vector<TLSIndex> freeTlsIndices;
 
 #endif
 
@@ -38,11 +51,10 @@ TLSIndex CreateTLSIndex()
 {
     TLSIndex index;
 
-#ifdef ANGLE_PLATFORM_WINDOWS
-#ifdef ANGLE_ENABLE_WINDOWS_STORE
+#if defined(ANGLE_ENABLE_WINDOWS_STORE) || defined(USE_CXX11_THREAD_LOCAL)
     if (!freeTlsIndices.empty())
     {
-        DWORD result = freeTlsIndices.back();
+        TLSIndex result = freeTlsIndices.back();
         freeTlsIndices.pop_back();
         index = result;
     }
@@ -50,10 +62,8 @@ TLSIndex CreateTLSIndex()
     {
         index = nextTlsIndex++;
     }
-#else
+#elif defined(ANGLE_PLATFORM_WINDOWS)
     index = TlsAlloc();
-#endif
-
 #elif defined(ANGLE_PLATFORM_POSIX)
     // Create global pool key
     if ((pthread_key_create(&index, NULL)) != 0)
@@ -74,8 +84,7 @@ bool DestroyTLSIndex(TLSIndex index)
         return false;
     }
 
-#ifdef ANGLE_PLATFORM_WINDOWS
-#ifdef ANGLE_ENABLE_WINDOWS_STORE
+#if defined(ANGLE_ENABLE_WINDOWS_STORE) || defined(USE_CXX11_THREAD_LOCAL)
     assert(index < nextTlsIndex);
     assert(find(freeTlsIndices.begin(), freeTlsIndices.end(), index) == freeTlsIndices.end());
 
@@ -88,9 +97,8 @@ bool DestroyTLSIndex(TLSIndex index)
         }
     }
     return true;
-#else
+#elif defined(ANGLE_PLATFORM_WINDOWS)
     return (TlsFree(index) == TRUE);
-#endif
 #elif defined(ANGLE_PLATFORM_POSIX)
     return (pthread_key_delete(index) == 0);
 #endif
@@ -104,8 +112,7 @@ bool SetTLSValue(TLSIndex index, void *value)
         return false;
     }
 
-#ifdef ANGLE_PLATFORM_WINDOWS
-#ifdef ANGLE_ENABLE_WINDOWS_STORE
+#if defined(ANGLE_ENABLE_WINDOWS_STORE) || defined(USE_CXX11_THREAD_LOCAL)
     ThreadLocalData* threadData = currentThreadData;
     if (!threadData)
     {
@@ -120,9 +127,8 @@ bool SetTLSValue(TLSIndex index, void *value)
 
     threadData->at(index) = value;
     return true;
-#else
+#elif defined(ANGLE_PLATFORM_WINDOWS)
     return (TlsSetValue(index, value) == TRUE);
-#endif
 #elif defined(ANGLE_PLATFORM_POSIX)
     return (pthread_setspecific(index, value) == 0);
 #endif
@@ -136,8 +142,7 @@ void *GetTLSValue(TLSIndex index)
         return NULL;
     }
 
-#ifdef ANGLE_PLATFORM_WINDOWS
-#ifdef ANGLE_ENABLE_WINDOWS_STORE
+#if defined(ANGLE_ENABLE_WINDOWS_STORE) || defined(USE_CXX11_THREAD_LOCAL)
     ThreadLocalData* threadData = currentThreadData;
     if (threadData && threadData->size() > index)
     {
@@ -147,9 +152,8 @@ void *GetTLSValue(TLSIndex index)
     {
         return nullptr;
     }
-#else
+#elif defined(ANGLE_PLATFORM_WINDOWS)
     return TlsGetValue(index);
-#endif
 #elif defined(ANGLE_PLATFORM_POSIX)
     return pthread_getspecific(index);
 #endif
diff --git a/3rdparty/angle/src/common/tls.h b/3rdparty/angle/src/common/tls.h
index ca9e07ab700ae9dbaab1c7e77ae9e66981bca812..5e7177d2b84cf08b7efa2d2c5e4361fe609c861c 100644
--- a/3rdparty/angle/src/common/tls.h
+++ b/3rdparty/angle/src/common/tls.h
@@ -14,15 +14,25 @@
 #ifdef ANGLE_PLATFORM_WINDOWS
 
 // TLS does not exist for Windows Store and needs to be emulated
+    typedef DWORD TLSIndex;
 #   ifdef ANGLE_ENABLE_WINDOWS_STORE
 #       ifndef TLS_OUT_OF_INDEXES
-#           define TLS_OUT_OF_INDEXES static_cast<DWORD>(0xFFFFFFFF)
+#           define TLS_OUT_OF_INDEXES static_cast<TLSIndex>(0xFFFFFFFF)
 #       endif
 #       ifndef CREATE_SUSPENDED
 #           define CREATE_SUSPENDED 0x00000004
 #       endif
 #   endif
-    typedef DWORD TLSIndex;
+#   define TLS_INVALID_INDEX (TLS_OUT_OF_INDEXES)
+#elif defined(USE_CXX11_THREAD_LOCAL)
+#   include <cstdint>
+    typedef uint32_t TLSIndex;
+#   ifndef TLS_OUT_OF_INDEXES
+#       define TLS_OUT_OF_INDEXES static_cast<TLSIndex>(0xFFFFFFFF)
+#   endif
+#   ifndef CREATE_SUSPENDED
+#       define CREATE_SUSPENDED 0x00000004
+#   endif
 #   define TLS_INVALID_INDEX (TLS_OUT_OF_INDEXES)
 #elif defined(ANGLE_PLATFORM_POSIX)
 #   include <pthread.h>
diff --git a/CMakeLists.txt b/CMakeLists.txt
index bdd56840f4cc3721f0cae8c0a83e0d93e2b915e4..6fa098062397074cb3f8693319c31066211ef83e 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -6,6 +6,9 @@ set(VER_MAJOR 0)
 set(VER_MINOR 3)
 set(VER_MICRO 9)
 
+option(USE_CXX11_THREAD_LOCAL_STORAGE
+    "Use C++11 thread-local storage instead of pthread g/setspecific on Unix" OFF)
+
 # setup compiler flags
 set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -std=gnu99 -fPIC -pthread")
 set(CMAKE_C_FLAGS "${CMAKE_C_FLAGS} -Wall -Werror=format-security")
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 969cfc51a2bf9b1734c5c4a2a070a8168514438b..eb25c586626fce1440be7758c468875cbe9dd127 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -3,6 +3,10 @@ if(${TRACE_ALL})
     add_definitions(-DTRACE_ALL)
 endif()
 
+if(USE_CXX11_THREAD_LOCAL_STORAGE)
+    add_definitions(-DUSE_CXX11_THREAD_LOCAL)
+endif()
+
 set(CMAKE_LIBRARY_OUTPUT_DIRECTORY ${CMAKE_BINARY_DIR})
 
 set(MOZPLUGIN_INSTALL_DIR "lib${LIB_SUFFIX}/mozilla/plugins/" CACHE STRING "plugin install directory")
@@ -87,6 +91,10 @@ set(source_list
     x11_event_thread.c
 )
 
+if (NOT USE_CXX11_THREAD_LOCAL_STORAGE)
+    set(source_list ${source_list} angle_tls.cpp)
+endif()
+
 if (PULSEAUDIO_FOUND AND WITH_PULSEAUDIO)
     list(APPEND source_list audio_thread_pulseaudio.c)
 endif()
diff --git a/src/angle_tls.cpp b/src/angle_tls.cpp
new file mode 100644
index 0000000000000000000000000000000000000000..a10cdce8223ad3b0927c0a8acf9390457ec1339d
--- /dev/null
+++ b/src/angle_tls.cpp
@@ -0,0 +1,147 @@
+//
+// Copyright (c) 2014 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+
+// tls.cpp: Simple cross-platform interface for thread local storage.
+
+#include "angle_tls.h"
+
+#include <assert.h>
+
+#if defined(ANGLE_ENABLE_WINDOWS_STORE)
+#include <vector>
+#include <set>
+#include <map>
+#include <mutex>
+
+#include <wrl/client.h>
+#include <wrl/async.h>
+#include <Windows.System.Threading.h>
+
+using namespace std;
+using namespace Windows::Foundation;
+using namespace ABI::Windows::System::Threading;
+
+// Thread local storage for Windows Store support
+typedef vector<void*> ThreadLocalData;
+
+static __declspec(thread) ThreadLocalData* currentThreadData = nullptr;
+static set<ThreadLocalData*> allThreadData;
+static TLSIndex nextTlsIndex = 0;
+static vector<TLSIndex> freeTlsIndices;
+
+#endif
+
+TLSIndex CreateTLSIndex()
+{
+    TLSIndex index;
+
+#if defined(ANGLE_ENABLE_WINDOWS_STORE)
+    if (!freeTlsIndices.empty())
+    {
+        TLSIndex result = freeTlsIndices.back();
+        freeTlsIndices.pop_back();
+        index = result;
+    }
+    else
+    {
+        index = nextTlsIndex++;
+    }
+#elif defined(ANGLE_PLATFORM_WINDOWS)
+    index = TlsAlloc();
+#elif defined(ANGLE_PLATFORM_POSIX)
+    // Create global pool key
+    if ((pthread_key_create(&index, NULL)) != 0)
+    {
+        index = TLS_INVALID_INDEX;
+    }
+#endif
+
+    assert(index != TLS_INVALID_INDEX && "CreateTLSIndex(): Unable to allocate Thread Local Storage");
+    return index;
+}
+
+int DestroyTLSIndex(TLSIndex index)
+{
+    assert(index != TLS_INVALID_INDEX && "DestroyTLSIndex(): Invalid TLS Index");
+    if (index == TLS_INVALID_INDEX)
+    {
+        return false;
+    }
+
+#if defined(ANGLE_ENABLE_WINDOWS_STORE)
+    assert(index < nextTlsIndex);
+    assert(find(freeTlsIndices.begin(), freeTlsIndices.end(), index) == freeTlsIndices.end());
+
+    freeTlsIndices.push_back(index);
+    for (auto threadData : allThreadData)
+    {
+        if (threadData->size() > index)
+        {
+            threadData->at(index) = nullptr;
+        }
+    }
+    return true;
+#elif defined(ANGLE_PLATFORM_WINDOWS)
+    return (TlsFree(index) == TRUE);
+#elif defined(ANGLE_PLATFORM_POSIX)
+    return (pthread_key_delete(index) == 0);
+#endif
+}
+
+int SetTLSValue(TLSIndex index, void *value)
+{
+    assert(index != TLS_INVALID_INDEX && "SetTLSValue(): Invalid TLS Index");
+    if (index == TLS_INVALID_INDEX)
+    {
+        return false;
+    }
+
+#if defined(ANGLE_ENABLE_WINDOWS_STORE)
+    ThreadLocalData* threadData = currentThreadData;
+    if (!threadData)
+    {
+        threadData = new ThreadLocalData(index + 1, nullptr);
+        allThreadData.insert(threadData);
+        currentThreadData = threadData;
+    }
+    else if (threadData->size() <= index)
+    {
+        threadData->resize(index + 1, nullptr);
+    }
+
+    threadData->at(index) = value;
+    return true;
+#elif defined(ANGLE_PLATFORM_WINDOWS)
+    return (TlsSetValue(index, value) == TRUE);
+#elif defined(ANGLE_PLATFORM_POSIX)
+    return (pthread_setspecific(index, value) == 0);
+#endif
+}
+
+void *GetTLSValue(TLSIndex index)
+{
+    assert(index != TLS_INVALID_INDEX && "GetTLSValue(): Invalid TLS Index");
+    if (index == TLS_INVALID_INDEX)
+    {
+        return NULL;
+    }
+
+#if defined(ANGLE_ENABLE_WINDOWS_STORE)
+    ThreadLocalData* threadData = currentThreadData;
+    if (threadData && threadData->size() > index)
+    {
+        return threadData->at(index);
+    }
+    else
+    {
+        return nullptr;
+    }
+#elif defined(ANGLE_PLATFORM_WINDOWS)
+    return TlsGetValue(index);
+#elif defined(ANGLE_PLATFORM_POSIX)
+    return pthread_getspecific(index);
+#endif
+}
diff --git a/src/angle_tls.h b/src/angle_tls.h
new file mode 100644
index 0000000000000000000000000000000000000000..978170113d4453821b43afdc647e42e6d69763d2
--- /dev/null
+++ b/src/angle_tls.h
@@ -0,0 +1,76 @@
+//
+// Copyright (c) 2014 The ANGLE Project Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+//
+
+// tls.h: Simple cross-platform interface for thread local storage.
+
+#ifndef COMMON_TLS_H_
+#define COMMON_TLS_H_
+
+#if defined(_WIN32) || defined(_WIN64)
+#   define ANGLE_PLATFORM_WINDOWS 1
+#elif defined(__APPLE__)
+#   define ANGLE_PLATFORM_APPLE 1
+#   define ANGLE_PLATFORM_POSIX 1
+#elif defined(ANDROID)
+#   define ANGLE_PLATFORM_ANDROID 1
+#   define ANGLE_PLATFORM_POSIX 1
+#elif defined(__linux__) || defined(EMSCRIPTEN)
+#   define ANGLE_PLATFORM_LINUX 1
+#   define ANGLE_PLATFORM_POSIX 1
+#elif defined(__FreeBSD__) || \
+      defined(__OpenBSD__) || \
+      defined(__NetBSD__) || \
+      defined(__DragonFly__) || \
+      defined(__sun) || \
+      defined(__GLIBC__) || \
+      defined(__GNU__) || \
+      defined(__QNX__)
+#   define ANGLE_PLATFORM_POSIX 1
+#else
+#   error Unsupported platform.
+#endif
+
+#ifdef __cplusplus
+extern "C" {
+#endif
+
+#ifdef ANGLE_PLATFORM_WINDOWS
+
+// TLS does not exist for Windows Store and needs to be emulated
+    typedef DWORD TLSIndex;
+#   ifdef ANGLE_ENABLE_WINDOWS_STORE
+#       ifndef TLS_OUT_OF_INDEXES
+#           define TLS_OUT_OF_INDEXES (TLSIndex)(0xFFFFFFFF)
+#       endif
+#       ifndef CREATE_SUSPENDED
+#           define CREATE_SUSPENDED 0x00000004
+#       endif
+#   endif
+#   define TLS_INVALID_INDEX (TLS_OUT_OF_INDEXES)
+#elif defined(ANGLE_PLATFORM_POSIX)
+#   include <pthread.h>
+#   include <semaphore.h>
+#   include <errno.h>
+    typedef pthread_key_t TLSIndex;
+#   define TLS_INVALID_INDEX ((TLSIndex)(-1))
+#else
+#   error Unsupported platform.
+#endif
+
+// TODO(kbr): for POSIX platforms this will have to be changed to take
+// in a destructor function pointer, to allow the thread-local storage
+// to be properly deallocated upon thread exit.
+TLSIndex CreateTLSIndex();
+int DestroyTLSIndex(TLSIndex index);
+
+int SetTLSValue(TLSIndex index, void *value);
+void *GetTLSValue(TLSIndex index);
+
+#ifdef __cplusplus
+}
+#endif
+
+#endif // COMMON_TLS_H_
diff --git a/src/ppb_message_loop.c b/src/ppb_message_loop.c
index c18c83d5f0ad1fb77e19e31df780b910a5c7a34f..ae19c3c705e314cfeb74bfeb9f88fa2fef076ae1 100644
--- a/src/ppb_message_loop.c
+++ b/src/ppb_message_loop.c
@@ -29,6 +29,7 @@
 #include "static_assert.h"
 #include "tables.h"
 #include "trace_core.h"
+#include "angle_tls.h"
 #include <glib.h>
 #include <inttypes.h>
 #include <ppapi/c/pp_errors.h>
@@ -47,8 +48,56 @@ struct pp_message_loop_s {
 
 STATIC_ASSERT(sizeof(struct pp_message_loop_s) <= LARGEST_RESOURCE_SIZE);
 
+#ifdef USE_CXX11_THREAD_LOCAL
 static __thread PP_Resource this_thread_message_loop = 0;
 static __thread int         thread_is_not_suitable_for_message_loop = 0;
+#else
+
+static TLSIndex loop_index, loop_suitable_index;
+static PP_Resource *this_thread_message_loop_ptr = NULL;
+static int *thread_is_not_suitable_for_message_loop_ptr = NULL;
+
+__attribute__((constructor)) void ppb_message_loop_init()
+{
+    loop_index = CreateTLSIndex();
+    loop_suitable_index = CreateTLSIndex();
+}
+
+static void GetMessageLoop()
+{
+    if (!(this_thread_message_loop_ptr = GetTLSValue(loop_index))) {
+        this_thread_message_loop_ptr = (PP_Resource*) calloc(1, sizeof(PP_Resource));
+        SetTLSValue(loop_index, this_thread_message_loop_ptr);
+    }
+}
+
+static void GetIsSuitable()
+{
+    if (!(thread_is_not_suitable_for_message_loop_ptr = GetTLSValue(loop_suitable_index))) {
+        thread_is_not_suitable_for_message_loop_ptr = (int*) calloc(1, sizeof(int));
+        SetTLSValue(loop_suitable_index, thread_is_not_suitable_for_message_loop_ptr);
+    }
+}
+
+__attribute__((destructor)) void ppb_message_loop_finish()
+{
+    if (this_thread_message_loop_ptr = GetTLSValue(loop_index)) {
+        free(this_thread_message_loop_ptr);
+    }
+    if (thread_is_not_suitable_for_message_loop_ptr = GetTLSValue(loop_suitable_index)) {
+        free(thread_is_not_suitable_for_message_loop_ptr);
+    }
+    SetTLSValue(loop_index, NULL);
+    SetTLSValue(loop_suitable_index, NULL);
+    DestroyTLSIndex(loop_index);
+    DestroyTLSIndex(loop_suitable_index);
+}
+
+#define this_thread_message_loop (*this_thread_message_loop_ptr)
+#define thread_is_not_suitable_for_message_loop (*this_thread_message_loop_ptr)
+
+#endif
+
 static          PP_Resource main_thread_message_loop = 0;
 static          PP_Resource browser_thread_message_loop = 0;
 
@@ -131,6 +180,9 @@ ppb_message_loop_get_for_main_thread(void)
 int32_t
 ppb_message_loop_proclaim_this_thread_main(void)
 {
+#ifndef USE_CXX11_THREAD_LOCAL
+    GetMessageLoop();
+#endif
     if (this_thread_message_loop == 0) {
         trace_error("%s, no message loop attached\n", __func__);
         return PP_ERROR_WRONG_THREAD;
@@ -149,6 +201,9 @@ ppb_message_loop_get_for_browser_thread(void)
 int32_t
 ppb_message_loop_proclaim_this_thread_browser(void)
 {
+#ifndef USE_CXX11_THREAD_LOCAL
+    GetMessageLoop();
+#endif
     if (this_thread_message_loop == 0) {
         trace_error("%s, no message loop attached\n", __func__);
         return PP_ERROR_WRONG_THREAD;
@@ -161,6 +216,9 @@ ppb_message_loop_proclaim_this_thread_browser(void)
 PP_Resource
 ppb_message_loop_get_current(void)
 {
+#ifndef USE_CXX11_THREAD_LOCAL
+    GetMessageLoop();
+#endif
     return this_thread_message_loop;
 }
 
@@ -181,6 +239,9 @@ ppb_message_loop_get_depth(PP_Resource message_loop)
 void
 ppb_message_loop_mark_thread_unsuitable(void)
 {
+#ifndef USE_CXX11_THREAD_LOCAL
+    GetIsSuitable();
+#endif
     thread_is_not_suitable_for_message_loop = 1;
 }
 
@@ -192,11 +253,17 @@ ppb_message_loop_attach_to_current_thread(PP_Resource message_loop)
         return PP_ERROR_BADRESOURCE;
     }
 
+#ifndef USE_CXX11_THREAD_LOCAL
+    GetIsSuitable();
+#endif
     if (thread_is_not_suitable_for_message_loop) {
         trace_error("%s, can't attach to this thread\n", __func__);
         return PP_ERROR_WRONG_THREAD;
     }
 
+#ifndef USE_CXX11_THREAD_LOCAL
+    GetMessageLoop();
+#endif
     if (this_thread_message_loop != 0) {
         trace_error("%s, thread already have message loop attached\n", __func__);
         return PP_ERROR_INPROGRESS;
@@ -263,6 +330,9 @@ find_first_task_with_appropriate_depth(GTree *q, int current_depth)
 int32_t
 ppb_message_loop_run_int(PP_Resource message_loop, uint32_t flags)
 {
+#ifndef USE_CXX11_THREAD_LOCAL
+    GetMessageLoop();
+#endif
     if (this_thread_message_loop != message_loop) {
         trace_error("%s, not attached to current thread\n", __func__);
         return PP_ERROR_WRONG_THREAD;
diff --git a/src/trace_core.c b/src/trace_core.c
index 11f531189e2da61c42db74710857685243942a9e..e9a62fae41c0fd125b248b3b831d0d9e11cad22d 100644
--- a/src/trace_core.c
+++ b/src/trace_core.c
@@ -24,7 +24,9 @@
 
 #include "config.h"
 #include "trace_core.h"
+#include "angle_tls.h"
 #include <pthread.h>
+#include <stdlib.h>
 #include <stdarg.h>
 #include <stdio.h>
 #include <sys/syscall.h>
@@ -32,7 +34,38 @@
 #include <unistd.h>
 
 static pthread_mutex_t lock = PTHREAD_MUTEX_INITIALIZER;
+
+#ifdef USE_CXX11_THREAD_LOCAL
 static __thread struct timespec tictoc_ts;
+#define TICTOC (&tictoc_ts)
+#else
+
+static TLSIndex tictoc_index;
+static struct timespec *tictoc_ts = NULL;
+
+__attribute__((constructor)) void trace_core_init()
+{
+    tictoc_index = CreateTLSIndex();
+}
+
+static void getTICTOC()
+{
+    if (!(tictoc_ts = GetTLSValue(tictoc_index))) {
+        tictoc_ts = (struct timespec*) calloc(1, sizeof(struct timespec));
+        SetTLSValue(tictoc_index, tictoc_ts);
+    }
+}
+
+__attribute__((destructor)) void trace_core_finish()
+{
+    if (tictoc_ts = GetTLSValue(tictoc_index)) {
+        free(tictoc_ts);
+    }
+    SetTLSValue(tictoc_index, NULL);
+    DestroyTLSIndex(tictoc_index);
+}
+#define TICTOC tictoc_ts
+#endif
 
 
 void
@@ -87,16 +120,24 @@ trace_error(const char *fmt, ...)
     pthread_mutex_unlock(&lock);
 }
 
+#ifdef BUILD_TRACE_BENCHMARK
 void
 trace_duration_tic(void)
 {
-    clock_gettime(CLOCK_REALTIME, &tictoc_ts);
+#ifndef USE_CXX11_THREAD_LOCAL
+    getTICTOC();
+#endif
+    clock_gettime(CLOCK_REALTIME, TICTOC);
 }
 
 double
 trace_duration_toc(void)
 {
+#ifndef USE_CXX11_THREAD_LOCAL
+    getTICTOC();
+#endif
     struct timespec ts;
     clock_gettime(CLOCK_REALTIME, &ts);
-    return (ts.tv_sec - tictoc_ts.tv_sec) + 1e-9 * (ts.tv_nsec - tictoc_ts.tv_nsec);
+    return (ts.tv_sec - TICTOC->tv_sec) + 1e-9 * (ts.tv_nsec - TICTOC->tv_nsec);
 }
+#endif
